#!/bin/bash
set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# GHA24 - Submit task to FUGUE Tutti (agent consensus)
# Usage: gha24 "task description" [--implement|--review] [--repo owner/repo] [--orchestrator codex|claude] [--assist-orchestrator claude|codex|none] [--force-claude] [--local-run|--gha-only]
#
# Options:
#   --implement    Add implement intent labels to trigger post-vote implementation
#   --review       Force review-only mode (ignore natural language hints)
#   --repo REPO    Target repository to operate on (default: cursorvers/fugue-orchestrator)
#   --orchestrator Per-request orchestrator override (codex|claude)
#   --assist-orchestrator Per-request assist orchestrator override (claude|codex|none)
#   --force-claude Force claude provider(s) for this issue even when repo fallback state is degraded/exhausted
#   --local-run    Force local orchestration run after issue creation
#   --gha-only     Disable local auto-fallback run
#
# Notes:
#   Default mode is implement unless review-only intent is explicit.
#   The issue is always created in the orchestrator repo. The target repo is
#   passed via the issue body so the caller workflow can resolve it.
#
# Secrets strategy:
#   Prefer GitHub Organization secrets (selected repos) over per-repo secrets.
#   Run scripts/audit-org-secrets.sh to verify coverage.

TASK=""
ORCHESTRATOR_REPO="${GHA24_ORCHESTRATOR_REPO:-cursorvers/fugue-orchestrator}"
TARGET_REPO="cursorvers/fugue-orchestrator"
IMPLEMENT=true
MODE_EXPLICIT=false
ORCHESTRATOR_PROVIDER="${GHA24_ORCHESTRATOR_PROVIDER:-}"
ORCHESTRATOR_PROVIDER_EXPLICIT=false
ASSIST_ORCHESTRATOR_PROVIDER="${GHA24_ASSIST_ORCHESTRATOR_PROVIDER:-}"
ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=false
FORCE_CLAUDE=false
LOCAL_RUN_MODE="${GHA24_LOCAL_RUN_MODE:-force}" # auto|force|off
LOCAL_POST_COMMENT="${GHA24_LOCAL_POST_COMMENT:-true}"
LOCAL_MAX_PARALLEL="${GHA24_LOCAL_MAX_PARALLEL:-4}"
LOCAL_RUN_MODE_EXPLICIT=false
if [[ -n "${GHA24_ORCHESTRATOR_PROVIDER:-}" ]]; then
  ORCHESTRATOR_PROVIDER_EXPLICIT=true
fi
if [[ -n "${GHA24_ASSIST_ORCHESTRATOR_PROVIDER:-}" ]]; then
  ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=true
fi
if [[ -n "${GHA24_LOCAL_RUN_MODE:-}" ]]; then
  LOCAL_RUN_MODE_EXPLICIT=true
fi

while [[ $# -gt 0 ]]; do
  case "${1}" in
    --implement)
      IMPLEMENT=true
      MODE_EXPLICIT=true
      shift
      ;;
    --review)
      IMPLEMENT=false
      MODE_EXPLICIT=true
      shift
      ;;
    --repo)
      TARGET_REPO="${2}"
      shift 2
      ;;
    --orchestrator)
      ORCHESTRATOR_PROVIDER="${2}"
      ORCHESTRATOR_PROVIDER_EXPLICIT=true
      shift 2
      ;;
    --assist-orchestrator)
      ASSIST_ORCHESTRATOR_PROVIDER="${2}"
      ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=true
      shift 2
      ;;
    --force-claude)
      FORCE_CLAUDE=true
      shift
      ;;
    --local-run)
      LOCAL_RUN_MODE="force"
      LOCAL_RUN_MODE_EXPLICIT=true
      shift
      ;;
    --gha-only)
      LOCAL_RUN_MODE="off"
      LOCAL_RUN_MODE_EXPLICIT=true
      shift
      ;;
    -h|--help)
      echo "Usage: gha24 \"task description\" [--implement|--review] [--repo owner/repo] [--orchestrator codex|claude] [--assist-orchestrator claude|codex|none] [--force-claude] [--local-run|--gha-only]"
      echo ""
      echo "Options:"
      echo "  --implement    Trigger Codex CLI for autonomous code generation"
      echo "  --review       Review only (no code generation)"
      echo "  --repo REPO    Target repository (default: cursorvers/fugue-orchestrator)"
      echo "  --orchestrator Per-request orchestrator override (codex|claude)"
      echo "  --assist-orchestrator Per-request assist orchestrator override (claude|codex|none)"
      echo "  --force-claude Force claude provider(s) for this issue"
      echo "  --local-run    Force local orchestration run after issue creation"
      echo "  --gha-only     Disable local auto-fallback run"
      echo "                 (フラグなしでも、タスク文の『ローカルで実行』『GHAのみ』等を自動解釈)"
      echo ""
      echo "Environment:"
      echo "  GHA24_ORCHESTRATOR_REPO  Orchestrator repo for issue creation (default: cursorvers/fugue-orchestrator)"
      echo "  GHA24_ORCHESTRATOR_PROVIDER  Per-request orchestrator override (codex|claude)"
      echo "  GHA24_ASSIST_ORCHESTRATOR_PROVIDER  Per-request assist override (claude|codex|none)"
      echo "  GHA24_LOCAL_RUN_MODE  Local run mode (auto|force|off, default: force)"
      echo "  GHA24_LOCAL_POST_COMMENT  Local run summary comment (true|false, default: true)"
      echo "  GHA24_LOCAL_MAX_PARALLEL  Local lane parallelism (default: 4)"
      echo ""
      echo "Examples:"
      echo "  gha24 \"認証フローのセキュリティレビュー\""
      echo "  gha24 \"実装: auth middleware を追加してPR作成\""
      echo "  gha24 \"レビュー: auth flow をレビューして指摘だけ\""
      echo "  gha24 \"Review auth flow\" --repo cursorvers/fugue-system-ui"
      echo "  gha24 \"Add tests for utils\" --implement --repo cursorvers/telop-pack-srt-02"
      echo "  gha24 \"完遂: API障害対応\" --orchestrator claude"
      echo "  gha24 \"完遂: API障害対応\" --orchestrator codex --assist-orchestrator claude"
      echo "  gha24 \"完遂: API障害対応\" --orchestrator claude --force-claude"
      echo "  gha24 \"完遂: API障害対応\" --local-run"
      exit 0
      ;;
    *)
      if [[ -z "${TASK}" ]]; then
        TASK="${1}"
      fi
      shift
      ;;
  esac
done

if [[ -z "${TASK}" ]]; then
  echo "Error: task description required" >&2
  echo "Usage: gha24 \"task description\" [--implement|--review] [--repo owner/repo] [--orchestrator codex|claude] [--assist-orchestrator claude|codex|none] [--force-claude]"
  exit 1
fi

if ! command -v gh &>/dev/null; then
  echo "Error: gh CLI not found" >&2
  exit 1
fi

LOCAL_RUN_MODE="$(echo "${LOCAL_RUN_MODE}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
if [[ "${LOCAL_RUN_MODE}" != "auto" && "${LOCAL_RUN_MODE}" != "force" && "${LOCAL_RUN_MODE}" != "off" ]]; then
  echo "Error: local run mode must be auto|force|off" >&2
  exit 1
fi
LOCAL_POST_COMMENT="$(echo "${LOCAL_POST_COMMENT}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
if [[ "${LOCAL_POST_COMMENT}" != "true" ]]; then
  LOCAL_POST_COMMENT="false"
fi
if ! [[ "${LOCAL_MAX_PARALLEL}" =~ ^[0-9]+$ ]] || (( LOCAL_MAX_PARALLEL < 1 )); then
  echo "Error: GHA24_LOCAL_MAX_PARALLEL must be a positive integer" >&2
  exit 1
fi

# Natural language orchestrator hints (only when not explicitly set by flag/env).
# Examples:
# - "claudeをメインorchestratorに"
# - "assistはcodex"
# - "co-orchestratorはnone"
if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" != "true" ]]; then
  if echo "${TASK}" | grep -Eqi '((main|メイン)[[:space:]:：-]*(orchestrator|オーケストレータ|オーケストレーター)?[[:space:]:：-]*(claude|opus))|((claude|opus)[[:space:]:：-]*(main|メイン))'; then
    ORCHESTRATOR_PROVIDER="claude"
    ORCHESTRATOR_PROVIDER_EXPLICIT=true
  elif echo "${TASK}" | grep -Eqi '((main|メイン)[[:space:]:：-]*(orchestrator|オーケストレータ|オーケストレーター)?[[:space:]:：-]*(codex|gpt-5(\.[0-9]+)?-codex))|((codex|gpt-5(\.[0-9]+)?-codex)[[:space:]:：-]*(main|メイン))'; then
    ORCHESTRATOR_PROVIDER="codex"
    ORCHESTRATOR_PROVIDER_EXPLICIT=true
  fi
fi

if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" != "true" ]]; then
  if echo "${TASK}" | grep -Eqi '((assist|sub|co-?orchestrator|アシスト|サブ|副)[[:space:]:：-]*(orchestrator|オーケストレータ|オーケストレーター)?[[:space:]:：-]*(claude|opus))|((claude|opus)[[:space:]:：-]*(assist|sub|co-?orchestrator|アシスト|サブ|副))'; then
    ASSIST_ORCHESTRATOR_PROVIDER="claude"
    ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=true
  elif echo "${TASK}" | grep -Eqi '((assist|sub|co-?orchestrator|アシスト|サブ|副)[[:space:]:：-]*(orchestrator|オーケストレータ|オーケストレーター)?[[:space:]:：-]*(codex|gpt-5(\.[0-9]+)?-codex))|((codex|gpt-5(\.[0-9]+)?-codex)[[:space:]:：-]*(assist|sub|co-?orchestrator|アシスト|サブ|副))'; then
    ASSIST_ORCHESTRATOR_PROVIDER="codex"
    ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=true
  elif echo "${TASK}" | grep -Eqi '((assist|sub|co-?orchestrator|アシスト|サブ|副)[[:space:]:：-]*(orchestrator|オーケストレータ|オーケストレーター)?[[:space:]:：-]*(none|off|なし|無効))|((none|off|なし|無効)[[:space:]:：-]*(assist|sub|co-?orchestrator|アシスト|サブ|副))'; then
    ASSIST_ORCHESTRATOR_PROVIDER="none"
    ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT=true
  fi
fi

if [[ "${FORCE_CLAUDE}" == "true" && "${ORCHESTRATOR_PROVIDER_EXPLICIT}" != "true" && "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" != "true" ]]; then
  echo "Error: --force-claude requires explicit claude on --orchestrator or --assist-orchestrator" >&2
  exit 1
fi
if [[ "${FORCE_CLAUDE}" == "true" ]]; then
  wants_force=false
  if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" && "$(echo "${ORCHESTRATOR_PROVIDER}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')" == "claude" ]]; then
    wants_force=true
  fi
  if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" && "$(echo "${ASSIST_ORCHESTRATOR_PROVIDER}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')" == "claude" ]]; then
    wants_force=true
  fi
  if [[ "${wants_force}" != "true" ]]; then
    echo "Error: --force-claude requires explicit claude on --orchestrator or --assist-orchestrator" >&2
    exit 1
  fi
fi

# Natural language mode selection (only when no explicit mode flag was provided).
# Default is implement; explicit review-only phrases can switch to review mode.
if [[ "${MODE_EXPLICIT}" != "true" ]]; then
  if echo "${TASK}" | grep -Eqi '(レビューのみ|指摘のみ|実装しない|実装不要|review only|no implement|no-implement|#review)'; then
    IMPLEMENT=false
  fi
fi

# Natural language local-run routing (only when not explicitly set by flag/env).
# Priority:
#   1) explicit GHA-only phrases      -> LOCAL_RUN_MODE=off
#   2) explicit local force phrases   -> LOCAL_RUN_MODE=force
if [[ "${LOCAL_RUN_MODE_EXPLICIT}" != "true" ]]; then
  if echo "${TASK}" | grep -Eqi '(ghaのみ|github actionsのみ|ローカル実行しない|local( |-)?disable|gha( |-)?only)'; then
    LOCAL_RUN_MODE="off"
  elif echo "${TASK}" | grep -Eqi '(寝る|就寝|離席|不在|外出|夜間|pcを閉じ|pc落とす|シャットダウン).*(gha|github actions|actions|回して|任せ|まかせ)'; then
    LOCAL_RUN_MODE="off"
  elif echo "${TASK}" | grep -Eqi '(ローカル(メイン|優先|実行)|ローカルで(実行|進め)|gha(は|を)?使わない|github actions(は|を)?使わない|runner(なし|不要)|自分のpcで実行|local( |-)?first|local( |-)?only|run locally)'; then
    LOCAL_RUN_MODE="force"
  fi
fi

LARGE_REFACTOR_HINT=false
if echo "${TASK}" | grep -Eqi '(大規模|全面|全体|リファクタ|refactor|migration|rewrite|アーキテクチャ刷新)'; then
  LARGE_REFACTOR_HINT=true
fi

# Create the issue first, then add the `tutti` label as a second step.
# This avoids multiple `issues:labeled` triggers firing at creation time.
provider=""
requested_provider=""
fallback_applied=false
fallback_reason=""
assist_provider=""
requested_assist_provider=""
assist_fallback_applied=false
assist_fallback_reason=""
assist_pressure_guard_applied=false
assist_pressure_guard_reason=""
claude_state="ok"
claude_main_assist_policy="codex"
if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  provider="$(echo "${ORCHESTRATOR_PROVIDER}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${provider}" != "claude" && "${provider}" != "codex" ]]; then
    echo "Error: --orchestrator must be codex or claude" >&2
    exit 1
  fi
fi

if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  assist_provider="$(echo "${ASSIST_ORCHESTRATOR_PROVIDER}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${assist_provider}" != "claude" && "${assist_provider}" != "codex" && "${assist_provider}" != "none" ]]; then
    echo "Error: --assist-orchestrator must be claude, codex, or none" >&2
    exit 1
  fi
fi

if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" || "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  if [[ "${FORCE_CLAUDE}" != "true" ]]; then
    claude_state="$(gh variable get FUGUE_CLAUDE_RATE_LIMIT_STATE --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "ok")"
    claude_state="$(echo "${claude_state}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  fi
  claude_main_assist_policy="$(gh variable get FUGUE_CLAUDE_MAIN_ASSIST_POLICY --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "codex")"
  claude_role_policy="$(gh variable get FUGUE_CLAUDE_ROLE_POLICY --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "flex")"
  claude_degraded_assist_policy="$(gh variable get FUGUE_CLAUDE_DEGRADED_ASSIST_POLICY --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "claude")"

  # shellcheck source=lib/safe-eval-policy.sh
  source "${SCRIPT_DIR}/lib/safe-eval-policy.sh"
  safe_eval_policy "${SCRIPT_DIR}/lib/orchestrator-policy.sh" \
      --main "${provider}" \
      --assist "${assist_provider}" \
      --default-main "codex" \
      --default-assist "claude" \
      --claude-state "${claude_state}" \
      --force-claude "${FORCE_CLAUDE}" \
      --assist-policy "${claude_main_assist_policy}" \
      --claude-role-policy "${claude_role_policy}" \
      --degraded-assist-policy "${claude_degraded_assist_policy}"

  if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
    requested_provider="${requested_main}"
    provider="${resolved_main}"
    if [[ "${requested_provider}" != "${provider}" ]]; then
      fallback_applied=true
      fallback_reason="${main_fallback_reason}"
      echo "Notice: FUGUE_CLAUDE_RATE_LIMIT_STATE=${claude_state}. Auto-fallback for main orchestrator: ${requested_provider} -> ${provider}."
    fi
  fi

  if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
    requested_assist_provider="${requested_assist}"
    assist_provider="${resolved_assist}"
    if [[ "${requested_assist_provider}" != "${assist_provider}" ]]; then
      assist_fallback_applied=true
      assist_fallback_reason="${assist_fallback_reason}"
      if [[ -z "${assist_fallback_reason}" ]]; then
        assist_fallback_reason="${pressure_guard_reason}"
        assist_pressure_guard_applied=true
        assist_pressure_guard_reason="${pressure_guard_reason}"
      fi
      echo "Notice: Orchestrator assist auto-adjusted: ${requested_assist_provider} -> ${assist_provider} (${assist_fallback_reason:-${assist_pressure_guard_reason}})."
    fi
  fi
fi

LABELS="fugue-task"
if [[ "${IMPLEMENT}" == "true" ]]; then
  gh label create "implement" \
    --repo "${ORCHESTRATOR_REPO}" \
    --description "Implementation intent (provider-agnostic)" \
    --color "1D76DB" >/dev/null 2>&1 || true

  # `implement` is the provider-agnostic intent label.
  # Add provider-specific compatibility label only when provider is explicitly chosen.
  LABELS="${LABELS},implement"
  gh label create "implement-confirmed" \
    --repo "${ORCHESTRATOR_REPO}" \
    --description "Human has explicitly confirmed implementation execution" \
    --color "0E8A16" >/dev/null 2>&1 || true
  LABELS="${LABELS},implement-confirmed"
  if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
    compat_label="$( [[ "${provider}" == "claude" ]] && echo "claude-implement" || echo "codex-implement" )"
    gh label create "${compat_label}" \
      --repo "${ORCHESTRATOR_REPO}" \
      --description "Implementation intent compatibility label" \
      --color "0052CC" >/dev/null 2>&1 || true
    LABELS="${LABELS},${compat_label}"
  fi

  if [[ "${LARGE_REFACTOR_HINT}" == "true" ]]; then
    gh label create "large-refactor" \
      --repo "${ORCHESTRATOR_REPO}" \
      --description "Large refactor/rewrite/migration task requiring extended preflight sections" \
      --color "D93F0B" >/dev/null 2>&1 || true
    LABELS="${LABELS},large-refactor"
  fi
fi

BODY="$(cat <<EOF
## GHA24 Task
${TASK}

## Spec (minimal)
### Goal
${TASK}

### Must not
- Do not touch unrelated files
- Do not leak secrets
- Do not perform destructive operations (delete/rotate/disable) unless explicitly requested

### Acceptance criteria
- [ ] Change matches Goal
- [ ] No unintended file changes
- [ ] CI/lint/tests pass if present

### Rollback
- Revert the PR

## Target repo
\`${TARGET_REPO}\`

$( if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then cat <<PROVIDER
## Orchestrator provider
${provider}

PROVIDER
fi )

$( if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then cat <<ASSIST_PROVIDER
## Assist orchestrator provider
${assist_provider}

ASSIST_PROVIDER
fi )

## Mode
$( [[ "${IMPLEMENT}" == "true" ]] && echo "implement" || echo "review" )

$( if [[ "${IMPLEMENT}" == "true" ]]; then cat <<IMPL_CONFIRM
## Implement confirmation
confirmed

IMPL_CONFIRM
fi )

$( if [[ "${IMPLEMENT}" == "true" ]]; then cat <<PREFLIGHT
## Mandatory preflight protocol (before implementation)
- Repeat 3 cycles by default (repo variable \`FUGUE_IMPLEMENT_REFINEMENT_CYCLES\` can override).
- Each cycle must execute in this exact order:
  1. Plan
  2. Parallel Simulation
  3. Critical Review
  4. Problem Fix
  5. Replan
- Parallel Simulation and Critical Review are hard gates and cannot be skipped.
- For large refactor/rewrite/migration tasks, every cycle must include:
  - Candidate A
  - Candidate B
  - Failure Modes
  - Rollback Check

## Mandatory implementation collaboration protocol
- After preflight completion, run implementation dialogue loops (repo variable \`FUGUE_IMPLEMENT_DIALOGUE_ROUNDS\`, default 2).
- Each round must include:
  - Implementer Proposal
  - Critic Challenge
  - Integrator Decision
  - Applied Change
  - Verification
- Only integrator-approved changes should be applied.

## Shared playbook operational requirements (Codex/Claude common)
- Keep a checkable task ledger in \`.fugue/pre-implement/issue-<N>-todo.md\`.
- Record durable prevention rules in \`.fugue/pre-implement/lessons.md\` after corrections or postmortems.
- Before marking done, show concrete verification evidence (tests/logs/diff).
- For non-trivial fixes, explicitly challenge hacky paths and keep the smallest elegant change surface.
- Respect policy boundaries: MUST (gates/evidence), SHOULD (lessons on correction), MAY (extra subagent fan-out only when uncertainty remains).
- Keep context usage staged by risk: low 6->12, medium 8->16, high 10->20 sources.
PREFLIGHT
fi )
EOF
)"

URL="$(gh issue create --repo "${ORCHESTRATOR_REPO}" \
  --title "${TASK}" \
  --label "${LABELS}" \
  --body "${BODY}")"

ISSUE_NUM="${URL##*/}"
if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  orchestrator_label="orchestrator:${provider}"
  gh label create "${orchestrator_label}" \
    --repo "${ORCHESTRATOR_REPO}" \
    --description "Requested orchestrator profile for Tutti routing" \
    --color "5319E7" >/dev/null 2>&1 || true
  gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --remove-label "orchestrator:claude" --remove-label "orchestrator:codex" >/dev/null 2>&1 || true
  gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --add-label "${orchestrator_label}" >/dev/null
  if [[ "${FORCE_CLAUDE}" == "true" ]]; then
    gh label create "orchestrator-force:claude" \
      --repo "${ORCHESTRATOR_REPO}" \
      --description "Force claude orchestrator for this issue (override rate-limit fallback)" \
      --color "B60205" >/dev/null 2>&1 || true
    gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --add-label "orchestrator-force:claude" >/dev/null
  fi
fi
if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  assist_label="orchestrator-assist:${assist_provider}"
  gh label create "${assist_label}" \
    --repo "${ORCHESTRATOR_REPO}" \
    --description "Requested assist orchestrator profile for Tutti routing" \
    --color "0052CC" >/dev/null 2>&1 || true
  gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --remove-label "orchestrator-assist:claude" --remove-label "orchestrator-assist:codex" --remove-label "orchestrator-assist:none" >/dev/null 2>&1 || true
  gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --add-label "${assist_label}" >/dev/null
fi
gh issue edit "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --add-label "tutti" >/dev/null
if [[ "${fallback_applied}" == "true" ]]; then
  gh issue comment "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --body "CLI pre-fallback applied: requested \`${requested_provider}\` but submitted \`${provider}\` due to \`${fallback_reason}\`. Use \`--force-claude\` to bypass this guard for this issue."
fi
if [[ "${assist_fallback_applied}" == "true" ]]; then
  gh issue comment "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --body "CLI pre-fallback applied for assist orchestrator: requested \`${requested_assist_provider}\` but submitted \`${assist_provider}\` due to \`${assist_fallback_reason}\`. Use \`--force-claude\` to bypass this guard for this issue."
fi
if [[ "${assist_pressure_guard_applied}" == "true" ]]; then
  gh issue comment "${ISSUE_NUM}" --repo "${ORCHESTRATOR_REPO}" --body "CLI pressure guard applied for assist orchestrator: requested \`${requested_assist_provider}\` but submitted \`${assist_provider}\` due to \`${assist_pressure_guard_reason}\`. Use \`--force-claude\` to bypass this guard for this issue."
fi

should_local_run=false
local_run_reason="disabled"
detected_engine="$(gh variable get FUGUE_CI_EXECUTION_ENGINE --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "subscription")"
detected_engine="$(echo "${detected_engine}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
if [[ "${detected_engine}" != "subscription" && "${detected_engine}" != "api" && "${detected_engine}" != "harness" ]]; then
  detected_engine="subscription"
fi
detected_offline_policy="$(gh variable get FUGUE_SUBSCRIPTION_OFFLINE_POLICY --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "continuity")"
detected_offline_policy="$(echo "${detected_offline_policy}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
if [[ "${detected_offline_policy}" != "hold" && "${detected_offline_policy}" != "continuity" ]]; then
  detected_offline_policy="continuity"
fi
detected_runner_label="$(gh variable get FUGUE_SUBSCRIPTION_RUNNER_LABEL --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "fugue-subscription")"
detected_runner_label="$(echo "${detected_runner_label}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
if [[ -z "${detected_runner_label}" ]]; then
  detected_runner_label="fugue-subscription"
fi

if [[ "${LOCAL_RUN_MODE}" == "force" ]]; then
  should_local_run=true
  local_run_reason="forced"
elif [[ "${LOCAL_RUN_MODE}" == "auto" ]]; then
  if [[ "${detected_engine}" == "subscription" ]]; then
    online_count_raw="$(gh api "repos/${ORCHESTRATOR_REPO}/actions/runners" --jq "[.runners[]? | select(.status==\"online\" and .busy != true and ([.labels[]?.name] | index(\"self-hosted\") != null) and ([.labels[]?.name] | index(\"${detected_runner_label}\") != null))] | length" 2>/dev/null || true)"
    if [[ "${online_count_raw}" =~ ^[0-9]+$ ]] && (( online_count_raw == 0 )); then
      should_local_run=true
      local_run_reason="subscription-no-self-hosted-online(policy=${detected_offline_policy})"
    fi
  fi
fi

if [[ "${should_local_run}" == "true" ]]; then
  local_runner="${SCRIPT_DIR}/local/run-local-orchestration.sh"
  if [[ ! -x "${local_runner}" ]]; then
    echo "Local fallback requested (${local_run_reason}) but runner is not executable: ${local_runner}" >&2
    exit 1
  fi

  local_main_provider="${provider}"
  if [[ -z "${local_main_provider}" ]]; then
    local_main_provider="$(gh variable get FUGUE_MAIN_ORCHESTRATOR_PROVIDER --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || true)"
    if [[ -z "${local_main_provider}" ]]; then
      local_main_provider="$(gh variable get FUGUE_ORCHESTRATOR_PROVIDER --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "codex")"
    fi
  fi
  local_main_provider="$(echo "${local_main_provider}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${local_main_provider}" != "codex" && "${local_main_provider}" != "claude" ]]; then
    local_main_provider="codex"
  fi

  local_assist_provider="${assist_provider}"
  if [[ -z "${local_assist_provider}" ]]; then
    local_assist_provider="$(gh variable get FUGUE_ASSIST_ORCHESTRATOR_PROVIDER --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "claude")"
  fi
  local_assist_provider="$(echo "${local_assist_provider}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${local_assist_provider}" != "claude" && "${local_assist_provider}" != "codex" && "${local_assist_provider}" != "none" ]]; then
    local_assist_provider="claude"
  fi

  local_multi_agent_mode="$(gh variable get FUGUE_MULTI_AGENT_MODE --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "enhanced")"
  local_multi_agent_mode="$(echo "${local_multi_agent_mode}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${local_multi_agent_mode}" != "standard" && "${local_multi_agent_mode}" != "enhanced" && "${local_multi_agent_mode}" != "max" ]]; then
    local_multi_agent_mode="enhanced"
  fi

  local_glm_mode="$(gh variable get FUGUE_GLM_SUBAGENT_MODE --repo "${ORCHESTRATOR_REPO}" --json value -q '.value' 2>/dev/null || echo "paired")"
  local_glm_mode="$(echo "${local_glm_mode}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  if [[ "${local_glm_mode}" != "off" && "${local_glm_mode}" != "paired" && "${local_glm_mode}" != "symphony" ]]; then
    local_glm_mode="paired"
  fi

  local_cmd=(
    "${local_runner}"
    --issue "${ISSUE_NUM}"
    --repo "${ORCHESTRATOR_REPO}"
    --main "${local_main_provider}"
    --assist "${local_assist_provider}"
    --mode "${local_multi_agent_mode}"
    --glm-mode "${local_glm_mode}"
    --max-parallel "${LOCAL_MAX_PARALLEL}"
  )
  if [[ "${LOCAL_POST_COMMENT}" == "true" ]]; then
    local_cmd+=(--comment)
  fi

  echo "Local orchestration fallback activated: ${local_run_reason}"
  echo "Local command: ${local_cmd[*]}"
  set +e
  "${local_cmd[@]}"
  local_rc=$?
  set -e
  if (( local_rc != 0 )); then
    echo "Local orchestration failed with exit code ${local_rc}" >&2
    exit "${local_rc}"
  fi
fi

echo "Created: ${URL}"
echo "Orchestrator repo: ${ORCHESTRATOR_REPO}"
echo "Target repo: ${TARGET_REPO}"
if [[ "${ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  echo "Orchestrator profile override: ${provider}"
  if [[ "${fallback_applied}" == "true" ]]; then
    echo "Orchestrator pre-fallback: ${requested_provider} -> ${provider} (${fallback_reason})"
  fi
  if [[ "${FORCE_CLAUDE}" == "true" ]]; then
    echo "Override guard: orchestrator-force:claude enabled"
  fi
else
  echo "Orchestrator profile: repository default (FUGUE_MAIN_ORCHESTRATOR_PROVIDER/FUGUE_ORCHESTRATOR_PROVIDER)"
fi
if [[ "${ASSIST_ORCHESTRATOR_PROVIDER_EXPLICIT}" == "true" ]]; then
  echo "Assist orchestrator profile override: ${assist_provider}"
  if [[ "${assist_fallback_applied}" == "true" ]]; then
    echo "Assist orchestrator pre-fallback: ${requested_assist_provider} -> ${assist_provider} (${assist_fallback_reason})"
  fi
else
  echo "Assist orchestrator profile: repository default (FUGUE_ASSIST_ORCHESTRATOR_PROVIDER)"
fi

if [[ "${IMPLEMENT}" == "true" ]]; then
  echo "Mode: Implementation intent (routing profile only; execution engine is Codex CLI after Tutti approval)"
  echo "Tutti vote will run first. If approved with implement-confirmed present, Codex implement will run automatically."
  if [[ "${LARGE_REFACTOR_HINT}" == "true" ]]; then
    echo "Large-refactor hint: enabled (label: large-refactor)"
  fi
else
  echo "Mode: Review only (6-parallel agent consensus)"
fi

echo "Check results later:"
echo "  gh issue view ${URL##*/} --repo ${ORCHESTRATOR_REPO} --comments"

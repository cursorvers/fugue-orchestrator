name: fugue-watchdog

on:
  schedule:
    - cron: "17 * * * *"
  workflow_dispatch:

permissions:
  issues: write
  # Needed to dispatch workflow runs for auto-recovery (reconcile job).
  actions: write
  contents: read

jobs:
  health:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Count pending work (for alert gating)
        id: pending
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          issues_json="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --label "fugue-task" \
            --limit 200 \
            --json number,labels)"

          # Pending router work: open fugue-task missing processing/completed/needs-human
          pending_json="$(echo "${issues_json}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("processing")) == null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null)
          ) | .number]')"
          pending_count="$(echo "${pending_json}" | jq 'length')"

          # Pending mainframe work: open issue has `tutti` but not completed/needs-human.
          mainframe_pending_json="$(echo "${issues_json}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("tutti")) != null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null)
          ) | .number]')"
          mainframe_pending_count="$(echo "${mainframe_pending_json}" | jq 'length')"

          {
            echo "pending_count=${pending_count}"
            echo "mainframe_pending_count=${mainframe_pending_count}"
          } >> "${GITHUB_OUTPUT}"

      - name: API connectivity check
        id: connectivity
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
        run: |
          set +e
          OPENAI_OK="false"
          ZAI_OK="false"

          curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
            https://api.openai.com/v1/models \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" >/dev/null 2>&1
          [[ $? -eq 0 ]] && OPENAI_OK="true"

          curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
            https://api.z.ai/api/coding/paas/v4/models \
            -H "Authorization: Bearer ${ZAI_API_KEY}" >/dev/null 2>&1
          [[ $? -eq 0 ]] && ZAI_OK="true"

          {
            echo "openai_ok=${OPENAI_OK}"
            echo "zai_ok=${ZAI_OK}"
          } >> "${GITHUB_OUTPUT}"

      - name: Get latest successful router run
        id: last_success
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          RUNS_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/fugue-task-router.yml/runs?status=success&per_page=1")"
          LAST_TIME="$(echo "${RUNS_JSON}" | jq -r '.workflow_runs[0].created_at // empty')"

          if [[ -z "${LAST_TIME}" ]]; then
            echo "stale=true" >> "${GITHUB_OUTPUT}"
            echo "hours_since=9999" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          NOW_EPOCH="$(date -u +%s)"
          LAST_EPOCH="$(date -u -d "${LAST_TIME}" +%s)"
          DIFF_HOURS="$(( (NOW_EPOCH - LAST_EPOCH) / 3600 ))"

          STALE="false"
          # Only page on router staleness when there is pending work to process.
          if [[ "${DIFF_HOURS}" -ge 3 && "${{ steps.pending.outputs.pending_count }}" != "0" ]]; then
            STALE="true"
          fi

          {
            echo "stale=${STALE}"
            echo "hours_since=${DIFF_HOURS}"
            echo "last_time=${LAST_TIME}"
          } >> "${GITHUB_OUTPUT}"

      - name: Get latest successful mainframe run
        id: mainframe_success
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          RUNS_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/fugue-tutti-caller.yml/runs?status=success&per_page=1")"
          LAST_TIME="$(echo "${RUNS_JSON}" | jq -r '.workflow_runs[0].created_at // empty')"

          if [[ -z "${LAST_TIME}" ]]; then
            echo "stale=true" >> "${GITHUB_OUTPUT}"
            echo "hours_since=9999" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          NOW_EPOCH="$(date -u +%s)"
          LAST_EPOCH="$(date -u -d "${LAST_TIME}" +%s)"
          DIFF_HOURS="$(( (NOW_EPOCH - LAST_EPOCH) / 3600 ))"

          STALE="false"
          # Only page on mainframe staleness when there is pending mainframe work.
          if [[ "${DIFF_HOURS}" -ge 3 && "${{ steps.pending.outputs.mainframe_pending_count }}" != "0" ]]; then
            STALE="true"
          fi

          {
            echo "stale=${STALE}"
            echo "hours_since=${DIFF_HOURS}"
            echo "last_time=${LAST_TIME}"
          } >> "${GITHUB_OUTPUT}"

      - name: Decide whether to alert (throttle + relevance)
        id: decide
        run: |
          set -euo pipefail

          openai_ok="${{ steps.connectivity.outputs.openai_ok }}"
          zai_ok="${{ steps.connectivity.outputs.zai_ok }}"
          router_stale="${{ steps.last_success.outputs.stale }}"
          mainframe_stale="${{ steps.mainframe_success.outputs.stale }}"

          router_hours="${{ steps.last_success.outputs.hours_since }}"
          mainframe_hours="${{ steps.mainframe_success.outputs.hours_since }}"

          pending_count="${{ steps.pending.outputs.pending_count }}"
          mainframe_pending_count="${{ steps.pending.outputs.mainframe_pending_count }}"

          hour_utc="$(date -u +%H)"
          should_alert="false"
          reasons=()

          # Connectivity issues can be transient. Only alert frequently if there is pending work.
          if [[ "${openai_ok}" != "true" || "${zai_ok}" != "true" ]]; then
            if [[ "${pending_count}" != "0" || "${mainframe_pending_count}" != "0" ]]; then
              # With pending work, alert at most every 3 hours.
              if (( 10#${hour_utc} % 3 == 0 )); then
                should_alert="true"
                reasons+=("connectivity")
              fi
            else
              # Without pending work, reduce noise: alert at most every 6 hours.
              if (( 10#${hour_utc} % 6 == 0 )); then
                should_alert="true"
                reasons+=("connectivity")
              fi
            fi
          fi

          # Staleness alerts: page at 3h, then every 6h (3,6,12,18,24,...).
          if [[ "${router_stale}" == "true" ]]; then
            if [[ "${router_hours}" == "9999" || "${router_hours}" == "3" || $((router_hours % 6)) -eq 0 ]]; then
              should_alert="true"
              reasons+=("router-stale")
            fi
          fi
          if [[ "${mainframe_stale}" == "true" ]]; then
            if [[ "${mainframe_hours}" == "9999" || "${mainframe_hours}" == "3" || $((mainframe_hours % 6)) -eq 0 ]]; then
              should_alert="true"
              reasons+=("mainframe-stale")
            fi
          fi

          msg="fugue-watchdog alert
          repo: ${GITHUB_REPOSITORY}
          reasons: ${reasons[*]:-none}
          openai_ok: ${openai_ok}
          zai_ok: ${zai_ok}
          pending_count: ${pending_count}
          mainframe_pending_count: ${mainframe_pending_count}
          router_hours_since_success: ${router_hours}
          router_last_success_at: ${{ steps.last_success.outputs.last_time }}
          mainframe_hours_since_success: ${mainframe_hours}
          mainframe_last_success_at: ${{ steps.mainframe_success.outputs.last_time }}"

          {
            echo "should_alert=${should_alert}"
            echo "message<<EOF"
            echo "${msg}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Discord alert when unhealthy
        if: ${{ steps.decide.outputs.should_alert == 'true' }}
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          set -euo pipefail

          PAYLOAD="$(jq -n --arg content "${{ steps.decide.outputs.message }}" '{content:$content}')"
          curl -fsS -X POST "${DISCORD_WEBHOOK_URL}" \
            -H "Content-Type: application/json" \
            -d "${PAYLOAD}"

  reconcile:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Find unprocessed fugue-task issues
        id: find
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ISSUES_JSON="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --label "fugue-task" \
            --limit 200 \
            --json number,labels)"

          # Avoid retry loops on `needs-human` issues. Also handle edge cases where labels are missing.
          PENDING_JSON="$(echo "${ISSUES_JSON}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("processing")) == null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null)
          ) | .number]')"
          COUNT="$(echo "${PENDING_JSON}" | jq 'length')"

          {
            echo "pending_count=${COUNT}"
            echo "pending_json=${PENDING_JSON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Trigger task-router for unprocessed issues
        if: ${{ steps.find.outputs.pending_count != '0' }}
        env:
          GH_TOKEN: ${{ github.token }}
          PENDING_JSON: ${{ steps.find.outputs.pending_json }}
        run: |
          set -euo pipefail

          echo "Found unprocessed issues: ${PENDING_JSON}"
          for ISSUE_NUM in $(echo "${PENDING_JSON}" | jq -r '.[]'); do
            echo "Triggering router for issue #${ISSUE_NUM}"
            gh workflow run fugue-task-router.yml \
              --repo "${GITHUB_REPOSITORY}" \
              -f issue_number="${ISSUE_NUM}"
            sleep 2
          done

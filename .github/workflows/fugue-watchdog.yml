name: fugue-watchdog

on:
  schedule:
    - cron: "17 * * * *"
  workflow_dispatch:

permissions:
  issues: write
  # Needed to dispatch workflow runs for auto-recovery (reconcile job).
  actions: write
  contents: read

jobs:
  health:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Count pending work (for alert gating)
        id: pending
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          issues_json="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --label "fugue-task" \
            --limit 200 \
            --json number,labels)"

          # Pending router work: issues that *should* be handled by `fugue-task-router`.
          # Exclude terminal/handled states to avoid alert spam (e.g. vote-rejected drills).
          pending_json="$(echo "${issues_json}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("processing")) == null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null) and
            (([.labels[]? | .name] | index("needs-review")) == null) and
            (([.labels[]? | .name] | index("vote-rejected")) == null) and
            (([.labels[]? | .name] | index("tutti")) == null)
          ) | .number]')"
          pending_count="$(echo "${pending_json}" | jq 'length')"

          # Pending mainframe work: open issue has `tutti` but is not in a terminal state.
          mainframe_pending_json="$(echo "${issues_json}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("tutti")) != null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null) and
            (([.labels[]? | .name] | index("needs-review")) == null) and
            (([.labels[]? | .name] | index("vote-rejected")) == null)
          ) | .number]')"
          mainframe_pending_count="$(echo "${mainframe_pending_json}" | jq 'length')"

          {
            echo "pending_count=${pending_count}"
            echo "mainframe_pending_count=${mainframe_pending_count}"
          } >> "${GITHUB_OUTPUT}"

      - name: API connectivity check
        id: connectivity
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
        run: |
          set +e
          OPENAI_OK="false"
          ZAI_OK="false"
          GEMINI_OK="skipped"
          XAI_OK="skipped"
          ANTHROPIC_OK="skipped"
          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi

          curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
            https://api.openai.com/v1/models \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" >/dev/null 2>&1
          [[ $? -eq 0 ]] && OPENAI_OK="true"

          curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
            https://api.z.ai/api/coding/paas/v4/models \
            -H "Authorization: Bearer ${ZAI_API_KEY}" >/dev/null 2>&1
          [[ $? -eq 0 ]] && ZAI_OK="true"

          if [[ -n "${GEMINI_API_KEY:-}" ]]; then
            GEMINI_OK="false"
            curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
              "https://generativelanguage.googleapis.com/v1beta/models?key=${GEMINI_API_KEY}" >/dev/null 2>&1
            [[ $? -eq 0 ]] && GEMINI_OK="true"
          fi

          if [[ -n "${XAI_API_KEY:-}" ]]; then
            XAI_OK="false"
            curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
              https://api.x.ai/v1/models \
              -H "Authorization: Bearer ${XAI_API_KEY}" >/dev/null 2>&1
            [[ $? -eq 0 ]] && XAI_OK="true"
          fi

          if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
            ANTHROPIC_OK="false"
            curl -fsS --connect-timeout 5 --max-time 15 --retry 2 --retry-delay 2 --retry-all-errors \
              https://api.anthropic.com/v1/models \
              -H "x-api-key: ${ANTHROPIC_API_KEY}" \
              -H "anthropic-version: 2023-06-01" >/dev/null 2>&1
            [[ $? -eq 0 ]] && ANTHROPIC_OK="true"
          elif [[ "${claude_max_plan}" == "true" ]]; then
            ANTHROPIC_OK="proxy"
          fi

          {
            echo "openai_ok=${OPENAI_OK}"
            echo "zai_ok=${ZAI_OK}"
            echo "gemini_ok=${GEMINI_OK}"
            echo "xai_ok=${XAI_OK}"
            echo "anthropic_ok=${ANTHROPIC_OK}"
          } >> "${GITHUB_OUTPUT}"

      - name: Auto-recover Claude rate-limit state when stable
        id: claude_state_guard
        env:
          GH_TOKEN: ${{ github.token }}
          OPS_TOKEN: ${{ secrets.FUGUE_OPS_PAT || secrets.TARGET_REPO_PAT || '' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
        run: |
          set -euo pipefail

          state="$(echo "${CLAUDE_RATE_LIMIT_STATE:-ok}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${state}" != "ok" && "${state}" != "degraded" && "${state}" != "exhausted" ]]; then
            state="ok"
          fi
          state_effective="${state}"
          recovered="false"
          recover_reason="not-required"
          age_hours="0"
          fallback_mentions_24h="0"
          can_manage_variables="false"

          if [[ -n "${OPS_TOKEN:-}" ]]; then
            GH_TOKEN="${OPS_TOKEN}"
            export GH_TOKEN
            can_manage_variables="true"
          fi

          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi

          if [[ "${state}" != "ok" ]]; then
            if [[ "${can_manage_variables}" == "true" ]]; then
              var_updated_at="$(gh variable list --repo "${GITHUB_REPOSITORY}" 2>/dev/null | awk '$1=="FUGUE_CLAUDE_RATE_LIMIT_STATE"{print $3}' || true)"
              if [[ -n "${var_updated_at}" ]]; then
                now_epoch="$(date -u +%s)"
                var_epoch="$(date -u -d "${var_updated_at}" +%s)"
                age_hours="$(( (now_epoch - var_epoch) / 3600 ))"
              fi
            else
              recover_reason="hold-no-ops-token"
            fi

            since_24h="$(date -u -d '1 day ago' +%Y-%m-%d)"
            fallback_mentions_24h="$(gh api "search/issues?q=repo:${GITHUB_REPOSITORY}+is:issue+%22auto-fallback%22+updated:>=${since_24h}&per_page=1" | jq -r '.total_count // 0')"

            pending_count="${{ steps.pending.outputs.pending_count }}"
            mainframe_pending_count="${{ steps.pending.outputs.mainframe_pending_count }}"
            openai_ok="${{ steps.connectivity.outputs.openai_ok }}"
            zai_ok="${{ steps.connectivity.outputs.zai_ok }}"
            anthropic_ok="${{ steps.connectivity.outputs.anthropic_ok }}"

            min_age_hours=12
            if [[ "${state}" == "exhausted" ]]; then
              min_age_hours=24
            fi

            has_pending="false"
            if [[ "${pending_count}" != "0" || "${mainframe_pending_count}" != "0" ]]; then
              has_pending="true"
            fi

            claude_path_ok="true"
            if [[ "${anthropic_ok}" == "false" && "${claude_max_plan}" != "true" ]]; then
              claude_path_ok="false"
            fi

            if [[ "${can_manage_variables}" == "true" &&
                  "${age_hours}" -ge "${min_age_hours}" &&
                  "${fallback_mentions_24h}" == "0" &&
                  "${has_pending}" == "false" &&
                  "${openai_ok}" == "true" &&
                  "${zai_ok}" == "true" &&
                  "${claude_path_ok}" == "true" ]]; then
              if gh variable set FUGUE_CLAUDE_RATE_LIMIT_STATE \
                --repo "${GITHUB_REPOSITORY}" \
                --body "ok"; then
                state_effective="ok"
                recovered="true"
                recover_reason="cooldown-auto-recover"
              else
                recover_reason="hold-variable-write-failed"
              fi
            else
              if [[ "${recover_reason}" == "not-required" ]]; then
                recover_reason="hold-${state}"
              fi
            fi
          fi

          {
            echo "state_effective=${state_effective}"
            echo "recovered=${recovered}"
            echo "recover_reason=${recover_reason}"
            echo "state_age_hours=${age_hours}"
            echo "fallback_mentions_24h=${fallback_mentions_24h}"
            echo "can_manage_variables=${can_manage_variables}"
          } >> "${GITHUB_OUTPUT}"

      - name: Get latest successful router run
        id: last_success
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          RUNS_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/fugue-task-router.yml/runs?status=success&per_page=1")"
          LAST_TIME="$(echo "${RUNS_JSON}" | jq -r '.workflow_runs[0].created_at // empty')"

          if [[ -z "${LAST_TIME}" ]]; then
            echo "stale=true" >> "${GITHUB_OUTPUT}"
            echo "hours_since=9999" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          NOW_EPOCH="$(date -u +%s)"
          LAST_EPOCH="$(date -u -d "${LAST_TIME}" +%s)"
          DIFF_HOURS="$(( (NOW_EPOCH - LAST_EPOCH) / 3600 ))"

          STALE="false"
          # Only page on router staleness when there is pending work to process.
          if [[ "${DIFF_HOURS}" -ge 3 && "${{ steps.pending.outputs.pending_count }}" != "0" ]]; then
            STALE="true"
          fi

          {
            echo "stale=${STALE}"
            echo "hours_since=${DIFF_HOURS}"
            echo "last_time=${LAST_TIME}"
          } >> "${GITHUB_OUTPUT}"

      - name: Get latest successful mainframe run
        id: mainframe_success
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          RUNS_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/fugue-tutti-caller.yml/runs?status=success&per_page=1")"
          LAST_TIME="$(echo "${RUNS_JSON}" | jq -r '.workflow_runs[0].created_at // empty')"

          if [[ -z "${LAST_TIME}" ]]; then
            echo "stale=true" >> "${GITHUB_OUTPUT}"
            echo "hours_since=9999" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          NOW_EPOCH="$(date -u +%s)"
          LAST_EPOCH="$(date -u -d "${LAST_TIME}" +%s)"
          DIFF_HOURS="$(( (NOW_EPOCH - LAST_EPOCH) / 3600 ))"

          STALE="false"
          # Only page on mainframe staleness when there is pending mainframe work.
          if [[ "${DIFF_HOURS}" -ge 3 && "${{ steps.pending.outputs.mainframe_pending_count }}" != "0" ]]; then
            STALE="true"
          fi

          {
            echo "stale=${STALE}"
            echo "hours_since=${DIFF_HOURS}"
            echo "last_time=${LAST_TIME}"
          } >> "${GITHUB_OUTPUT}"

      - name: Decide whether to alert (throttle + relevance)
        id: decide
        env:
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
        run: |
          set -euo pipefail

          openai_ok="${{ steps.connectivity.outputs.openai_ok }}"
          zai_ok="${{ steps.connectivity.outputs.zai_ok }}"
          gemini_ok="${{ steps.connectivity.outputs.gemini_ok }}"
          xai_ok="${{ steps.connectivity.outputs.xai_ok }}"
          anthropic_ok="${{ steps.connectivity.outputs.anthropic_ok }}"
          claude_state="${{ steps.claude_state_guard.outputs.state_effective }}"
          claude_recovered="${{ steps.claude_state_guard.outputs.recovered }}"
          claude_recover_reason="${{ steps.claude_state_guard.outputs.recover_reason }}"
          claude_state_age_hours="${{ steps.claude_state_guard.outputs.state_age_hours }}"
          claude_fallback_mentions_24h="${{ steps.claude_state_guard.outputs.fallback_mentions_24h }}"
          claude_can_manage_variables="${{ steps.claude_state_guard.outputs.can_manage_variables }}"
          claude_state="$(echo "${claude_state:-ok}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_state}" != "ok" && "${claude_state}" != "degraded" && "${claude_state}" != "exhausted" ]]; then
            claude_state="ok"
          fi
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi
          router_stale="${{ steps.last_success.outputs.stale }}"
          mainframe_stale="${{ steps.mainframe_success.outputs.stale }}"

          router_hours="${{ steps.last_success.outputs.hours_since }}"
          mainframe_hours="${{ steps.mainframe_success.outputs.hours_since }}"

          pending_count="${{ steps.pending.outputs.pending_count }}"
          mainframe_pending_count="${{ steps.pending.outputs.mainframe_pending_count }}"

          hour_utc="$(date -u +%H)"
          should_alert="false"
          reasons=()

          # Connectivity issues can be transient. Only alert frequently if there is pending work.
          if [[ "${openai_ok}" != "true" || "${zai_ok}" != "true" || ( "${gemini_ok}" != "true" && "${gemini_ok}" != "skipped" ) || ( "${xai_ok}" != "true" && "${xai_ok}" != "skipped" ) ]]; then
            if [[ "${pending_count}" != "0" || "${mainframe_pending_count}" != "0" ]]; then
              # With pending work, alert at most every 3 hours.
              if (( 10#${hour_utc} % 3 == 0 )); then
                should_alert="true"
                reasons+=("connectivity")
              fi
            else
              # Without pending work, reduce noise: alert at most every 6 hours.
              if (( 10#${hour_utc} % 6 == 0 )); then
                should_alert="true"
                reasons+=("connectivity")
              fi
            fi
          fi

          # Claude assist execution path unavailable (only relevant when not exhausted).
          if [[ "${claude_state}" != "exhausted" && "${anthropic_ok}" == "false" && "${claude_max_plan}" != "true" ]]; then
            if [[ "${pending_count}" != "0" || "${mainframe_pending_count}" != "0" ]]; then
              if (( 10#${hour_utc} % 3 == 0 )); then
                should_alert="true"
                reasons+=("claude-assist-unavailable")
              fi
            fi
          fi

          # Claude orchestrator throttle visibility: when not ok and work is pending, page at most every 3h.
          if [[ "${claude_state}" != "ok" && ( "${pending_count}" != "0" || "${mainframe_pending_count}" != "0" ) ]]; then
            if (( 10#${hour_utc} % 3 == 0 )); then
              should_alert="true"
              reasons+=("claude-rate-limit-${claude_state}")
            fi
          fi

          # Staleness alerts: page at 3h, then every 6h (3,6,12,18,24,...).
          if [[ "${router_stale}" == "true" ]]; then
            if [[ "${router_hours}" == "9999" || "${router_hours}" == "3" || $((router_hours % 6)) -eq 0 ]]; then
              should_alert="true"
              reasons+=("router-stale")
            fi
          fi
          if [[ "${mainframe_stale}" == "true" ]]; then
            if [[ "${mainframe_hours}" == "9999" || "${mainframe_hours}" == "3" || $((mainframe_hours % 6)) -eq 0 ]]; then
              should_alert="true"
              reasons+=("mainframe-stale")
            fi
          fi

          msg="fugue-watchdog alert
          repo: ${GITHUB_REPOSITORY}
          reasons: ${reasons[*]:-none}
          claude_rate_limit_state: ${claude_state}
          claude_rate_limit_auto_recovered: ${claude_recovered}
          claude_rate_limit_recover_reason: ${claude_recover_reason}
          claude_rate_limit_manage_variables_enabled: ${claude_can_manage_variables}
          claude_rate_limit_state_age_hours: ${claude_state_age_hours}
          claude_fallback_mentions_24h: ${claude_fallback_mentions_24h}
          claude_max_plan_mode: ${claude_max_plan}
          openai_ok: ${openai_ok}
          zai_ok: ${zai_ok}
          gemini_ok: ${gemini_ok}
          xai_ok: ${xai_ok}
          anthropic_ok: ${anthropic_ok}
          pending_count: ${pending_count}
          mainframe_pending_count: ${mainframe_pending_count}
          router_hours_since_success: ${router_hours}
          router_last_success_at: ${{ steps.last_success.outputs.last_time }}
          mainframe_hours_since_success: ${mainframe_hours}
          mainframe_last_success_at: ${{ steps.mainframe_success.outputs.last_time }}"

          {
            echo "should_alert=${should_alert}"
            echo "message<<EOF"
            echo "${msg}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"

      - name: Discord alert when unhealthy
        if: ${{ steps.decide.outputs.should_alert == 'true' && (secrets.DISCORD_WEBHOOK_URL != '' || secrets.DISCORD_SYSTEM_WEBHOOK != '') }}
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          DISCORD_SYSTEM_WEBHOOK: ${{ secrets.DISCORD_SYSTEM_WEBHOOK }}
        run: |
          set -euo pipefail

          webhook_url="${DISCORD_WEBHOOK_URL:-${DISCORD_SYSTEM_WEBHOOK:-}}"
          if [[ -z "${webhook_url}" ]]; then
            exit 0
          fi
          PAYLOAD="$(jq -n --arg content "${{ steps.decide.outputs.message }}" '{content:$content}')"
          curl -fsS -X POST "${webhook_url}" \
            -H "Content-Type: application/json" \
            -d "${PAYLOAD}"

      - name: LINE alert when unhealthy
        if: ${{ steps.decide.outputs.should_alert == 'true' && (secrets.LINE_WEBHOOK_URL != '' || (secrets.LINE_CHANNEL_ACCESS_TOKEN != '' && secrets.LINE_TO != '') || secrets.LINE_NOTIFY_TOKEN != '' || secrets.LINE_NOTIFY_ACCESS_TOKEN != '') }}
        env:
          LINE_WEBHOOK_URL: ${{ secrets.LINE_WEBHOOK_URL }}
          LINE_CHANNEL_ACCESS_TOKEN: ${{ secrets.LINE_CHANNEL_ACCESS_TOKEN }}
          LINE_TO: ${{ secrets.LINE_TO }}
          LINE_PUSH_API_URL: ${{ vars.LINE_PUSH_API_URL || 'https://api.line.me/v2/bot/message/push' }}
          LINE_NOTIFY_TOKEN: ${{ secrets.LINE_NOTIFY_TOKEN }}
          LINE_NOTIFY_ACCESS_TOKEN: ${{ secrets.LINE_NOTIFY_ACCESS_TOKEN }}
          LINE_NOTIFY_API_URL: ${{ vars.LINE_NOTIFY_API_URL || 'https://notify-api.line.me/api/notify' }}
        run: |
          set -euo pipefail

          message="${{ steps.decide.outputs.message }}"
          if (( ${#message} > 900 )); then
            message="${message:0:897}..."
          fi
          if [[ -n "${LINE_WEBHOOK_URL:-}" ]]; then
            PAYLOAD="$(jq -n --arg text "${message}" '{text:$text}')"
            curl -fsS -X POST "${LINE_WEBHOOK_URL}" \
              -H "Content-Type: application/json" \
              -d "${PAYLOAD}"
          elif [[ -n "${LINE_CHANNEL_ACCESS_TOKEN:-}" && -n "${LINE_TO:-}" ]]; then
            PAYLOAD="$(jq -n --arg to "${LINE_TO}" --arg text "${message}" '{to:$to,messages:[{type:"text",text:$text}]}')"
            curl -fsS -X POST "${LINE_PUSH_API_URL}" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${LINE_CHANNEL_ACCESS_TOKEN}" \
              -d "${PAYLOAD}"
          elif [[ -n "${LINE_NOTIFY_TOKEN:-${LINE_NOTIFY_ACCESS_TOKEN:-}}" ]]; then
            line_notify_token="${LINE_NOTIFY_TOKEN:-${LINE_NOTIFY_ACCESS_TOKEN:-}}"
            curl -fsS -X POST "${LINE_NOTIFY_API_URL}" \
              -H "Authorization: Bearer ${line_notify_token}" \
              --data-urlencode "message=${message}"
          fi

  reconcile:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Find unprocessed fugue-task issues
        id: find
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ISSUES_JSON="$(gh issue list \
            --repo "${GITHUB_REPOSITORY}" \
            --state open \
            --label "fugue-task" \
            --limit 200 \
            --json number,labels)"

          # Only retry issues that the router would actually pick up.
          # Avoid retry loops on terminal/handled states (`needs-human`, `needs-review`, `vote-rejected`, `tutti`).
          PENDING_JSON="$(echo "${ISSUES_JSON}" | jq -c '[.[] | select(
            (([.labels[]? | .name] | index("processing")) == null) and
            (([.labels[]? | .name] | index("completed")) == null) and
            (([.labels[]? | .name] | index("needs-human")) == null) and
            (([.labels[]? | .name] | index("needs-review")) == null) and
            (([.labels[]? | .name] | index("vote-rejected")) == null) and
            (([.labels[]? | .name] | index("tutti")) == null)
          ) | .number]')"
          COUNT="$(echo "${PENDING_JSON}" | jq 'length')"

          {
            echo "pending_count=${COUNT}"
            echo "pending_json=${PENDING_JSON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Trigger task-router for unprocessed issues
        if: ${{ steps.find.outputs.pending_count != '0' }}
        env:
          GH_TOKEN: ${{ github.token }}
          PENDING_JSON: ${{ steps.find.outputs.pending_json }}
        run: |
          set -euo pipefail

          echo "Found unprocessed issues: ${PENDING_JSON}"
          for ISSUE_NUM in $(echo "${PENDING_JSON}" | jq -r '.[]'); do
            echo "Triggering router for issue #${ISSUE_NUM}"
            gh workflow run fugue-task-router.yml \
              --repo "${GITHUB_REPOSITORY}" \
              -f issue_number="${ISSUE_NUM}"
            sleep 2
          done

name: fugue-task-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
    secrets:
      OPENAI_API_KEY:
        required: true
      ZAI_API_KEY:
        required: true
      GEMINI_API_KEY:
        required: false
      XAI_API_KEY:
        required: false
  issues:
    # Avoid `labeled` here: labels added by automation (processing/proj/tutti) can
    # create extra runs and cause unnecessary concurrency cancellations.
    types: [opened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string

permissions:
  issues: write
  contents: read
  actions: write

jobs:
  route:
    # Ignore bot-driven issue label churn (processing/proj labels), but still allow
    # watchdog-triggered workflow_dispatch to run as github-actions[bot].
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: fugue-task-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.event.inputs.issue_number || github.run_id }}
      cancel-in-progress: false

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          COMMENT_BODY=""
          if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            COMMENT_BODY="$(jq -r '.comment.body // ""' "${GITHUB_EVENT_PATH}")"
          fi

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_call" ]]; then
            ISSUE_NUMBER="${{ inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          AUTHOR_ASSOC="$(echo "${issue_json}" | jq -r '.author_association // "NONE"')"

          # Trust gate (write/maintain/admin). Used to prevent untrusted users
          # from dispatching the mainframe workflows.
          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi
          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_GHA24="$(echo "${issue_json}" | jq -r '((.body // "") | test("^##\\s*GHA24\\s*Task"; "m"))')"

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-fugue-task-label"
          elif [[ "${HAS_GHA24}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-gha24"
          elif [[ "${HAS_TUTTI}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-tutti"
          elif [[ "${HAS_PROCESSING}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "comment_body<<EOF"
            echo "${COMMENT_BODY}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "author_association=${AUTHOR_ASSOC}"
            echo "trusted=${TRUSTED}"
            echo "permission=${PERM}"
            echo "has_fugue=${HAS_FUGUE}"
            echo "has_tutti=${HAS_TUTTI}"
            echo "has_processing=${HAS_PROCESSING}"
            echo "has_gha24=${HAS_GHA24}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Skip when not target
        if: ${{ steps.ctx.outputs.should_run != 'true' }}
        run: |
          echo "Skip reason: ${{ steps.ctx.outputs.skip_reason }}"

      - name: Annotate target project (label + title prefix)
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
          COMMENT_BODY: ${{ steps.ctx.outputs.comment_body }}
        run: |
          set -euo pipefail

          title="${ISSUE_TITLE}"
          body="${ISSUE_BODY}"
          comment="${COMMENT_BODY}"
          text="$(printf '%s\n%s\n%s\n' "${title}" "${body}" "${comment}")"

          owner="${GITHUB_REPOSITORY%%/*}"

          # 1) Prefer fully-qualified owner/repo found inside backticks.
          target_repo="$(printf '%s\n' "${text}" \
            | sed -nE 's/.*`([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)`.*/\1/p' \
            | head -n1)"

          # 1b) Also accept plain "owner/repo" (common on mobile forms).
          if [[ -z "${target_repo}" ]]; then
            target_repo="$(printf '%s\n' "${text}" | grep -oE "${owner}/[A-Za-z0-9_.-]+" | head -n1 || true)"
          fi

          # 2) Fallback: repo name in backticks on lines mentioning repo/リポジトリ.
          if [[ -z "${target_repo}" ]]; then
            bare_repo="$(printf '%s\n' "${text}" \
              | grep -E 'repo|Repo|repository|Repository|リポジトリ|対象|target' \
              | sed -nE 's/.*`([A-Za-z0-9_.-]+)`.*/\1/p' \
              | head -n1 || true)"
            if [[ -n "${bare_repo}" ]]; then
              target_repo="${owner}/${bare_repo}"
            fi
          fi

          # 3) Default to caller repo when no hint exists.
          if [[ -z "${target_repo}" ]]; then
            target_repo="${GITHUB_REPOSITORY}"
          fi

          short="${target_repo#*/}"
          slug="$(printf '%s' "${short}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_.-]/-/g' | sed 's/--*/-/g' | head -c 40)"
          if [[ -z "${slug}" ]]; then
            slug="unknown"
          fi

          proj_label="proj:${slug}"

          # Create label if missing (idempotent).
          gh label create "${proj_label}" \
            --repo "${GITHUB_REPOSITORY}" \
            --description "Target project: ${target_repo}" \
            --color "0E8A16" >/dev/null 2>&1 || true

          # Apply label to the issue.
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${proj_label}" >/dev/null || true

          # Prefix title for easy scanning in the issue list (avoid clobbering an existing [..] prefix).
          if ! echo "${title}" | grep -Eq '^\[[^]]+\]\s'; then
            new_title="[${slug}] ${title}"
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --title "${new_title}" >/dev/null || true
          fi

      - name: GHA24 mainframe handoff (natural language)
        id: handoff
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.trusted == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
          DEFAULT_MAIN_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_MAIN_ORCHESTRATOR_PROVIDER || vars.FUGUE_ORCHESTRATOR_PROVIDER || 'codex' }}
          DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_ASSIST_ORCHESTRATOR_PROVIDER || 'claude' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
        run: |
          set -euo pipefail

          title="${ISSUE_TITLE}"
          body="${ISSUE_BODY}"
          text="$(printf '%s\n%s\n' "${title}" "${body}")"

          issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          label_main_provider="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] as $labels
            | if ((($labels | index("orchestrator:claude")) != null) and (($labels | index("orchestrator:codex")) != null)) then ""
              elif (($labels | index("orchestrator:claude")) != null) then "claude"
              elif (($labels | index("orchestrator:codex")) != null) then "codex"
              else "" end
          ')"
          label_assist_provider="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] as $labels
            | if (($labels | index("orchestrator-assist:none")) != null) then "none"
              elif ((($labels | index("orchestrator-assist:claude")) != null) and (($labels | index("orchestrator-assist:codex")) != null)) then ""
              elif (($labels | index("orchestrator-assist:claude")) != null) then "claude"
              elif (($labels | index("orchestrator-assist:codex")) != null) then "codex"
              else "" end
          ')"
          force_claude="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] | index("orchestrator-force:claude") != null
          ')"
          body_main_provider="$(printf '%s\n' "${body}" | awk '
            BEGIN { in_sec=0 }
            tolower($0) ~ /^##[[:space:]]*orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
            in_sec && $0 ~ /^##[[:space:]]/ { exit }
            in_sec {
              line=$0
              gsub(/`/, "", line)
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
              if (line != "") {
                print tolower(line)
                exit
              }
            }
          ')"
          if [[ "${body_main_provider}" != "claude" && "${body_main_provider}" != "codex" ]]; then
            body_main_provider=""
          fi
          if [[ -z "${body_main_provider}" ]]; then
            body_main_provider="$(echo "${body}" | sed -nE 's/^[[:space:]]*orchestrator[[:space:]_-]*provider[[:space:]]*:[[:space:]]*(claude|codex)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
          fi

          body_assist_provider="$(printf '%s\n' "${body}" | awk '
            BEGIN { in_sec=0 }
            tolower($0) ~ /^##[[:space:]]*assist[[:space:]]+orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
            in_sec && $0 ~ /^##[[:space:]]/ { exit }
            in_sec {
              line=$0
              gsub(/`/, "", line)
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
              if (line != "") {
                print tolower(line)
                exit
              }
            }
          ')"
          if [[ "${body_assist_provider}" != "claude" && "${body_assist_provider}" != "codex" && "${body_assist_provider}" != "none" ]]; then
            body_assist_provider=""
          fi
          if [[ -z "${body_assist_provider}" ]]; then
            body_assist_provider="$(echo "${body}" | sed -nE 's/^[[:space:]]*assist[[:space:]]+orchestrator[[:space:]_-]*provider[[:space:]]*:[[:space:]]*(claude|codex|none)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
          fi

          provider="${label_main_provider}"
          if [[ -z "${provider}" && -n "${body_main_provider}" ]]; then
            provider="${body_main_provider}"
          fi
          if [[ -z "${provider}" ]]; then
            provider="$(echo "${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER:-codex}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          fi
          if [[ "${provider}" != "claude" && "${provider}" != "codex" ]]; then
            provider="codex"
          fi

          assist_provider="${label_assist_provider}"
          if [[ -z "${assist_provider}" && -n "${body_assist_provider}" ]]; then
            assist_provider="${body_assist_provider}"
          fi
          if [[ -z "${assist_provider}" ]]; then
            assist_provider="$(echo "${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER:-claude}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          fi
          if [[ "${assist_provider}" != "claude" && "${assist_provider}" != "codex" && "${assist_provider}" != "none" ]]; then
            assist_provider="claude"
          fi
          requested_provider="${provider}"
          requested_assist_provider="${assist_provider}"
          claude_state="$(echo "${CLAUDE_RATE_LIMIT_STATE:-ok}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_state}" != "ok" && "${claude_state}" != "degraded" && "${claude_state}" != "exhausted" ]]; then
            claude_state="ok"
          fi
          main_fallback_note=""
          if [[ "${provider}" == "claude" && "${claude_state}" != "ok" && "${force_claude}" != "true" ]]; then
            provider="codex"
            main_fallback_note="Main orchestrator auto-fallback: requested \`claude\` but switched to \`codex\` due to \`claude-rate-limit-${claude_state}\`."
          fi
          assist_fallback_note=""
          if [[ "${assist_provider}" == "claude" && "${claude_state}" == "exhausted" && "${force_claude}" != "true" ]]; then
            assist_provider="none"
            assist_fallback_note="Assist orchestrator auto-fallback: requested \`claude\` but switched to \`none\` due to \`claude-rate-limit-${claude_state}\`."
          fi

          compat_label="$( [[ "${provider}" == "claude" ]] && echo "claude-implement" || echo "codex-implement" )"
          orchestrator_label="orchestrator:${provider}"
          assist_orchestrator_label="orchestrator-assist:${assist_provider}"

          # Default: fugue-task issues are handed off to the GHA24 mainframe.
          # Explicit manual markers can opt out.
          wants_mainframe=true
          if echo "${text}" | grep -Eqi '(mainframeしない|自動実行しない|manual only|#manual|#no-gha24)'; then
            wants_mainframe=false
          fi

          if [[ "${wants_mainframe}" != "true" ]]; then
            echo "handoff=false" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          # Mode selection:
          # - If user explicitly asked for mainframe completion, default to implement.
          # - Explicit review-only wins over implement.
          wants_review=false
          wants_implement=true
          if echo "${text}" | grep -Eqi '(レビューのみ|指摘のみ|実装しない|実装不要|review only|no implement|no-implement|#review)'; then
            wants_review=true
          fi
          if [[ "${wants_review}" == "true" ]]; then
            wants_implement=false
          fi

          # Safety guard: when review-only is explicitly requested, clear any
          # stale implementation intent labels before handing off to Tutti.
          if [[ "${wants_implement}" != "true" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" \
              --remove-label "implement" \
              --remove-label "codex-implement" \
              --remove-label "claude-implement" >/dev/null 2>&1 || true
          fi

          # Prefer provider-agnostic implement intent label while also adding
          # a provider-specific compatibility label for existing tooling.
          if [[ "${wants_implement}" == "true" ]]; then
            # Keep only one compatibility label in sync with the resolved
            # orchestrator provider to avoid stale dual-label drift.
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" \
              --remove-label "codex-implement" \
              --remove-label "claude-implement" >/dev/null 2>&1 || true
            gh label create "implement" \
              --repo "${GITHUB_REPOSITORY}" \
              --description "Implementation intent (provider-agnostic)" \
              --color "1D76DB" >/dev/null 2>&1 || true
            gh label create "${compat_label}" \
              --repo "${GITHUB_REPOSITORY}" \
              --description "Implementation intent compatibility label" \
              --color "0052CC" >/dev/null 2>&1 || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "implement" >/dev/null
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${compat_label}" >/dev/null
          fi

          gh label create "${orchestrator_label}" \
            --repo "${GITHUB_REPOSITORY}" \
            --description "Requested orchestrator profile for Tutti routing" \
            --color "5319E7" >/dev/null 2>&1 || true
          gh label create "${assist_orchestrator_label}" \
            --repo "${GITHUB_REPOSITORY}" \
            --description "Requested assist orchestrator profile for Tutti routing" \
            --color "0052CC" >/dev/null 2>&1 || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "orchestrator:claude" --remove-label "orchestrator:codex" >/dev/null 2>&1 || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "orchestrator-assist:claude" --remove-label "orchestrator-assist:codex" --remove-label "orchestrator-assist:none" >/dev/null 2>&1 || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${orchestrator_label}" >/dev/null
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${assist_orchestrator_label}" >/dev/null

          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "tutti" >/dev/null

          mode="$( [[ "${wants_implement}" == "true" ]] && echo "implement" || echo "review" )"
          extra=""
          if [[ "${wants_implement}" == "true" ]]; then
            extra=" + implement (+ ${compat_label} compatibility)"
          fi
          provider_line="- Orchestrator: ${provider}"
          if [[ -n "${main_fallback_note}" ]]; then
            provider_line="- Orchestrator: ${provider} (requested: ${requested_provider})"
          fi
          assist_provider_line="- Assist orchestrator: ${assist_provider}"
          if [[ -n "${assist_fallback_note}" ]]; then
            assist_provider_line="- Assist orchestrator: ${assist_provider} (requested: ${requested_assist_provider})"
          fi
          fallback_block="$(printf '%s\n%s\n' "${main_fallback_note}" "${assist_fallback_note}" | sed '/^$/d')"
          cat > handoff-comment.md <<EOF
          GHA24 mainframe handoff (natural language)

          - Mode: ${mode}
          ${provider_line}
          ${assist_provider_line}
          - Action: added label \`tutti\`${extra}
          ${fallback_block}

          Next: Tutti runs and posts the vote/audit comment. If approved and an implementation label is present, Codex will create a PR.
          EOF
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body-file handoff-comment.md

          # IMPORTANT: label events created by GitHub Actions' GITHUB_TOKEN do NOT trigger other workflows.
          # We must dispatch the mainframe workflow explicitly.
          gh workflow run fugue-tutti-caller.yml \
            --repo "${GITHUB_REPOSITORY}" \
            -f issue_number="${ISSUE_NUMBER}" >/dev/null

          echo "handoff=true" >> "${GITHUB_OUTPUT}"
          echo "mode=${mode}" >> "${GITHUB_OUTPUT}"

      - name: Detect post-handoff routing state
        id: route_state
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
        run: |
          set -euo pipefail
          issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          echo "has_tutti=${HAS_TUTTI}" >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --add-label "processing"

      - name: Untrusted mainframe request notice
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.trusted != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
        run: |
          set -euo pipefail
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Mainframe handoff is restricted to trusted collaborators (write/maintain/admin). Current permission: `${{ steps.ctx.outputs.permission }}`."

      - name: Classify intent (Node.js decision table)
        id: classify
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' }}
        env:
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const title = (process.env.ISSUE_TITLE || "").toLowerCase();
          const body = (process.env.ISSUE_BODY || "").toLowerCase();
          const text = `${title}\n${body}`;

          const rules = [
            { keywords: ["x/twitter", "twitter", "tweet", "x検索", "トレンド", "リアルタイム", "grok", "xai"], provider: "xai", agent: "realtime-info", tier: 2, intent: "x-realtime" },
            { keywords: ["ui", "ux", "ui design", "ux design", "figma", "screenshot", "レイアウト", "デザイン", "画面", "画像"], provider: "gemini", agent: "ui-reviewer", tier: 2, intent: "visual-review" },
            { keywords: ["review", "レビュー"], provider: "codex", agent: "code-reviewer", tier: 0, intent: "review" },
            { keywords: ["security", "セキュリティ"], provider: "codex", agent: "security-analyst", tier: 1, intent: "security" },
            { keywords: ["設計", "architecture"], provider: "codex", agent: "architect", tier: 1, intent: "architecture" },
            { keywords: ["修正", "fix", "bug"], provider: "codex", agent: "code-reviewer", tier: 2, intent: "fix" },
            { keywords: ["deploy", "本番"], provider: "null", agent: "null", tier: 3, intent: "deploy" }
          ];

          let selected = { provider: "codex", agent: "general-reviewer", tier: 2, intent: "default" };
          for (const rule of rules) {
            if (rule.keywords.some(k => text.includes(k.toLowerCase()))) {
              selected = rule;
              break;
            }
          }

          const out = (k, v) => fs.appendFileSync(process.env.GITHUB_OUTPUT, `${k}=${v}\n`);
          out("provider", selected.provider);
          out("agent", selected.agent);
          out("tier", selected.tier);
          out("intent", selected.intent);
          NODE

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          AUTHOR="${{ steps.ctx.outputs.author }}"

          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Resolve final tier
        id: final
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' }}
        run: |
          BASE_TIER="${{ steps.classify.outputs.tier }}"
          TRUSTED="${{ steps.trust.outputs.trusted }}"
          FINAL_TIER="${BASE_TIER}"
          if [[ "${TRUSTED}" != "true" ]]; then
            FINAL_TIER="3"
          fi
          echo "tier=${FINAL_TIER}" >> "${GITHUB_OUTPUT}"

      - name: Execute agent and post result (Tier 0-2)
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.final.outputs.tier != '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ZAI_MODEL: glm-5.0
          XAI_MODEL: grok-3-mini
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          PROVIDER="${{ steps.classify.outputs.provider }}"
          AGENT="${{ steps.classify.outputs.agent }}"
          TIER="${{ steps.final.outputs.tier }}"
          TITLE="${ISSUE_TITLE}"
          BODY="${ISSUE_BODY}"

          SYS_PROMPT="You are ${AGENT}. Provide concise, actionable guidance for this GitHub issue."
          USER_PROMPT="Issue Title: ${TITLE}

          Issue Body:
          ${BODY}"

          RESP=""
          RESP_PROVIDER=""
          # Try OpenAI first if provider is codex
          if [[ "${PROVIDER}" == "codex" && -n "${OPENAI_API_KEY}" ]]; then
            OPENAI_MODEL_CANDIDATES=("gpt-5.3-codex-spark" "gpt-5.3-codex" "gpt-5.2-codex" "gpt-5.1-codex" "gpt-4.1" "gpt-4o-mini")
            for OPENAI_MODEL in "${OPENAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${OPENAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="codex"
                echo "OpenAI ok (model=${OPENAI_MODEL})"
                break
              fi
              echo "OpenAI failed (model=${OPENAI_MODEL}, http=${HTTP_CODE})"
            done
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "gemini" && -n "${GEMINI_API_KEY:-}" ]]; then
            REQ="$(jq -n --arg text "SYSTEM:\n${SYS_PROMPT}\n\nUSER:\n${USER_PROMPT}\n\nReturn concise actionable guidance." '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.2}}')"
            GEMINI_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}"
            raw="$(curl -sS -w "\n%{http_code}" "${GEMINI_URL}" \
              -H "Content-Type: application/json" \
              -d "${REQ}" 2>/dev/null || true)"
            HTTP_CODE="$(echo "${raw}" | tail -1)"
            RESP_BODY="$(echo "${raw}" | sed '$d')"
            if [[ "${HTTP_CODE}" == "200" ]]; then
              RESP="${RESP_BODY}"
              RESP_PROVIDER="gemini"
            fi
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "xai" && -n "${XAI_API_KEY:-}" ]]; then
            XAI_MODEL_CANDIDATES=("${XAI_MODEL}" "grok-2-latest")
            for XAI_MODEL_NAME in "${XAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${XAI_MODEL_NAME}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.x.ai/v1/chat/completions \
                -H "Authorization: Bearer ${XAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="xai"
                break
              fi
            done
          fi

          # GLM fallback or primary
          if [[ -z "${RESP}" ]]; then
            REQ="$(jq -n --arg model "${ZAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
            raw="$(curl -sS -w "\n%{http_code}" https://api.z.ai/api/coding/paas/v4/chat/completions \
              -H "Authorization: Bearer ${ZAI_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "${REQ}" 2>/dev/null || true)"
            HTTP_CODE="$(echo "${raw}" | tail -1)"
            RESP_BODY="$(echo "${raw}" | sed '$d')"
            if [[ "${HTTP_CODE}" == "200" ]]; then
              RESP="${RESP_BODY}"
              RESP_PROVIDER="glm"
            else
              echo "GLM failed (http=${HTTP_CODE})"
            fi
          fi

          if [[ -z "${RESP}" ]]; then
            ANSWER="自動実行で外部LLM呼び出しに失敗しました。`needs-human` を付与したので、手動確認をお願いします。"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${ANSWER}"
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"
            exit 0
          elif [[ "${RESP_PROVIDER}" == "gemini" ]]; then
            ANSWER="$(echo "${RESP}" | jq -r '.candidates[0].content.parts[0].text // "No response body returned."' )"
          else
            ANSWER="$(echo "${RESP}" | jq -r '.choices[0].message.content // "No response body returned."' )"
          fi

          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${ANSWER}"

          if [[ "${TIER}" == "0" || "${TIER}" == "1" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "needs-review" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
            gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
          fi

      - name: Tier 3 fallback
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.final.outputs.tier == '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" || true
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "自動実行不可。人間の承認が必要です。"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"

      - name: Remove processing label
        if: ${{ always() && steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true

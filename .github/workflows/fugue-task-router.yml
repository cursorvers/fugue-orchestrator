name: fugue-task-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
    secrets:
      OPENAI_API_KEY:
        required: false
      ZAI_API_KEY:
        required: false
      GEMINI_API_KEY:
        required: false
      XAI_API_KEY:
        required: false
  issues:
    # Avoid `labeled` here: labels added by automation (processing/proj/tutti) can
    # create extra runs and cause unnecessary concurrency cancellations.
    types: [opened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string

permissions:
  issues: write
  contents: read
  actions: write

jobs:
  route:
    # Ignore bot-driven issue label churn (processing/proj labels), but still allow
    # watchdog-triggered workflow_dispatch to run as github-actions[bot].
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: fugue-task-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.event.inputs.issue_number || github.run_id }}
      cancel-in-progress: false

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          COMMENT_BODY=""
          COMMENT_AUTHOR=""
          IS_VOTE_COMMAND="false"
          VOTE_INSTRUCTION=""
          if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            COMMENT_BODY="$(jq -r '.comment.body // ""' "${GITHUB_EVENT_PATH}")"
            COMMENT_AUTHOR="$(jq -r '.comment.user.login // ""' "${GITHUB_EVENT_PATH}")"
            comment_trimmed="$(printf '%s\n' "${COMMENT_BODY}" | sed -E 's/^[[:space:]]+//')"
            if printf '%s\n' "${comment_trimmed}" | grep -Eqi '^/vote([[:space:]]|$)'; then
              IS_VOTE_COMMAND="true"
              VOTE_INSTRUCTION="$(printf '%s' "${comment_trimmed}" | sed -E '1s%^[[:space:]]*/vote[[:space:]]*%%')"
              VOTE_INSTRUCTION="$(printf '%s' "${VOTE_INSTRUCTION}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
            fi
          fi

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_call" ]]; then
            ISSUE_NUMBER="${{ inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          AUTHOR_ASSOC="$(echo "${issue_json}" | jq -r '.author_association // "NONE"')"

          # Trust gate (write/maintain/admin). For issue comments, evaluate the
          # comment actor (triggering user), not the issue author.
          TRUST_SUBJECT="${AUTHOR}"
          if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            TRUST_SUBJECT="${COMMENT_AUTHOR}"
          fi
          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${TRUST_SUBJECT}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi
          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_GHA24="$(echo "${issue_json}" | jq -r '((.body // "") | test("^##\\s*GHA24\\s*Task"; "m"))')"

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-fugue-task-label"
          elif [[ "${HAS_GHA24}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-gha24"
          elif [[ "${HAS_TUTTI}" == "true" && "${IS_VOTE_COMMAND}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-tutti"
          elif [[ "${HAS_PROCESSING}" == "true" && "${IS_VOTE_COMMAND}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "comment_body<<EOF"
            echo "${COMMENT_BODY}"
            echo "EOF"
            echo "comment_author=${COMMENT_AUTHOR}"
            echo "is_vote_command=${IS_VOTE_COMMAND}"
            echo "vote_instruction<<EOF"
            echo "${VOTE_INSTRUCTION}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "trust_subject=${TRUST_SUBJECT}"
            echo "author_association=${AUTHOR_ASSOC}"
            echo "trusted=${TRUSTED}"
            echo "permission=${PERM}"
            echo "has_fugue=${HAS_FUGUE}"
            echo "has_tutti=${HAS_TUTTI}"
            echo "has_processing=${HAS_PROCESSING}"
            echo "has_gha24=${HAS_GHA24}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Skip when not target
        if: ${{ steps.ctx.outputs.should_run != 'true' }}
        run: |
          echo "Skip reason: ${{ steps.ctx.outputs.skip_reason }}"

      - name: Checkout repository
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        uses: actions/checkout@v4

      - name: Resolve orchestrator workflow ref
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        id: orch_ref
        run: |
          set -euo pipefail
          ref="${GITHUB_WORKFLOW_REF##*@}"
          if [[ -z "${ref}" ]]; then
            ref="main"
          fi
          echo "ref=${ref}" >> "${GITHUB_OUTPUT}"

      - name: Checkout orchestrator scripts
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: cursorvers/fugue-orchestrator
          ref: ${{ steps.orch_ref.outputs.ref }}
          path: .fugue-orchestrator

      - name: Annotate target project (label + title prefix)
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
          COMMENT_BODY: ${{ steps.ctx.outputs.comment_body }}
          IS_VOTE_COMMAND: ${{ steps.ctx.outputs.is_vote_command }}
        run: |
          set -euo pipefail

          title="${ISSUE_TITLE}"
          body="${ISSUE_BODY}"
          comment="${COMMENT_BODY}"
          is_vote_command="$(echo "${IS_VOTE_COMMAND:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${is_vote_command}" == "true" ]]; then
            # Ignore /vote comment body for routing metadata extraction.
            text="$(printf '%s\n%s\n' "${title}" "${body}")"
          else
            text="$(printf '%s\n%s\n%s\n' "${title}" "${body}" "${comment}")"
          fi

          owner="${GITHUB_REPOSITORY%%/*}"

          # 1) Prefer fully-qualified owner/repo found inside backticks.
          target_repo="$(printf '%s\n' "${text}" \
            | sed -nE 's/.*`([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)`.*/\1/p' \
            | head -n1)"

          # 1b) Also accept plain "owner/repo" (common on mobile forms).
          if [[ -z "${target_repo}" ]]; then
            target_repo="$(printf '%s\n' "${text}" | grep -oE "${owner}/[A-Za-z0-9_.-]+" | head -n1 || true)"
          fi

          # 2) Fallback: repo name in backticks on lines mentioning repo/リポジトリ.
          if [[ -z "${target_repo}" ]]; then
            bare_repo="$(printf '%s\n' "${text}" \
              | grep -E 'repo|Repo|repository|Repository|リポジトリ|対象|target' \
              | sed -nE 's/.*`([A-Za-z0-9_.-]+)`.*/\1/p' \
              | head -n1 || true)"
            if [[ -n "${bare_repo}" ]]; then
              target_repo="${owner}/${bare_repo}"
            fi
          fi

          # 3) Default to caller repo when no hint exists.
          if [[ -z "${target_repo}" ]]; then
            target_repo="${GITHUB_REPOSITORY}"
          fi

          short="${target_repo#*/}"
          slug="$(printf '%s' "${short}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_.-]/-/g' | sed 's/--*/-/g' | head -c 40)"
          if [[ -z "${slug}" ]]; then
            slug="unknown"
          fi

          proj_label="proj:${slug}"

          # Create label if missing (idempotent).
          gh label create "${proj_label}" \
            --repo "${GITHUB_REPOSITORY}" \
            --description "Target project: ${target_repo}" \
            --color "0E8A16" >/dev/null 2>&1 || true

          # Apply label to the issue.
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${proj_label}" >/dev/null || true

          # Prefix title for easy scanning in the issue list (avoid clobbering an existing [..] prefix).
          if ! echo "${title}" | grep -Eq '^\[[^]]+\]\s'; then
            new_title="[${slug}] ${title}"
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --title "${new_title}" >/dev/null || true
          fi

      - name: GHA24 mainframe handoff (natural language)
        id: handoff
        if: ${{ steps.ctx.outputs.should_run == 'true' && (steps.ctx.outputs.trusted == 'true' || steps.ctx.outputs.is_vote_command == 'true') }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
          COMMENT_BODY: ${{ steps.ctx.outputs.comment_body }}
          IS_VOTE_COMMAND: ${{ steps.ctx.outputs.is_vote_command }}
          VOTE_INSTRUCTION: ${{ steps.ctx.outputs.vote_instruction }}
          TRUST_SUBJECT: ${{ steps.ctx.outputs.trust_subject }}
          DEFAULT_MAIN_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_MAIN_ORCHESTRATOR_PROVIDER || vars.FUGUE_ORCHESTRATOR_PROVIDER || 'codex' }}
          DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_ASSIST_ORCHESTRATOR_PROVIDER || 'claude' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          CLAUDE_MAIN_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_MAIN_ASSIST_POLICY || 'codex' }}
          CLAUDE_ROLE_POLICY: ${{ vars.FUGUE_CLAUDE_ROLE_POLICY || 'flex' }}
          CLAUDE_DEGRADED_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_DEGRADED_ASSIST_POLICY || 'claude' }}
        run: bash scripts/harness/route-task-handoff.sh

      - name: Detect post-handoff routing state
        id: route_state
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
        run: |
          set -euo pipefail
          issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          echo "has_tutti=${HAS_TUTTI}" >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.trusted == 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --add-label "processing"

      - name: Untrusted mainframe request notice
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.trusted != 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
        run: |
          set -euo pipefail
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Mainframe handoff is restricted to trusted collaborators (write/maintain/admin). Current permission: `${{ steps.ctx.outputs.permission }}`."

      - name: Classify intent (Node.js decision table)
        id: classify
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        env:
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const title = (process.env.ISSUE_TITLE || "").toLowerCase();
          const body = (process.env.ISSUE_BODY || "").toLowerCase();
          const text = `${title}\n${body}`;

          const rules = [
            { keywords: ["x/twitter", "twitter", "tweet", "x検索", "トレンド", "リアルタイム", "grok", "xai"], provider: "xai", agent: "realtime-info", tier: 2, intent: "x-realtime" },
            { keywords: ["ui", "ux", "ui design", "ux design", "figma", "screenshot", "レイアウト", "デザイン", "画面", "画像"], provider: "gemini", agent: "ui-reviewer", tier: 2, intent: "visual-review" },
            { keywords: ["review", "レビュー"], provider: "codex", agent: "code-reviewer", tier: 0, intent: "review" },
            { keywords: ["security", "セキュリティ"], provider: "codex", agent: "security-analyst", tier: 1, intent: "security" },
            { keywords: ["設計", "architecture"], provider: "codex", agent: "architect", tier: 1, intent: "architecture" },
            { keywords: ["修正", "fix", "bug"], provider: "codex", agent: "code-reviewer", tier: 2, intent: "fix" },
            { keywords: ["deploy", "本番"], provider: "null", agent: "null", tier: 3, intent: "deploy" }
          ];

          let selected = { provider: "codex", agent: "general-reviewer", tier: 2, intent: "default" };
          for (const rule of rules) {
            if (rule.keywords.some(k => text.includes(k.toLowerCase()))) {
              selected = rule;
              break;
            }
          }

          const out = (k, v) => fs.appendFileSync(process.env.GITHUB_OUTPUT, `${k}=${v}\n`);
          out("provider", selected.provider);
          out("agent", selected.agent);
          out("tier", selected.tier);
          out("intent", selected.intent);
          NODE

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          TRUST_SUBJECT="${{ steps.ctx.outputs.trust_subject }}"
          if [[ -z "${TRUST_SUBJECT}" ]]; then
            TRUST_SUBJECT="${{ steps.ctx.outputs.author }}"
          fi

          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${TRUST_SUBJECT}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Resolve final tier
        id: final
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        run: |
          BASE_TIER="${{ steps.classify.outputs.tier }}"
          TRUSTED="${{ steps.trust.outputs.trusted }}"
          FINAL_TIER="${BASE_TIER}"
          if [[ "${TRUSTED}" != "true" ]]; then
            FINAL_TIER="3"
          fi
          echo "tier=${FINAL_TIER}" >> "${GITHUB_OUTPUT}"

      - name: Execute agent and post result (Tier 0-2)
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.is_vote_command != 'true' && steps.final.outputs.tier != '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ZAI_MODEL: glm-5.0
          XAI_MODEL: ${{ vars.FUGUE_XAI_MODEL || 'grok-4' }}
          GEMINI_PRIMARY_MODEL: ${{ vars.FUGUE_GEMINI_MODEL || 'gemini-3.1-pro' }}
          GEMINI_FALLBACK_MODEL: ${{ vars.FUGUE_GEMINI_FALLBACK_MODEL || 'gemini-3-flash' }}
          CODEX_MAIN_MODEL: ${{ vars.FUGUE_CODEX_MAIN_MODEL || 'gpt-5-codex' }}
          CODEX_MULTI_AGENT_MODEL: ${{ vars.FUGUE_CODEX_MULTI_AGENT_MODEL || 'gpt-5.3-codex-spark' }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          PROVIDER="${{ steps.classify.outputs.provider }}"
          AGENT="${{ steps.classify.outputs.agent }}"
          TIER="${{ steps.final.outputs.tier }}"
          TITLE="${ISSUE_TITLE}"
          BODY="${ISSUE_BODY}"
          CODEX_MAIN_MODEL="gpt-5-codex"
          if ! [[ "${CODEX_MULTI_AGENT_MODEL}" =~ ^gpt-5(\.[0-9]+)?-codex-spark$ ]]; then
            CODEX_MULTI_AGENT_MODEL="gpt-5.3-codex-spark"
          fi
          if [[ "${GEMINI_PRIMARY_MODEL}" != "gemini-3.1-pro" && "${GEMINI_PRIMARY_MODEL}" != "gemini-3-flash" ]]; then
            GEMINI_PRIMARY_MODEL="gemini-3.1-pro"
          fi
          if [[ "${GEMINI_FALLBACK_MODEL}" != "gemini-3.1-pro" && "${GEMINI_FALLBACK_MODEL}" != "gemini-3-flash" ]]; then
            GEMINI_FALLBACK_MODEL="gemini-3-flash"
          fi
          if ! [[ "${XAI_MODEL}" =~ ^grok-4([.-].+)?$ ]]; then
            XAI_MODEL="grok-4"
          fi

          SYS_PROMPT="You are ${AGENT}. Provide concise, actionable guidance for this GitHub issue."
          USER_PROMPT="Issue Title: ${TITLE}

          Issue Body:
          ${BODY}"

          RESP=""
          RESP_PROVIDER=""
          # Try OpenAI first if provider is codex
          if [[ "${PROVIDER}" == "codex" && -n "${OPENAI_API_KEY}" ]]; then
            OPENAI_MODEL_CANDIDATES=("${CODEX_MULTI_AGENT_MODEL}" "${CODEX_MAIN_MODEL}" "gpt-5-codex")
            for OPENAI_MODEL in "${OPENAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${OPENAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="codex"
                echo "OpenAI ok (model=${OPENAI_MODEL})"
                break
              fi
              echo "OpenAI failed (model=${OPENAI_MODEL}, http=${HTTP_CODE})"
            done
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "gemini" && -n "${GEMINI_API_KEY:-}" ]]; then
            REQ="$(jq -n --arg text "SYSTEM:\n${SYS_PROMPT}\n\nUSER:\n${USER_PROMPT}\n\nReturn concise actionable guidance." '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.2}}')"
            for GEMINI_MODEL in "${GEMINI_PRIMARY_MODEL}" "${GEMINI_FALLBACK_MODEL}"; do
              GEMINI_URL="https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}"
              raw="$(curl -sS -w "\n%{http_code}" "${GEMINI_URL}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="gemini"
                break
              fi
            done
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "xai" && -n "${XAI_API_KEY:-}" ]]; then
            XAI_MODEL_CANDIDATES=("${XAI_MODEL}" "grok-4-fast-reasoning" "grok-4-fast-non-reasoning")
            for XAI_MODEL_NAME in "${XAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${XAI_MODEL_NAME}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.x.ai/v1/chat/completions \
                -H "Authorization: Bearer ${XAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="xai"
                break
              fi
            done
          fi

          # GLM fallback or primary
          if [[ -z "${RESP}" ]]; then
            REQ="$(jq -n --arg model "${ZAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
            raw="$(curl -sS -w "\n%{http_code}" https://api.z.ai/api/coding/paas/v4/chat/completions \
              -H "Authorization: Bearer ${ZAI_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "${REQ}" 2>/dev/null || true)"
            HTTP_CODE="$(echo "${raw}" | tail -1)"
            RESP_BODY="$(echo "${raw}" | sed '$d')"
            if [[ "${HTTP_CODE}" == "200" ]]; then
              RESP="${RESP_BODY}"
              RESP_PROVIDER="glm"
            else
              echo "GLM failed (http=${HTTP_CODE})"
            fi
          fi

          if [[ -z "${RESP}" ]]; then
            ANSWER="自動実行で外部LLM呼び出しに失敗しました。`needs-human` を付与したので、手動確認をお願いします。"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${ANSWER}"
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"
            exit 0
          elif [[ "${RESP_PROVIDER}" == "gemini" ]]; then
            ANSWER="$(echo "${RESP}" | jq -r '.candidates[0].content.parts[0].text // "No response body returned."' )"
          else
            ANSWER="$(echo "${RESP}" | jq -r '.choices[0].message.content // "No response body returned."' )"
          fi

          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${ANSWER}"

          if [[ "${TIER}" == "0" || "${TIER}" == "1" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "needs-review" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
            gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
          fi

      - name: Tier 3 fallback
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.is_vote_command != 'true' && steps.final.outputs.tier == '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" || true
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "自動実行不可。人間の承認が必要です。"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"

      - name: Remove processing label
        if: ${{ always() && steps.ctx.outputs.should_run == 'true' && steps.route_state.outputs.has_tutti != 'true' && steps.ctx.outputs.trusted == 'true' && steps.ctx.outputs.is_vote_command != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true

name: fugue-task-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
    secrets:
      OPENAI_API_KEY:
        required: true
      ZAI_API_KEY:
        required: true
      GEMINI_API_KEY:
        required: false
      XAI_API_KEY:
        required: false
  issues:
    # Avoid `labeled` here: labels added by automation (processing/proj/tutti) can
    # create extra runs and cause unnecessary concurrency cancellations.
    types: [opened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string

permissions:
  issues: write
  contents: read
  actions: write

jobs:
  route:
    # Ignore bot-driven issue label churn (processing/proj labels), but still allow
    # watchdog-triggered workflow_dispatch to run as github-actions[bot].
    if: ${{ github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_call' || github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: fugue-task-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.event.inputs.issue_number || github.run_id }}
      cancel-in-progress: false

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          COMMENT_BODY=""
          if [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
            COMMENT_BODY="$(jq -r '.comment.body // ""' "${GITHUB_EVENT_PATH}")"
          fi

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_call" ]]; then
            ISSUE_NUMBER="${{ inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          elif [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            ISSUE_NUMBER="${{ github.event.inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          AUTHOR_ASSOC="$(echo "${issue_json}" | jq -r '.author_association // "NONE"')"

          # Trust gate (write/maintain/admin). Used to prevent untrusted users
          # from dispatching the mainframe workflows.
          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi
          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_GHA24="$(echo "${issue_json}" | jq -r '((.body // "") | test("^##\\s*GHA24\\s*Task"; "m"))')"

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-fugue-task-label"
          elif [[ "${HAS_GHA24}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-gha24"
          elif [[ "${HAS_TUTTI}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="handled-by-tutti"
          elif [[ "${HAS_PROCESSING}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "comment_body<<EOF"
            echo "${COMMENT_BODY}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "author_association=${AUTHOR_ASSOC}"
            echo "trusted=${TRUSTED}"
            echo "permission=${PERM}"
            echo "has_fugue=${HAS_FUGUE}"
            echo "has_tutti=${HAS_TUTTI}"
            echo "has_processing=${HAS_PROCESSING}"
            echo "has_gha24=${HAS_GHA24}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Skip when not target
        if: ${{ steps.ctx.outputs.should_run != 'true' }}
        run: |
          echo "Skip reason: ${{ steps.ctx.outputs.skip_reason }}"

      - name: Annotate target project (label + title prefix)
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
          COMMENT_BODY: ${{ steps.ctx.outputs.comment_body }}
        run: |
          set -euo pipefail

          title="${ISSUE_TITLE}"
          body="${ISSUE_BODY}"
          comment="${COMMENT_BODY}"
          text="$(printf '%s\n%s\n%s\n' "${title}" "${body}" "${comment}")"

          owner="${GITHUB_REPOSITORY%%/*}"

          # 1) Prefer fully-qualified owner/repo found inside backticks.
          target_repo="$(printf '%s\n' "${text}" \
            | sed -nE 's/.*`([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)`.*/\1/p' \
            | head -n1)"

          # 1b) Also accept plain "owner/repo" (common on mobile forms).
          if [[ -z "${target_repo}" ]]; then
            target_repo="$(printf '%s\n' "${text}" | grep -oE "${owner}/[A-Za-z0-9_.-]+" | head -n1 || true)"
          fi

          # 2) Fallback: repo name in backticks on lines mentioning repo/リポジトリ.
          if [[ -z "${target_repo}" ]]; then
            bare_repo="$(printf '%s\n' "${text}" \
              | grep -E 'repo|Repo|repository|Repository|リポジトリ|対象|target' \
              | sed -nE 's/.*`([A-Za-z0-9_.-]+)`.*/\1/p' \
              | head -n1 || true)"
            if [[ -n "${bare_repo}" ]]; then
              target_repo="${owner}/${bare_repo}"
            fi
          fi

          # 3) Default to caller repo when no hint exists.
          if [[ -z "${target_repo}" ]]; then
            target_repo="${GITHUB_REPOSITORY}"
          fi

          short="${target_repo#*/}"
          slug="$(printf '%s' "${short}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_.-]/-/g' | sed 's/--*/-/g' | head -c 40)"
          if [[ -z "${slug}" ]]; then
            slug="unknown"
          fi

          proj_label="proj:${slug}"

          # Create label if missing (idempotent).
          gh label create "${proj_label}" \
            --repo "${GITHUB_REPOSITORY}" \
            --description "Target project: ${target_repo}" \
            --color "0E8A16" >/dev/null 2>&1 || true

          # Apply label to the issue.
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "${proj_label}" >/dev/null || true

          # Prefix title for easy scanning in the issue list (avoid clobbering an existing [..] prefix).
          if ! echo "${title}" | grep -Eq '^\[[^]]+\]\s'; then
            new_title="[${slug}] ${title}"
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --title "${new_title}" >/dev/null || true
          fi

      - name: GHA24 mainframe handoff (natural language)
        id: handoff
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.trusted == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          set -euo pipefail

          title="${ISSUE_TITLE}"
          body="${ISSUE_BODY}"
          text="$(printf '%s\n%s\n' "${title}" "${body}")"

          # Natural-language trigger: require an explicit "complete it" intent
          # to avoid accidentally pushing issues into the GHA24 mainframe.
          wants_mainframe=false
          if echo "${text}" | grep -Eqi '(完遂|自走|完了まで|最後まで|full[- ]?auto|#gha24|GHA24)'; then
            wants_mainframe=true
          fi

          if [[ "${wants_mainframe}" != "true" ]]; then
            echo "handoff=false" >> "${GITHUB_OUTPUT}"
            exit 0
          fi

          # Mode selection:
          # - If user explicitly asked for mainframe completion, default to implement.
          # - Explicit review-only wins over implement.
          wants_review=false
          wants_implement=true
          if echo "${text}" | grep -Eqi '(レビューのみ|指摘のみ|実装しない|実装不要|review only|no implement|no-implement|#review)'; then
            wants_review=true
          fi
          if [[ "${wants_review}" == "true" ]]; then
            wants_implement=false
          fi

          # Ensure `codex-implement` label is present before firing `tutti`.
          if [[ "${wants_implement}" == "true" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "codex-implement" >/dev/null
          fi

          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "tutti" >/dev/null

          mode="$( [[ "${wants_implement}" == "true" ]] && echo "implement" || echo "review" )"
          extra=""
          if [[ "${wants_implement}" == "true" ]]; then
            extra=" + codex-implement"
          fi
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "GHA24 mainframe handoff (natural language)\n\n- Mode: ${mode}\n- Action: added label \`tutti\`${extra}\n\nNext: Tutti runs and posts the vote/audit comment. If approved and \`codex-implement\` is present, Codex will create a PR."

          # IMPORTANT: label events created by GitHub Actions' GITHUB_TOKEN do NOT trigger other workflows.
          # We must dispatch the mainframe workflow explicitly.
          gh workflow run fugue-tutti-caller.yml \
            --repo "${GITHUB_REPOSITORY}" \
            -f issue_number="${ISSUE_NUMBER}" >/dev/null

          echo "handoff=true" >> "${GITHUB_OUTPUT}"
          echo "mode=${mode}" >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --add-label "processing"

      - name: Untrusted mainframe request notice
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.trusted != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          set -euo pipefail
          text="$(printf '%s\n%s\n' "${ISSUE_TITLE}" "${ISSUE_BODY}")"
          if echo "${text}" | grep -Eqi '(完遂|自走|完了まで|最後まで|full[- ]?auto|#gha24|GHA24)'; then
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Mainframe handoff is restricted to trusted collaborators (write/maintain/admin). Current permission: `${{ steps.ctx.outputs.permission }}`."
          fi

      - name: Classify intent (Node.js decision table)
        id: classify
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' }}
        env:
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const title = (process.env.ISSUE_TITLE || "").toLowerCase();
          const body = (process.env.ISSUE_BODY || "").toLowerCase();
          const text = `${title}\n${body}`;

          const rules = [
            { keywords: ["x/twitter", "twitter", "tweet", "x検索", "トレンド", "リアルタイム", "grok", "xai"], provider: "xai", agent: "realtime-info", tier: 2, intent: "x-realtime" },
            { keywords: ["ui", "ux", "ui design", "ux design", "figma", "screenshot", "レイアウト", "デザイン", "画面", "画像"], provider: "gemini", agent: "ui-reviewer", tier: 2, intent: "visual-review" },
            { keywords: ["review", "レビュー"], provider: "glm", agent: "code-reviewer", tier: 0, intent: "review" },
            { keywords: ["security", "セキュリティ"], provider: "codex", agent: "security-analyst", tier: 1, intent: "security" },
            { keywords: ["設計", "architecture"], provider: "codex", agent: "architect", tier: 1, intent: "architecture" },
            { keywords: ["修正", "fix", "bug"], provider: "codex", agent: "code-reviewer", tier: 2, intent: "fix" },
            { keywords: ["deploy", "本番"], provider: "null", agent: "null", tier: 3, intent: "deploy" }
          ];

          let selected = { provider: "glm", agent: "general-reviewer", tier: 2, intent: "default" };
          for (const rule of rules) {
            if (rule.keywords.some(k => text.includes(k.toLowerCase()))) {
              selected = rule;
              break;
            }
          }

          const out = (k, v) => fs.appendFileSync(process.env.GITHUB_OUTPUT, `${k}=${v}\n`);
          out("provider", selected.provider);
          out("agent", selected.agent);
          out("tier", selected.tier);
          out("intent", selected.intent);
          NODE

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          AUTHOR="${{ steps.ctx.outputs.author }}"

          PERM="none"
          PERM_JSON="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${PERM_JSON}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${PERM_JSON}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Resolve final tier
        id: final
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' }}
        run: |
          BASE_TIER="${{ steps.classify.outputs.tier }}"
          TRUSTED="${{ steps.trust.outputs.trusted }}"
          FINAL_TIER="${BASE_TIER}"
          if [[ "${TRUSTED}" != "true" ]]; then
            FINAL_TIER="3"
          fi
          echo "tier=${FINAL_TIER}" >> "${GITHUB_OUTPUT}"

      - name: Execute agent and post result (Tier 0-2)
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' && steps.final.outputs.tier != '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ZAI_MODEL: glm-4.7
          XAI_MODEL: grok-3-mini
          ISSUE_TITLE: ${{ steps.ctx.outputs.issue_title }}
          ISSUE_BODY: ${{ steps.ctx.outputs.issue_body }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          PROVIDER="${{ steps.classify.outputs.provider }}"
          AGENT="${{ steps.classify.outputs.agent }}"
          TIER="${{ steps.final.outputs.tier }}"
          TITLE="${ISSUE_TITLE}"
          BODY="${ISSUE_BODY}"

          SYS_PROMPT="You are ${AGENT}. Provide concise, actionable guidance for this GitHub issue."
          USER_PROMPT="Issue Title: ${TITLE}

          Issue Body:
          ${BODY}"

          RESP=""
          RESP_PROVIDER=""
          # Try OpenAI first if provider is codex
          if [[ "${PROVIDER}" == "codex" && -n "${OPENAI_API_KEY}" ]]; then
            OPENAI_MODEL_CANDIDATES=("gpt-5.3-codex-spark" "gpt-5.3-codex" "gpt-5.2-codex" "gpt-5.1-codex" "gpt-4.1" "gpt-4o-mini")
            for OPENAI_MODEL in "${OPENAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${OPENAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="codex"
                echo "OpenAI ok (model=${OPENAI_MODEL})"
                break
              fi
              echo "OpenAI failed (model=${OPENAI_MODEL}, http=${HTTP_CODE})"
            done
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "gemini" && -n "${GEMINI_API_KEY:-}" ]]; then
            REQ="$(jq -n --arg text "SYSTEM:\n${SYS_PROMPT}\n\nUSER:\n${USER_PROMPT}\n\nReturn concise actionable guidance." '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.2}}')"
            GEMINI_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}"
            raw="$(curl -sS -w "\n%{http_code}" "${GEMINI_URL}" \
              -H "Content-Type: application/json" \
              -d "${REQ}" 2>/dev/null || true)"
            HTTP_CODE="$(echo "${raw}" | tail -1)"
            RESP_BODY="$(echo "${raw}" | sed '$d')"
            if [[ "${HTTP_CODE}" == "200" ]]; then
              RESP="${RESP_BODY}"
              RESP_PROVIDER="gemini"
            fi
          fi

          if [[ -z "${RESP}" && "${PROVIDER}" == "xai" && -n "${XAI_API_KEY:-}" ]]; then
            XAI_MODEL_CANDIDATES=("${XAI_MODEL}" "grok-2-latest")
            for XAI_MODEL_NAME in "${XAI_MODEL_CANDIDATES[@]}"; do
              REQ="$(jq -n --arg model "${XAI_MODEL_NAME}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
              raw="$(curl -sS -w "\n%{http_code}" https://api.x.ai/v1/chat/completions \
                -H "Authorization: Bearer ${XAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${REQ}" 2>/dev/null || true)"
              HTTP_CODE="$(echo "${raw}" | tail -1)"
              RESP_BODY="$(echo "${raw}" | sed '$d')"
              if [[ "${HTTP_CODE}" == "200" ]]; then
                RESP="${RESP_BODY}"
                RESP_PROVIDER="xai"
                break
              fi
            done
          fi

          # GLM fallback or primary
          if [[ -z "${RESP}" ]]; then
            REQ="$(jq -n --arg model "${ZAI_MODEL}" --arg s "${SYS_PROMPT}" --arg u "${USER_PROMPT}" '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.2}')"
            RESP="$(curl -fsS https://api.z.ai/api/coding/paas/v4/chat/completions \
              -H "Authorization: Bearer ${ZAI_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "${REQ}")"
            RESP_PROVIDER="glm"
          fi

          if [[ "${RESP_PROVIDER}" == "gemini" ]]; then
            ANSWER="$(echo "${RESP}" | jq -r '.candidates[0].content.parts[0].text // "No response body returned."' )"
          else
            ANSWER="$(echo "${RESP}" | jq -r '.choices[0].message.content // "No response body returned."' )"
          fi

          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${ANSWER}"

          if [[ "${TIER}" == "0" || "${TIER}" == "1" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "needs-review" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
            gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-human" || true
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
          fi

      - name: Tier 3 fallback
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.handoff.outputs.handoff != 'true' && steps.final.outputs.tier == '3' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE_NUMBER="${{ steps.ctx.outputs.issue_number }}"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" || true
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "自動実行不可。人間の承認が必要です。"
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"

      - name: Remove processing label
        if: ${{ always() && steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true

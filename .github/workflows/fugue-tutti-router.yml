name: fugue-tutti-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
      orchestrator_provider:
        description: "Orchestrator profile to use (claude|codex)"
        required: false
        type: string
        default: "codex"
    outputs:
      ok_to_execute:
        description: "true when approvals >= 2/3 and no HIGH risk was detected"
        value: ${{ jobs.integrate.outputs.ok_to_execute }}
      vote_passed:
        description: "true when approvals >= 2/3"
        value: ${{ jobs.integrate.outputs.vote_passed }}
      threshold:
        description: "ceil(2/3 * total_count)"
        value: ${{ jobs.integrate.outputs.threshold }}
      high_risk:
        description: "true when any agent reports HIGH risk"
        value: ${{ jobs.integrate.outputs.high_risk }}
      approve_count:
        description: "number of approvals"
        value: ${{ jobs.integrate.outputs.approve_count }}
      total_count:
        description: "number of total agent results"
        value: ${{ jobs.integrate.outputs.total_count }}
    secrets:
      OPENAI_API_KEY:
        required: true
      ZAI_API_KEY:
        required: true
      GEMINI_API_KEY:
        required: false

permissions:
  issues: write
  contents: read
  actions: read

concurrency:
  group: fugue-tutti-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_run: ${{ steps.ctx.outputs.should_run }}
      skip_reason: ${{ steps.ctx.outputs.skip_reason }}
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_title: ${{ steps.ctx.outputs.issue_title }}
      issue_body: ${{ steps.ctx.outputs.issue_body }}
      author: ${{ steps.ctx.outputs.author }}
      has_codex_implement: ${{ steps.ctx.outputs.has_codex_implement }}
      trusted: ${{ steps.trust.outputs.trusted }}
      permission: ${{ steps.trust.outputs.permission }}

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_call" ]]; then
            ISSUE_NUMBER="${{ inputs.issue_number }}"
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_CODEX_IMPLEMENT="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("codex-implement") != null')"

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" || "${HAS_TUTTI}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-required-labels"
          elif [[ "${HAS_PROCESSING}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "has_codex_implement=${HAS_CODEX_IMPLEMENT}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          AUTHOR="${{ steps.ctx.outputs.author }}"
          PERM="none"

          perm_json="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${perm_json}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${perm_json}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --remove-label "completed" \
            --remove-label "needs-review" \
            --remove-label "needs-human" \
            --remove-label "vote-approved" \
            --remove-label "vote-rejected" || true
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --add-label "processing"

      - name: Mark untrusted as needs-human
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE="${{ steps.ctx.outputs.issue_number }}"
          gh issue comment "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --body "Author trust check failed (permission: ${{ steps.trust.outputs.permission }}). Hand-off to humans required."
          gh issue edit "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human" --remove-label "processing" || true

  run-agents:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, resolve-orchestrator]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.resolve-orchestrator.outputs.agent_matrix) }}

    steps:
      - name: Call agent API
        id: call
        env:
          ISSUE_TITLE: ${{ needs.prepare.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.prepare.outputs.issue_body }}
          ORCHESTRATOR_PROVIDER: ${{ needs.resolve-orchestrator.outputs.provider }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          API_URL: ${{ matrix.api_url }}
          PROVIDER: ${{ matrix.provider }}
          MODEL: ${{ matrix.model }}
          AGENT_ROLE: ${{ matrix.agent_role }}
          AGENT_NAME: ${{ matrix.name }}
        run: |
          set -euo pipefail

          sys_prompt="You are ${AGENT_ROLE}. Analyze the GitHub issue and return ONLY valid JSON with keys: risk (LOW|MEDIUM|HIGH), approve (boolean), findings (array of strings), recommendation (string), rationale (string)."
          user_prompt="Issue Title: ${ISSUE_TITLE}

          Issue Body:
          ${ISSUE_BODY}"

          # Gemini can run without being OpenAI-compatible; if key is missing, skip it.
          if [[ "${PROVIDER}" == "gemini" && -z "${GEMINI_API_KEY:-}" ]]; then
            result="$(jq -n \
              --arg name "${AGENT_NAME}" \
              --arg provider "${PROVIDER}" \
              --arg api_url "${API_URL}" \
              --arg model "${MODEL}" \
              --arg agent_role "${AGENT_ROLE}" \
              '{
                name:$name,
                provider:$provider,
                api_url:$api_url,
                model:$model,
                agent_role:$agent_role,
                http_code:"skipped",
                skipped:true,
                risk:"MEDIUM",
                approve:false,
                findings:["Skipped: missing GEMINI_API_KEY"],
                recommendation:"Add GEMINI_API_KEY to enable Gemini voter",
                rationale:"Gemini voter was skipped due to missing secret"
              }')"
            echo "${result}" > "agent-${AGENT_NAME}.json"
            exit 0
          fi

          req=""
          auth_header=""
          if [[ "${PROVIDER}" == "codex" || "${PROVIDER}" == "glm" ]]; then
            req="$(jq -n \
              --arg model "${MODEL}" \
              --arg s "${sys_prompt}" \
              --arg u "${user_prompt}" \
              '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
            if [[ "${PROVIDER}" == "codex" ]]; then
              auth_header="Authorization: Bearer ${OPENAI_API_KEY}"
            else
              auth_header="Authorization: Bearer ${ZAI_API_KEY}"
            fi
          else
            # Gemini generateContent expects a single "user" content string. Keep it strict: JSON only.
            req="$(jq -n \
              --arg text "SYSTEM:\n${sys_prompt}\n\nUSER:\n${user_prompt}\n\nReturn ONLY JSON." \
              '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.1}}')"
          fi

          chosen_model="${MODEL}"
          http_code=""
          content=""

          if [[ "${PROVIDER}" == "codex" ]]; then
            # Prefer spark when available, but fall back to widely-available Codex models.
            candidates=("${MODEL}" "gpt-5.3-codex" "gpt-5.2-codex" "gpt-5.1-codex")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done
          else
            if [[ "${PROVIDER}" == "glm" ]]; then
              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
            else
              # Gemini REST API (key in query param)
              gemini_url="${API_URL}/${MODEL}:generateContent?key=${GEMINI_API_KEY}"
              http_code="$(curl -sS -o response.json -w "%{http_code}" "${gemini_url}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
            fi
          fi

          if [[ "${PROVIDER}" == "gemini" ]]; then
            content="$(jq -r '.candidates[0].content.parts[0].text // ""' response.json 2>/dev/null || echo "")"
          else
            content="$(jq -r '.choices[0].message.content // ""' response.json 2>/dev/null || echo "")"
          fi

          skipped_flag="false"
          # Gemini is optional; if it fails, exclude it from consensus totals.
          if [[ "${PROVIDER}" == "gemini" && "${http_code}" != "200" ]]; then
            skipped_flag="true"
          fi

          # Extract JSON even if wrapped in ```json fences.
          extracted="$(jq -Rn --arg s "${content}" '
            ($s | gsub("\r"; "") | gsub("^\\s+|\\s+$"; "")) as $t |
            if ($t | test("```json"; "i")) then
              (($t | split("```json") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            elif ($t | test("```"; "i")) then
              (($t | split("```") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            else
              $t
            end
          ')"

          normalized="$(echo "${extracted}" | jq -c '
            if type == "string" then (fromjson? // .) else . end
          ' 2>/dev/null || true)"

          if [[ -n "${normalized}" ]] && echo "${normalized}" | jq -e 'type == "object"' >/dev/null 2>&1; then
            parsed="${normalized}"
          else
            parsed="$(jq -n --arg c "${content}" '{risk:"MEDIUM",approve:false,findings:["Could not parse JSON object from model output"],recommendation:"Manual review required",rationale:($c|tostring)}')"
          fi

          result="$(jq -n \
            --arg name "${AGENT_NAME}" \
            --arg provider "${PROVIDER}" \
            --arg api_url "${API_URL}" \
            --arg model "${chosen_model}" \
            --arg agent_role "${AGENT_ROLE}" \
            --argjson payload "${parsed}" \
            --arg http_code "${http_code}" \
            --arg skipped "${skipped_flag}" \
            '{
              name:$name,
              provider:$provider,
              api_url:$api_url,
              model:$model,
              agent_role:$agent_role,
              http_code:$http_code,
              skipped:($skipped == "true"),
              risk:(($payload.risk // "MEDIUM")|ascii_upcase),
              approve:($payload.approve // false),
              findings:(if ($payload.findings|type)=="array" then $payload.findings else [($payload.findings|tostring)] end),
              recommendation:($payload.recommendation // "No recommendation"),
              rationale:($payload.rationale // "No rationale")
            }')"

          echo "${result}" > "agent-${AGENT_NAME}.json"

      - name: Upload JSON artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-result-${{ matrix.name }}
          path: agent-${{ matrix.name }}.json
          if-no-files-found: error

  integrate:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, resolve-orchestrator, run-agents]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      high_risk: ${{ steps.integrate.outputs.high_risk }}
      approve_count: ${{ steps.integrate.outputs.approve_count }}
      total_count: ${{ steps.integrate.outputs.total_count }}
      threshold: ${{ steps.integrate.outputs.threshold }}
      vote_passed: ${{ steps.integrate.outputs.vote_passed }}
      ok_to_execute: ${{ steps.integrate.outputs.ok_to_execute }}

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: agent-result-*
          path: agent-results
          merge-multiple: true

      - name: Integrate results with jq rules
        id: integrate
        run: |
          set -euo pipefail

          jq -s '.' agent-results/*.json > all-results.json

          total_count="$(jq '[.[] | select(.skipped != true)] | length' all-results.json)"
          approve_count="$(jq '[.[] | select(.skipped != true and .approve == true)] | length' all-results.json)"
          reject_count="$(jq '[.[] | select(.skipped != true and .approve != true)] | length' all-results.json)"
          high_risk_count="$(jq '[.[] | select(.skipped != true and (.risk|ascii_upcase) == "HIGH")] | length' all-results.json)"
          high_risk="false"
          if [[ "${high_risk_count}" -gt 0 ]]; then
            high_risk="true"
          fi

          if [[ "${total_count}" -eq 0 ]]; then
            threshold=1
          else
            threshold=$(( (total_count * 2 + 2) / 3 )) # ceil(2/3 * total)
          fi
          vote_passed="false"
          if [[ "${approve_count}" -ge "${threshold}" ]]; then
            vote_passed="true"
          fi
          ok_to_execute="false"
          if [[ "${vote_passed}" == "true" && "${high_risk}" != "true" ]]; then
            ok_to_execute="true"
          fi

          jq '
            {
              adopted_security_criticism: [
                .[] | select(.skipped != true and (.agent_role|test("security";"i")) and ((.findings|length) > 0)) |
                {agent: .name, findings: .findings, recommendation: .recommendation}
              ],
              high_confidence: {
                approve_agreement: (([.[] | select(.skipped != true and .approve == true)] | length) >= 3),
                reject_agreement: (([.[] | select(.skipped != true and .approve != true)] | length) >= 3)
              },
              considerations: (
                [ .[] | select(.skipped != true) | .findings[] ] | group_by(.) | map(select(length == 1) | .[0])
              ),
              contradictions: (
                ([.[] | select(.skipped != true and .approve == true)] | length) > 0 and
                ([.[] | select(.skipped != true and .approve != true)] | length) > 0
              ),
              by_agent: [ .[] | select(.skipped != true) | {name, provider, agent_role, risk, approve, findings, recommendation, rationale} ]
            }
          ' all-results.json > integrated.json

          {
            echo "high_risk=${high_risk}"
            echo "approve_count=${approve_count}"
            echo "total_count=${total_count}"
            echo "threshold=${threshold}"
            echo "vote_passed=${vote_passed}"
            echo "ok_to_execute=${ok_to_execute}"
          } >> "${GITHUB_OUTPUT}"

          approve_agents="$(jq -r '[.[] | select(.skipped != true and .approve == true) | .name] | join(", ")' all-results.json)"
          reject_agents="$(jq -r '[.[] | select(.skipped != true and .approve != true) | .name] | join(", ")' all-results.json)"
          security_block="$(jq -r '
            [.adopted_security_criticism[]? |
              "- **\(.agent)**\n  - findings: \(.findings | join(" | "))\n  - recommendation: \(.recommendation)"
            ] | if length==0 then "- none" else join("\n") end
          ' integrated.json)"
          one_agent_points="$(jq -r '
            .considerations | if length==0 then "- none" else map("- " + .) | join("\n") end
          ' integrated.json)"
          contradiction_flag="$(jq -r '.contradictions' integrated.json)"
          contradiction_section="- none"
          if [[ "${contradiction_flag}" == "true" ]]; then
            contradiction_section="Approve side: ${approve_agents}
          Reject side: ${reject_agents}"
          fi

          cat > integrated-comment.md <<COMMENT_EOF
          ## Tutti Integrated Review

          - orchestrator profile: ${{ needs.resolve-orchestrator.outputs.provider }}
          - lanes configured: ${{ needs.resolve-orchestrator.outputs.expected_lanes }}

          **Rule a: Security criticism (unconditionally adopted)**
          ${security_block}

          **Rule b: 3+ agents agree (high confidence)**
          - approve agreement (>=3): $(jq -r '.high_confidence.approve_agreement' integrated.json)
          - reject agreement (>=3): $(jq -r '.high_confidence.reject_agreement' integrated.json)

          **Rule c: Single-agent points (consideration)**
          ${one_agent_points}

          **Rule d: Contradictions (present both sides)**
          ${contradiction_section}

          **Consensus summary**
          - approvals: ${approve_count}/${total_count}
          - high-risk findings: ${high_risk_count}
          - approving agents: ${approve_agents}
          - non-approving agents: ${reject_agents}
          COMMENT_EOF

      - name: Post integrated comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue comment "${{ needs.prepare.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --body-file integrated-comment.md

  finalize:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, integrate]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Apply Tier 2 decision and labels
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
          HAS_CODEX_IMPLEMENT: ${{ needs.prepare.outputs.has_codex_implement }}
          HIGH_RISK: ${{ needs.integrate.outputs.high_risk }}
          APPROVE_COUNT: ${{ needs.integrate.outputs.approve_count }}
          TOTAL_COUNT: ${{ needs.integrate.outputs.total_count }}
          THRESHOLD: ${{ needs.integrate.outputs.threshold }}
        run: |
          set -euo pipefail

          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" --remove-label "needs-human" || true

          if [[ "${HIGH_RISK}" == "true" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tier 2 consensus: HIGH risk detected. Escalated to human review."
            exit 0
          fi

          if [[ "${APPROVE_COUNT}" -ge "${THRESHOLD}" ]]; then
            if [[ "${HAS_CODEX_IMPLEMENT}" == "true" ]]; then
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti vote: ${APPROVE_COUNT}/${TOTAL_COUNT} approval (>=2/3). Approved to execute; implementation may proceed."
            else
              gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti vote: ${APPROVE_COUNT}/${TOTAL_COUNT} approval (>=2/3). Auto-execution approved."
              gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
            fi
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti vote: ${APPROVE_COUNT}/${TOTAL_COUNT} approval (<2/3). Marked for review."
          fi

  resolve-orchestrator:
    if: ${{ github.actor != 'github-actions[bot]' && needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      provider: ${{ steps.resolve.outputs.provider }}
      expected_lanes: ${{ steps.resolve.outputs.expected_lanes }}
      agent_matrix: ${{ steps.resolve.outputs.agent_matrix }}
    steps:
      - name: Resolve orchestrator profile and lane matrix
        id: resolve
        env:
          REQUESTED_PROVIDER: ${{ inputs.orchestrator_provider }}
        run: |
          set -euo pipefail

          provider="$(echo "${REQUESTED_PROVIDER:-codex}" | tr '[:upper:]' '[:lower:]')"
          if [[ "${provider}" != "claude" && "${provider}" != "codex" ]]; then
            provider="codex"
          fi

          if [[ "${provider}" == "codex" ]]; then
            matrix="$(jq -cn '{
              include: [
                {name:"codex-security-analyst",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex",agent_role:"security-analyst"},
                {name:"codex-code-reviewer",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex",agent_role:"code-reviewer"},
                {name:"codex-general-reviewer",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex-spark",agent_role:"general-reviewer"},
                {name:"glm-code-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5",agent_role:"code-reviewer"},
                {name:"glm-general-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5",agent_role:"general-reviewer"},
                {name:"glm-math-reasoning",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5",agent_role:"math-reasoning"}
              ]
            }')"
          else
            matrix="$(jq -cn '{
              include: [
                {name:"codex-security-analyst",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex",agent_role:"security-analyst"},
                {name:"glm-code-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5",agent_role:"code-reviewer"},
                {name:"glm-general-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5",agent_role:"general-reviewer"},
                {name:"gemini-general-reviewer",provider:"gemini",api_url:"https://generativelanguage.googleapis.com/v1beta/models",model:"gemini-2.0-flash",agent_role:"general-reviewer"}
              ]
            }')"
          fi

          lanes="$(echo "${matrix}" | jq -r '.include | length')"

          {
            echo "provider=${provider}"
            echo "expected_lanes=${lanes}"
            echo "agent_matrix=${matrix}"
          } >> "${GITHUB_OUTPUT}"

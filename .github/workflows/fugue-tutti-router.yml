name: fugue-tutti-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
      orchestrator_provider:
        description: "Legacy main orchestrator profile input (claude|codex)"
        required: false
        type: string
        default: ""
      main_orchestrator_provider:
        description: "Main orchestrator profile (codex|claude)"
        required: false
        type: string
        default: ""
      assist_orchestrator_provider:
        description: "Assist orchestrator profile (claude|codex|none)"
        required: false
        type: string
        default: ""
      force_claude:
        description: "Force claude profile even when claude rate-limit state is degraded/exhausted"
        required: false
        type: string
        default: "false"
      multi_agent_mode_override:
        description: "Override multi-agent mode (standard|enhanced|max)"
        required: false
        type: string
        default: ""
      multi_agent_mode_lock:
        description: "When true, ignore issue-body multi-agent mode overrides"
        required: false
        type: string
        default: "false"
    outputs:
      ok_to_execute:
        description: "true when approvals >= 2/3 and no HIGH risk was detected"
        value: ${{ jobs.integrate.outputs.ok_to_execute }}
      vote_passed:
        description: "true when approvals >= 2/3"
        value: ${{ jobs.integrate.outputs.vote_passed }}
      threshold:
        description: "ceil(2/3 * total_count)"
        value: ${{ jobs.integrate.outputs.threshold }}
      high_risk:
        description: "true when any agent reports HIGH risk"
        value: ${{ jobs.integrate.outputs.high_risk }}
      approve_count:
        description: "number of approvals"
        value: ${{ jobs.integrate.outputs.approve_count }}
      total_count:
        description: "number of total agent results"
        value: ${{ jobs.integrate.outputs.total_count }}
      weighted_approve_score:
        description: "weighted approval score"
        value: ${{ jobs.integrate.outputs.weighted_approve_score }}
      weighted_total_score:
        description: "weighted total score"
        value: ${{ jobs.integrate.outputs.weighted_total_score }}
      weighted_threshold:
        description: "weighted threshold score"
        value: ${{ jobs.integrate.outputs.weighted_threshold }}
      weighted_vote_passed:
        description: "true when weighted approvals meet threshold"
        value: ${{ jobs.integrate.outputs.weighted_vote_passed }}
      expected_lanes:
        description: "configured lane count for this run"
        value: ${{ jobs.resolve-orchestrator.outputs.expected_lanes }}
      resolved_multi_agent_mode:
        description: "resolved multi-agent mode after policy/override resolution"
        value: ${{ jobs.resolve-orchestrator.outputs.multi_agent_mode }}
      resolved_multi_agent_mode_source:
        description: "where the resolved multi-agent mode came from"
        value: ${{ jobs.resolve-orchestrator.outputs.multi_agent_mode_source }}
    secrets:
      OPENAI_API_KEY:
        required: true
      ZAI_API_KEY:
        required: true
      GEMINI_API_KEY:
        required: false
      XAI_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false

permissions:
  issues: write
  contents: read
  actions: read

concurrency:
  group: fugue-tutti-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_run: ${{ steps.ctx.outputs.should_run }}
      skip_reason: ${{ steps.ctx.outputs.skip_reason }}
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_title: ${{ steps.ctx.outputs.issue_title }}
      issue_body: ${{ steps.ctx.outputs.issue_body }}
      author: ${{ steps.ctx.outputs.author }}
      has_implement_request: ${{ steps.ctx.outputs.has_implement_request }}
      trusted: ${{ steps.trust.outputs.trusted }}
      permission: ${{ steps.trust.outputs.permission }}

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ inputs.issue_number }}"
          if [[ -n "${ISSUE_NUMBER}" ]]; then
            issue_json="$(gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}")"
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_IMPLEMENT_REQUEST="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | (index("implement") != null) or (index("codex-implement") != null) or (index("claude-implement") != null)')"

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" || "${HAS_TUTTI}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-required-labels"
          elif [[ "${HAS_PROCESSING}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "has_implement_request=${HAS_IMPLEMENT_REQUEST}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          AUTHOR="${{ steps.ctx.outputs.author }}"
          PERM="none"

          perm_json="$(gh api "repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission" 2>/dev/null || echo '{}')"
          if echo "${perm_json}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${perm_json}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --remove-label "completed" \
            --remove-label "needs-review" \
            --remove-label "needs-human" \
            --remove-label "vote-approved" \
            --remove-label "vote-rejected" || true
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --add-label "processing"

      - name: Mark untrusted as needs-human
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE="${{ steps.ctx.outputs.issue_number }}"
          gh issue comment "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --body "Author trust check failed (permission: ${{ steps.trust.outputs.permission }}). Hand-off to humans required."
          gh issue edit "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human" --remove-label "processing" || true

  run-agents:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, resolve-orchestrator]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.resolve-orchestrator.outputs.agent_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Call agent engine
        id: call
        env:
          ISSUE_TITLE: ${{ needs.prepare.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.prepare.outputs.issue_body }}
          ORCHESTRATOR_PROVIDER: ${{ needs.resolve-orchestrator.outputs.main_provider }}
          ASSIST_ORCHESTRATOR_PROVIDER: ${{ needs.resolve-orchestrator.outputs.assist_provider }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
          CI_EXECUTION_ENGINE: ${{ vars.FUGUE_CI_EXECUTION_ENGINE || 'harness' }}
          API_URL: ${{ matrix.api_url }}
          PROVIDER: ${{ matrix.provider }}
          MODEL: ${{ matrix.model }}
          AGENT_ROLE: ${{ matrix.agent_role }}
          AGENT_NAME: ${{ matrix.name }}
        run: |
          set -euo pipefail

          ci_execution_engine="$(echo "${CI_EXECUTION_ENGINE:-harness}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ci_execution_engine}" != "harness" && "${ci_execution_engine}" != "api" ]]; then
            ci_execution_engine="harness"
          fi
          if [[ "${ci_execution_engine}" == "harness" ]]; then
            if [[ ! -x "scripts/harness/ci-agent-runner.sh" ]]; then
              echo "harness execution engine is enabled, but scripts/harness/ci-agent-runner.sh is missing or not executable." >&2
              exit 1
            fi
            bash scripts/harness/ci-agent-runner.sh
            exit 0
          fi

          sys_prompt="You are ${AGENT_ROLE}. Analyze the GitHub issue and return ONLY valid JSON with keys: risk (LOW|MEDIUM|HIGH), approve (boolean), findings (array of strings), recommendation (string), rationale (string)."
          user_prompt="Issue Title: ${ISSUE_TITLE}

          Issue Body:
          ${ISSUE_BODY}"

          ORIGINAL_PROVIDER="${PROVIDER}"
          ORIGINAL_MODEL="${MODEL}"
          CLAUDE_PROXY_MODE="false"
          CLAUDE_PROXY_NOTE=""
          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi

          # Gemini can run without being OpenAI-compatible; if key is missing, skip it.
          if [[ "${PROVIDER}" == "gemini" && -z "${GEMINI_API_KEY:-}" ]]; then
            result="$(jq -n \
              --arg name "${AGENT_NAME}" \
              --arg provider "${PROVIDER}" \
              --arg api_url "${API_URL}" \
              --arg model "${MODEL}" \
              --arg agent_role "${AGENT_ROLE}" \
              '{
                name:$name,
                provider:$provider,
                api_url:$api_url,
                model:$model,
                agent_role:$agent_role,
                http_code:"skipped",
                skipped:true,
                risk:"MEDIUM",
                approve:false,
                findings:["Skipped: missing GEMINI_API_KEY"],
                recommendation:"Add GEMINI_API_KEY to enable Gemini voter",
                rationale:"Gemini voter was skipped due to missing secret"
              }')"
            echo "${result}" > "agent-${AGENT_NAME}.json"
            exit 0
          fi

          if [[ "${PROVIDER}" == "xai" && -z "${XAI_API_KEY:-}" ]]; then
            result="$(jq -n \
              --arg name "${AGENT_NAME}" \
              --arg provider "${PROVIDER}" \
              --arg api_url "${API_URL}" \
              --arg model "${MODEL}" \
              --arg agent_role "${AGENT_ROLE}" \
              '{
                name:$name,
                provider:$provider,
                api_url:$api_url,
                model:$model,
                agent_role:$agent_role,
                http_code:"skipped",
                skipped:true,
                risk:"MEDIUM",
                approve:false,
                findings:["Skipped: missing XAI_API_KEY"],
                recommendation:"Add XAI_API_KEY to enable xAI voter",
                rationale:"xAI voter was skipped due to missing secret"
              }')"
            echo "${result}" > "agent-${AGENT_NAME}.json"
            exit 0
          fi

          if [[ "${PROVIDER}" == "claude" && -z "${ANTHROPIC_API_KEY:-}" ]]; then
            if [[ "${claude_max_plan}" == "true" && -n "${OPENAI_API_KEY:-}" ]]; then
              PROVIDER="codex"
              API_URL="https://api.openai.com/v1/chat/completions"
              MODEL="gpt-5.3-codex-spark"
              CLAUDE_PROXY_MODE="true"
              CLAUDE_PROXY_NOTE="Claude MAX plan mode: executed via Codex proxy because ANTHROPIC_API_KEY is not configured."
            else
              result="$(jq -n \
                --arg name "${AGENT_NAME}" \
                --arg provider "${PROVIDER}" \
                --arg api_url "${API_URL}" \
                --arg model "${MODEL}" \
                --arg agent_role "${AGENT_ROLE}" \
                '{
                  name:$name,
                  provider:$provider,
                  api_url:$api_url,
                  model:$model,
                  agent_role:$agent_role,
                  http_code:"skipped",
                  skipped:true,
                  risk:"MEDIUM",
                  approve:false,
                  findings:["Skipped: missing ANTHROPIC_API_KEY and Claude MAX proxy mode is disabled"],
                  recommendation:"Set FUGUE_CLAUDE_MAX_PLAN=true or provide ANTHROPIC_API_KEY to enable Claude lanes",
                  rationale:"Claude lane was skipped due to missing credential path"
                }')"
              echo "${result}" > "agent-${AGENT_NAME}.json"
              exit 0
            fi
          fi

          req=""
          auth_header=""
          if [[ "${PROVIDER}" == "codex" || "${PROVIDER}" == "glm" || "${PROVIDER}" == "xai" ]]; then
            req="$(jq -n \
              --arg model "${MODEL}" \
              --arg s "${sys_prompt}" \
              --arg u "${user_prompt}" \
              '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
            if [[ "${PROVIDER}" == "codex" ]]; then
              auth_header="Authorization: Bearer ${OPENAI_API_KEY}"
            elif [[ "${PROVIDER}" == "glm" ]]; then
              auth_header="Authorization: Bearer ${ZAI_API_KEY}"
            else
              auth_header="Authorization: Bearer ${XAI_API_KEY}"
            fi
          elif [[ "${PROVIDER}" == "claude" ]]; then
            req="$(jq -n \
              --arg model "${MODEL}" \
              --arg s "${sys_prompt}" \
              --arg u "${user_prompt}" \
              '{model:$model,system:$s,messages:[{role:"user",content:$u}],max_tokens:1200,temperature:0.1}')"
          else
            # Gemini generateContent expects a single "user" content string. Keep it strict: JSON only.
            req="$(jq -n \
              --arg text "SYSTEM:\n${sys_prompt}\n\nUSER:\n${user_prompt}\n\nReturn ONLY JSON." \
              '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.1}}')"
          fi

          chosen_model="${MODEL}"
          effective_provider="${PROVIDER}"
          effective_api_url="${API_URL}"
          http_code=""
          content=""

          if [[ "${PROVIDER}" == "codex" ]]; then
            # Prefer Codex models first, then generic OpenAI fallbacks for compatibility.
            candidates=("${MODEL}" "gpt-5.3-codex" "gpt-5.2-codex" "gpt-5.1-codex" "gpt-4.1" "gpt-4o-mini")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done

            # If Codex lane is unavailable, fail over to GLM-5.0 so consensus can continue.
            if [[ "${http_code}" != "200" && -n "${ZAI_API_KEY:-}" ]]; then
              effective_provider="glm"
              effective_api_url="https://api.z.ai/api/coding/paas/v4/chat/completions"
              chosen_model="glm-5.0"
              fallback_req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
              http_code="$(curl -sS -o response.json -w "%{http_code}" "${effective_api_url}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "Authorization: Bearer ${ZAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${fallback_req}" || true)"
            fi
          elif [[ "${PROVIDER}" == "xai" ]]; then
            candidates=("${MODEL}" "grok-3-mini" "grok-2-latest")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done
          elif [[ "${PROVIDER}" == "claude" ]]; then
            candidates=("${MODEL}" "claude-opus-4-1-20250805" "claude-opus-4-20250514" "claude-3-7-sonnet-latest" "claude-3-5-sonnet-latest")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,system:$s,messages:[{role:"user",content:$u}],max_tokens:1200,temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "x-api-key: ${ANTHROPIC_API_KEY}" \
                -H "anthropic-version: 2023-06-01" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done
          else
            if [[ "${PROVIDER}" == "glm" ]]; then
              candidates=("${MODEL}" "glm-5.0" "glm-4.5")
              for m in "${candidates[@]}"; do
                chosen_model="${m}"
                req="$(jq -n \
                  --arg model "${chosen_model}" \
                  --arg s "${sys_prompt}" \
                  --arg u "${user_prompt}" \
                  '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

                http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "${auth_header}" \
                  -H "Content-Type: application/json" \
                  -d "${req}" || true)"
                if [[ "${http_code}" == "200" ]]; then
                  break
                fi
              done

              # Keep 6-lane quorum robust when GLM endpoint/model is temporarily unavailable.
              if [[ "${http_code}" != "200" && -n "${OPENAI_API_KEY:-}" ]]; then
                effective_provider="codex"
                effective_api_url="https://api.openai.com/v1/chat/completions"
                chosen_model="gpt-5.3-codex-spark"
                fallback_req="$(jq -n \
                  --arg model "${chosen_model}" \
                  --arg s "${sys_prompt}" \
                  --arg u "${user_prompt}" \
                  '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
                http_code="$(curl -sS -o response.json -w "%{http_code}" "${effective_api_url}" \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d "${fallback_req}" || true)"
              fi
            else
              # Gemini REST API (key in query param)
              gemini_url="${API_URL}/${MODEL}:generateContent?key=${GEMINI_API_KEY}"
              http_code="$(curl -sS -o response.json -w "%{http_code}" "${gemini_url}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
            fi
          fi

          if [[ "${PROVIDER}" == "gemini" ]]; then
            content="$(jq -r '.candidates[0].content.parts[0].text // ""' response.json 2>/dev/null || echo "")"
          elif [[ "${PROVIDER}" == "claude" ]]; then
            content="$(jq -r '[.content[]? | select(.type=="text") | .text] | join("\n") // ""' response.json 2>/dev/null || echo "")"
          else
            content="$(jq -r '.choices[0].message.content // ""' response.json 2>/dev/null || echo "")"
          fi

          skipped_flag="false"
          # Optional specialist lanes are excluded from consensus totals when they fail.
          if [[ ( "${PROVIDER}" == "gemini" || "${PROVIDER}" == "xai" || "${PROVIDER}" == "claude" ) && "${http_code}" != "200" ]]; then
            skipped_flag="true"
          fi

          optional_error_note=""
          optional_provider_label=""
          if [[ "${PROVIDER}" == "gemini" && "${http_code}" != "200" ]]; then
            optional_provider_label="Gemini"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="Gemini API rate limited (HTTP 429)"
            else
              optional_error_note="Gemini API error (HTTP ${http_code})"
            fi
          elif [[ "${PROVIDER}" == "xai" && "${http_code}" != "200" ]]; then
            optional_provider_label="xAI"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="xAI API rate limited (HTTP 429)"
            else
              optional_error_note="xAI API error (HTTP ${http_code})"
            fi
          elif [[ "${PROVIDER}" == "claude" && "${http_code}" != "200" ]]; then
            optional_provider_label="Claude"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="Claude API rate limited (HTTP 429)"
            else
              optional_error_note="Claude API error (HTTP ${http_code})"
            fi
          fi

          # Extract JSON even if wrapped in ```json fences.
          extracted="$(jq -Rn --arg s "${content}" '
            ($s | gsub("\r"; "") | gsub("^\\s+|\\s+$"; "")) as $t |
            if ($t | test("```json"; "i")) then
              (($t | split("```json") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            elif ($t | test("```"; "i")) then
              (($t | split("```") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            else
              $t
            end
          ')"

          normalized="$(echo "${extracted}" | jq -c '
            if type == "string" then (fromjson? // .) else . end
          ' 2>/dev/null || true)"

          if [[ -n "${optional_error_note}" ]]; then
            parsed="$(jq -n \
              --arg note "${optional_error_note}" \
              --arg provider "${optional_provider_label}" \
              '{
                risk:"MEDIUM",
                approve:false,
                findings:[$note],
                recommendation:("Retry later or reduce " + $provider + " specialist lane pressure"),
                rationale:"Optional specialist lane skipped due to provider-side throttling/error"
              }')"
          elif [[ -n "${normalized}" ]] && echo "${normalized}" | jq -e 'type == "object"' >/dev/null 2>&1; then
            parsed="${normalized}"
          else
            parsed="$(jq -n --arg c "${content}" '{risk:"MEDIUM",approve:false,findings:["Could not parse JSON object from model output"],recommendation:"Manual review required",rationale:($c|tostring)}')"
          fi

          if [[ "${CLAUDE_PROXY_MODE}" == "true" ]]; then
            parsed="$(echo "${parsed}" | jq -c \
              --arg note "${CLAUDE_PROXY_NOTE}" \
              '{
                risk:(.risk // "MEDIUM"),
                approve:(.approve // false),
                findings:(
                  (if (.findings|type)=="array" then .findings else [(.findings|tostring)] end) + [$note]
                ),
                recommendation:(.recommendation // "No recommendation"),
                rationale:(
                  (.rationale // "No rationale") + " | " + $note
                )
              }')"
          fi

          reported_provider="${effective_provider}"
          if [[ "${CLAUDE_PROXY_MODE}" == "true" ]]; then
            reported_provider="claude-max-proxy-codex"
          fi

          result="$(jq -n \
            --arg name "${AGENT_NAME}" \
            --arg provider "${reported_provider}" \
            --arg api_url "${effective_api_url}" \
            --arg model "${chosen_model}" \
            --arg agent_role "${AGENT_ROLE}" \
            --argjson payload "${parsed}" \
            --arg http_code "${http_code}" \
            --arg skipped "${skipped_flag}" \
            '{
              name:$name,
              provider:$provider,
              api_url:$api_url,
              model:$model,
              agent_role:$agent_role,
              http_code:$http_code,
              skipped:($skipped == "true"),
              risk:(($payload.risk // "MEDIUM")|ascii_upcase),
              approve:($payload.approve // false),
              findings:(if ($payload.findings|type)=="array" then $payload.findings else [($payload.findings|tostring)] end),
              recommendation:($payload.recommendation // "No recommendation"),
              rationale:($payload.rationale // "No rationale"),
              execution_engine:"api"
            }')"

          echo "${result}" > "agent-${AGENT_NAME}.json"

      - name: Upload JSON artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-result-${{ matrix.name }}
          path: agent-${{ matrix.name }}.json
          if-no-files-found: error

  integrate:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, resolve-orchestrator, run-agents]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      high_risk: ${{ steps.integrate.outputs.high_risk }}
      approve_count: ${{ steps.integrate.outputs.approve_count }}
      total_count: ${{ steps.integrate.outputs.total_count }}
      threshold: ${{ steps.integrate.outputs.threshold }}
      weighted_approve_score: ${{ steps.integrate.outputs.weighted_approve_score }}
      weighted_total_score: ${{ steps.integrate.outputs.weighted_total_score }}
      weighted_threshold: ${{ steps.integrate.outputs.weighted_threshold }}
      weighted_vote_passed: ${{ steps.integrate.outputs.weighted_vote_passed }}
      vote_passed: ${{ steps.integrate.outputs.vote_passed }}
      ok_to_execute: ${{ steps.integrate.outputs.ok_to_execute }}

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: agent-result-*
          path: agent-results
          merge-multiple: true

      - name: Integrate results with jq rules
        id: integrate
        run: |
          set -euo pipefail

          jq -s '.' agent-results/*.json > all-results.json

          total_count="$(jq '[.[] | select(.skipped != true)] | length' all-results.json)"
          approve_count="$(jq '[.[] | select(.skipped != true and .approve == true)] | length' all-results.json)"
          reject_count="$(jq '[.[] | select(.skipped != true and .approve != true)] | length' all-results.json)"
          high_risk_count="$(jq '[.[] | select(.skipped != true and (.risk|ascii_upcase) == "HIGH")] | length' all-results.json)"
          high_risk="false"
          if [[ "${high_risk_count}" -gt 0 ]]; then
            high_risk="true"
          fi

          if [[ "${total_count}" -eq 0 ]]; then
            threshold=1
          else
            threshold=$(( (total_count * 2 + 2) / 3 )) # ceil(2/3 * total)
          fi
          vote_passed="false"
          if [[ "${approve_count}" -ge "${threshold}" ]]; then
            vote_passed="true"
          fi
          weighted_total_score="$(jq -r '
            [ .[] | select(.skipped != true) |
              (if (.agent_role|test("security-analyst";"i")) then 1.4
               elif (.agent_role|test("code-reviewer";"i")) then 1.2
               elif (.agent_role|test("architect";"i")) then 1.1
               elif (.agent_role|test("reliability-engineer|invariants-checker";"i")) then 1.1
               elif (.agent_role|test("general-reviewer|plan-reviewer|general-critic";"i")) then 1.0
               elif (.agent_role|test("refactor-advisor";"i")) then 0.9
               elif (.agent_role|test("math-reasoning|orchestration-assistant|main-orchestrator|ui-reviewer";"i")) then 0.8
               elif (.agent_role|test("realtime-info";"i")) then 0.7
               else 1.0 end)
            ] | add // 0
          ' all-results.json)"
          weighted_approve_score="$(jq -r '
            [ .[] | select(.skipped != true and .approve == true) |
              (if (.agent_role|test("security-analyst";"i")) then 1.4
               elif (.agent_role|test("code-reviewer";"i")) then 1.2
               elif (.agent_role|test("architect";"i")) then 1.1
               elif (.agent_role|test("reliability-engineer|invariants-checker";"i")) then 1.1
               elif (.agent_role|test("general-reviewer|plan-reviewer|general-critic";"i")) then 1.0
               elif (.agent_role|test("refactor-advisor";"i")) then 0.9
               elif (.agent_role|test("math-reasoning|orchestration-assistant|main-orchestrator|ui-reviewer";"i")) then 0.8
               elif (.agent_role|test("realtime-info";"i")) then 0.7
               else 1.0 end)
            ] | add // 0
          ' all-results.json)"
          weighted_threshold="$(awk -v total="${weighted_total_score}" 'BEGIN {printf "%.3f", (2*total)/3}')"
          weighted_vote_passed="$(awk -v approve="${weighted_approve_score}" -v threshold="${weighted_threshold}" 'BEGIN { if (approve + 1e-9 >= threshold) print "true"; else print "false" }')"
          ok_to_execute="false"
          if [[ "${weighted_vote_passed}" == "true" && "${high_risk}" != "true" ]]; then
            ok_to_execute="true"
          fi

          jq '
            {
              adopted_security_criticism: [
                .[] | select(.skipped != true and (.agent_role|test("security";"i")) and ((.findings|length) > 0)) |
                {agent: .name, findings: .findings, recommendation: .recommendation}
              ],
              high_confidence: {
                approve_agreement: (([.[] | select(.skipped != true and .approve == true)] | length) >= 3),
                reject_agreement: (([.[] | select(.skipped != true and .approve != true)] | length) >= 3)
              },
              considerations: (
                [ .[] | select(.skipped != true) | .findings[] ] | group_by(.) | map(select(length == 1) | .[0])
              ),
              contradictions: (
                ([.[] | select(.skipped != true and .approve == true)] | length) > 0 and
                ([.[] | select(.skipped != true and .approve != true)] | length) > 0
              ),
              by_agent: [ .[] | select(.skipped != true) | {name, provider, execution_engine, agent_role, risk, approve, findings, recommendation, rationale} ]
            }
          ' all-results.json > integrated.json

          {
            echo "high_risk=${high_risk}"
            echo "approve_count=${approve_count}"
            echo "total_count=${total_count}"
            echo "threshold=${threshold}"
            echo "weighted_approve_score=${weighted_approve_score}"
            echo "weighted_total_score=${weighted_total_score}"
            echo "weighted_threshold=${weighted_threshold}"
            echo "weighted_vote_passed=${weighted_vote_passed}"
            echo "vote_passed=${weighted_vote_passed}"
            echo "ok_to_execute=${ok_to_execute}"
          } >> "${GITHUB_OUTPUT}"

          approve_agents="$(jq -r '[.[] | select(.skipped != true and .approve == true) | .name] | join(", ")' all-results.json)"
          reject_agents="$(jq -r '[.[] | select(.skipped != true and .approve != true) | .name] | join(", ")' all-results.json)"
          security_block="$(jq -r '
            [.adopted_security_criticism[]? |
              "- **\(.agent)**\n  - findings: \(.findings | join(" | "))\n  - recommendation: \(.recommendation)"
            ] | if length==0 then "- none" else join("\n") end
          ' integrated.json)"
          one_agent_points="$(jq -r '
            .considerations | if length==0 then "- none" else map("- " + .) | join("\n") end
          ' integrated.json)"
          contradiction_flag="$(jq -r '.contradictions' integrated.json)"
          contradiction_section="- none"
          if [[ "${contradiction_flag}" == "true" ]]; then
            contradiction_section="Approve side: ${approve_agents}
          Reject side: ${reject_agents}"
          fi
          skipped_agents="$(jq -r '
            [ .[] | select(.skipped == true) |
              "- \(.name) [\(.provider)/\(.execution_engine // "api")] (http=\(.http_code)): \((.findings | join(" | ")))"
            ] | if length==0 then "- none" else join("\n") end
          ' all-results.json)"
          main_fallback_section="- main fallback: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.main_claude_fallback_applied }}" == "true" ]]; then
            main_fallback_section="- main fallback: claude -> codex (\`${{ needs.resolve-orchestrator.outputs.main_claude_fallback_reason }}\`)"
          fi
          assist_fallback_section="- assist fallback: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.assist_claude_fallback_applied }}" == "true" ]]; then
            assist_fallback_section="- assist fallback: claude -> none (\`${{ needs.resolve-orchestrator.outputs.assist_claude_fallback_reason }}\`)"
          fi
          claude_pressure_section="- claude pressure guard: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.claude_pressure_guard_applied }}" == "true" ]]; then
            claude_pressure_section="- claude pressure guard: applied (\`${{ needs.resolve-orchestrator.outputs.claude_pressure_guard_reason }}\`)"
          fi

          cat > integrated-comment.md <<COMMENT_EOF
          ## Tutti Integrated Review

          - main orchestrator requested: ${{ needs.resolve-orchestrator.outputs.main_provider_requested }}
          - main orchestrator resolved: ${{ needs.resolve-orchestrator.outputs.main_provider }}
          - main orchestrator signal lane: ${{ needs.resolve-orchestrator.outputs.main_signal_lane }}
          - assist orchestrator requested: ${{ needs.resolve-orchestrator.outputs.assist_provider_requested }}
          - assist orchestrator resolved: ${{ needs.resolve-orchestrator.outputs.assist_provider }}
          - multi-agent mode: ${{ needs.resolve-orchestrator.outputs.multi_agent_mode }}
          - multi-agent mode source: ${{ needs.resolve-orchestrator.outputs.multi_agent_mode_source }}
          ${main_fallback_section}
          ${assist_fallback_section}
          ${claude_pressure_section}
          - lanes configured: ${{ needs.resolve-orchestrator.outputs.expected_lanes }}

          **Rule a: Security criticism (unconditionally adopted)**
          ${security_block}

          **Rule b: 3+ agents agree (high confidence)**
          - approve agreement (>=3): $(jq -r '.high_confidence.approve_agreement' integrated.json)
          - reject agreement (>=3): $(jq -r '.high_confidence.reject_agreement' integrated.json)

          **Rule c: Single-agent points (consideration)**
          ${one_agent_points}

          **Rule d: Contradictions (present both sides)**
          ${contradiction_section}

          **Optional lanes skipped**
          ${skipped_agents}

          **Consensus summary**
          - approvals: ${approve_count}/${total_count}
          - weighted approvals: ${weighted_approve_score}/${weighted_total_score} (threshold: ${weighted_threshold})
          - weighted vote passed: ${weighted_vote_passed}
          - high-risk findings: ${high_risk_count}
          - approving agents: ${approve_agents}
          - non-approving agents: ${reject_agents}
          COMMENT_EOF

      - name: Post integrated comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue comment "${{ needs.prepare.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --body-file integrated-comment.md

  finalize:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, integrate]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Apply Tier 2 decision and labels
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
          HAS_IMPLEMENT_REQUEST: ${{ needs.prepare.outputs.has_implement_request }}
          HIGH_RISK: ${{ needs.integrate.outputs.high_risk }}
          APPROVE_COUNT: ${{ needs.integrate.outputs.approve_count }}
          TOTAL_COUNT: ${{ needs.integrate.outputs.total_count }}
          THRESHOLD: ${{ needs.integrate.outputs.threshold }}
          WEIGHTED_APPROVE_SCORE: ${{ needs.integrate.outputs.weighted_approve_score }}
          WEIGHTED_TOTAL_SCORE: ${{ needs.integrate.outputs.weighted_total_score }}
          WEIGHTED_THRESHOLD: ${{ needs.integrate.outputs.weighted_threshold }}
          WEIGHTED_VOTE_PASSED: ${{ needs.integrate.outputs.weighted_vote_passed }}
        run: |
          set -euo pipefail

          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" --remove-label "needs-human" || true

          if [[ "${HIGH_RISK}" == "true" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tier 2 consensus: HIGH risk detected. Escalated to human review."
            exit 0
          fi

          if [[ "${WEIGHTED_VOTE_PASSED}" == "true" ]]; then
            if [[ "${HAS_IMPLEMENT_REQUEST}" == "true" ]]; then
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote passed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}. weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Approved to execute; implementation may proceed."
            else
              gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote passed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}. weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Auto-execution approved."
              gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
            fi
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote failed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}, weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Marked for review."
          fi

  resolve-orchestrator:
    # Allow bot-triggered workflow_dispatch (from task-router handoff) to resolve
    # the matrix; otherwise run-agents/integrate/finalize are skipped.
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      provider: ${{ steps.resolve.outputs.main_provider }}
      provider_requested: ${{ steps.resolve.outputs.main_provider_requested }}
      multi_agent_mode: ${{ steps.resolve.outputs.multi_agent_mode }}
      multi_agent_mode_source: ${{ steps.resolve.outputs.multi_agent_mode_source }}
      claude_fallback_applied: ${{ steps.resolve.outputs.main_claude_fallback_applied }}
      claude_fallback_reason: ${{ steps.resolve.outputs.main_claude_fallback_reason }}
      main_provider: ${{ steps.resolve.outputs.main_provider }}
      main_provider_requested: ${{ steps.resolve.outputs.main_provider_requested }}
      main_claude_fallback_applied: ${{ steps.resolve.outputs.main_claude_fallback_applied }}
      main_claude_fallback_reason: ${{ steps.resolve.outputs.main_claude_fallback_reason }}
      assist_provider: ${{ steps.resolve.outputs.assist_provider }}
      assist_provider_requested: ${{ steps.resolve.outputs.assist_provider_requested }}
      assist_claude_fallback_applied: ${{ steps.resolve.outputs.assist_claude_fallback_applied }}
      assist_claude_fallback_reason: ${{ steps.resolve.outputs.assist_claude_fallback_reason }}
      claude_pressure_guard_applied: ${{ steps.resolve.outputs.claude_pressure_guard_applied }}
      claude_pressure_guard_reason: ${{ steps.resolve.outputs.claude_pressure_guard_reason }}
      main_signal_lane: ${{ steps.resolve.outputs.main_signal_lane }}
      expected_lanes: ${{ steps.resolve.outputs.expected_lanes }}
      agent_matrix: ${{ steps.resolve.outputs.agent_matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Resolve orchestrator profile and lane matrix
        id: resolve
        env:
          REQUESTED_PROVIDER: ${{ inputs.main_orchestrator_provider || inputs.orchestrator_provider }}
          REQUESTED_ASSIST_PROVIDER: ${{ inputs.assist_orchestrator_provider }}
          FORCE_CLAUDE: ${{ inputs.force_claude }}
          MULTI_AGENT_MODE_OVERRIDE: ${{ inputs.multi_agent_mode_override }}
          MULTI_AGENT_MODE_LOCK: ${{ inputs.multi_agent_mode_lock }}
          DEFAULT_MAIN_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_MAIN_ORCHESTRATOR_PROVIDER || vars.FUGUE_ORCHESTRATOR_PROVIDER || 'codex' }}
          DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_ASSIST_ORCHESTRATOR_PROVIDER || 'none' }}
          MULTI_AGENT_MODE: ${{ vars.FUGUE_MULTI_AGENT_MODE || 'enhanced' }}
          CLAUDE_SONNET4_MODEL: ${{ vars.FUGUE_CLAUDE_SONNET4_MODEL || 'claude-3-7-sonnet-latest' }}
          CLAUDE_SONNET6_MODEL: ${{ vars.FUGUE_CLAUDE_SONNET6_MODEL || 'claude-3-5-sonnet-latest' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          CLAUDE_MAIN_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_MAIN_ASSIST_POLICY || 'codex' }}
          CLAUDE_ROLE_POLICY: ${{ vars.FUGUE_CLAUDE_ROLE_POLICY || 'flex' }}
          CLAUDE_DEGRADED_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_DEGRADED_ASSIST_POLICY || 'none' }}
          ISSUE_TITLE: ${{ needs.prepare.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.prepare.outputs.issue_body }}
        run: |
          set -euo pipefail

          force_claude="$(echo "${FORCE_CLAUDE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${force_claude}" != "true" ]]; then
            force_claude="false"
          fi

          eval "$(
            scripts/lib/orchestrator-policy.sh \
              --main "${REQUESTED_PROVIDER}" \
              --assist "${REQUESTED_ASSIST_PROVIDER}" \
              --default-main "${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER}" \
              --default-assist "${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER}" \
              --claude-state "${CLAUDE_RATE_LIMIT_STATE}" \
              --force-claude "${force_claude}" \
              --assist-policy "${CLAUDE_MAIN_ASSIST_POLICY}" \
              --claude-role-policy "${CLAUDE_ROLE_POLICY}" \
              --degraded-assist-policy "${CLAUDE_DEGRADED_ASSIST_POLICY}"
          )"

          main_provider_requested="${requested_main}"
          assist_provider_requested="${requested_assist}"
          main_provider="${resolved_main}"
          assist_provider="${resolved_assist}"
          main_claude_fallback_applied="${main_fallback_applied}"
          main_claude_fallback_reason="${main_fallback_reason}"
          assist_claude_fallback_applied="${assist_fallback_applied}"
          assist_claude_fallback_reason="${assist_fallback_reason}"
          claude_pressure_guard_applied="${pressure_guard_applied}"
          claude_pressure_guard_reason="${pressure_guard_reason}"

          text="$(printf '%s\n%s\n' "${ISSUE_TITLE}" "${ISSUE_BODY}" | tr '[:upper:]' '[:lower:]')"
          multi_agent_mode="$(echo "${MULTI_AGENT_MODE:-enhanced}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          mode_override="$(echo "${MULTI_AGENT_MODE_OVERRIDE:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          mode_lock="$(echo "${MULTI_AGENT_MODE_LOCK:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          multi_agent_mode_source="repo-default"
          if [[ "${mode_lock}" != "true" ]]; then
            mode_lock="false"
          fi
          if [[ "${mode_override}" == "standard" || "${mode_override}" == "enhanced" || "${mode_override}" == "max" ]]; then
            multi_agent_mode="${mode_override}"
            multi_agent_mode_source="input-override"
          fi
          if [[ "${mode_lock}" != "true" ]]; then
            body_multi_agent_mode="$(printf '%s\n' "${ISSUE_BODY}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*multi[[:space:]_-]*agent[[:space:]]+mode[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
            if [[ -z "${body_multi_agent_mode}" ]]; then
              body_multi_agent_mode="$(echo "${ISSUE_BODY}" | sed -nE 's/^[[:space:]]*multi[[:space:]_-]*agent[[:space:]_-]*mode[[:space:]]*:[[:space:]]*(standard|enhanced|max|auto)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
            fi
            if [[ "${body_multi_agent_mode}" == "auto" ]]; then
              body_multi_agent_mode=""
            fi
            if [[ -n "${body_multi_agent_mode}" ]]; then
              multi_agent_mode="${body_multi_agent_mode}"
              multi_agent_mode_source="issue-body"
            fi
          fi
          if [[ "${multi_agent_mode_source}" == "repo-default" ]]; then
            heuristic_mode=""
            if echo "${text}" | grep -Eqi '(大規模|全面|全体|refactor|rewrite|migration|アーキテクチャ|全面刷新|リライト)'; then
              heuristic_mode="max"
            elif echo "${text}" | grep -Eqi '(architecture|security|performance|concurrency|database|schema|workflow|ci|gha|infra|統合|設計|移行)'; then
              heuristic_mode="enhanced"
            fi
            text_len="$(printf '%s' "${text}" | wc -c | tr -d ' ')"
            if [[ -z "${heuristic_mode}" ]]; then
              if (( text_len > 1400 )); then
                heuristic_mode="enhanced"
              elif (( text_len > 0 && text_len < 280 )); then
                heuristic_mode="standard"
              fi
            fi
            if [[ -n "${heuristic_mode}" ]]; then
              multi_agent_mode="${heuristic_mode}"
              multi_agent_mode_source="complexity-heuristic"
            fi
          fi
          if [[ "${multi_agent_mode}" != "standard" && "${multi_agent_mode}" != "enhanced" && "${multi_agent_mode}" != "max" ]]; then
            multi_agent_mode="enhanced"
            multi_agent_mode_source="repo-default"
          fi
          wants_gemini="false"
          wants_xai="false"
          if echo "${text}" | grep -Eqi '(ui|ux|ui[[:space:]]*design|ux[[:space:]]*design|figma|mockup|wireframe|screenshot|layout|デザイン|画面|画像|スクリーンショット|レイアウト|pencil)'; then
            wants_gemini="true"
          fi
          if echo "${text}" | grep -Eqi '(x/twitter|twitter|tweet|tweets|xai|grok|x検索|トレンド|リアルタイム|速報|timeline|タイムライン)'; then
            wants_xai="true"
          fi

          # Keep /vote quorum baseline as 6 lanes minimum (Codex3 + GLM3).
          matrix="$(jq -cn '{
            include: [
              {name:"codex-security-analyst",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex",agent_role:"security-analyst"},
              {name:"codex-code-reviewer",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex",agent_role:"code-reviewer"},
              {name:"codex-general-reviewer",provider:"codex",api_url:"https://api.openai.com/v1/chat/completions",model:"gpt-5.3-codex-spark",agent_role:"general-reviewer"},
              {name:"glm-code-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5.0",agent_role:"code-reviewer"},
              {name:"glm-general-reviewer",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5.0",agent_role:"general-reviewer"},
              {name:"glm-math-reasoning",provider:"glm",api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",model:"glm-5.0",agent_role:"math-reasoning"}
            ]
          }')"
          main_signal_lane="codex-main-orchestrator"
          if [[ "${main_provider}" == "claude" ]]; then
            main_signal_lane="claude-main-orchestrator"
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "claude-main-orchestrator") then .
              else .include += [{
                name:"claude-main-orchestrator",
                provider:"claude",
                api_url:"https://api.anthropic.com/v1/messages",
                model:"claude-opus-4-1-20250805",
                agent_role:"main-orchestrator"
              }] end
            ')"
          else
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "codex-main-orchestrator") then .
              else .include += [{
                name:"codex-main-orchestrator",
                provider:"codex",
                api_url:"https://api.openai.com/v1/chat/completions",
                model:"gpt-5.3-codex",
                agent_role:"main-orchestrator"
              }] end
            ')"
          fi

          if [[ "${assist_provider}" == "claude" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "claude-opus-assist") then .
              else .include += [{
                name:"claude-opus-assist",
                provider:"claude",
                api_url:"https://api.anthropic.com/v1/messages",
                model:"claude-opus-4-1-20250805",
                agent_role:"orchestration-assistant"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c --arg sonnet4 "${CLAUDE_SONNET4_MODEL}" '
              if any(.include[]; .name == "claude-sonnet4-assist") then .
              else .include += [{
                name:"claude-sonnet4-assist",
                provider:"claude",
                api_url:"https://api.anthropic.com/v1/messages",
                model:$sonnet4,
                agent_role:"orchestration-assistant"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c --arg sonnet6 "${CLAUDE_SONNET6_MODEL}" '
              if any(.include[]; .name == "claude-sonnet6-assist") then .
              else .include += [{
                name:"claude-sonnet6-assist",
                provider:"claude",
                api_url:"https://api.anthropic.com/v1/messages",
                model:$sonnet6,
                agent_role:"orchestration-assistant"
              }] end
            ')"
          elif [[ "${assist_provider}" == "codex" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "codex-orchestration-assist") then .
              else .include += [{
                name:"codex-orchestration-assist",
                provider:"codex",
                api_url:"https://api.openai.com/v1/chat/completions",
                model:"gpt-5.3-codex-spark",
                agent_role:"orchestration-assistant"
              }] end
            ')"
          fi

          if [[ "${wants_gemini}" == "true" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "gemini-visual-reviewer") then .
              else .include += [{
                name:"gemini-visual-reviewer",
                provider:"gemini",
                api_url:"https://generativelanguage.googleapis.com/v1beta/models",
                model:"gemini-2.0-flash",
                agent_role:"ui-reviewer"
              }] end
            ')"
          fi

          if [[ "${wants_xai}" == "true" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "xai-realtime-info") then .
              else .include += [{
                name:"xai-realtime-info",
                provider:"xai",
                api_url:"https://api.x.ai/v1/chat/completions",
                model:"grok-3-mini",
                agent_role:"realtime-info"
              }] end
            ')"
          fi

          if [[ "${multi_agent_mode}" == "enhanced" || "${multi_agent_mode}" == "max" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "codex-architect") then .
              else .include += [{
                name:"codex-architect",
                provider:"codex",
                api_url:"https://api.openai.com/v1/chat/completions",
                model:"gpt-5.3-codex",
                agent_role:"architect"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "codex-plan-reviewer") then .
              else .include += [{
                name:"codex-plan-reviewer",
                provider:"codex",
                api_url:"https://api.openai.com/v1/chat/completions",
                model:"gpt-5.3-codex-spark",
                agent_role:"plan-reviewer"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "glm-refactor-advisor") then .
              else .include += [{
                name:"glm-refactor-advisor",
                provider:"glm",
                api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",
                model:"glm-5.0",
                agent_role:"refactor-advisor"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "glm-general-critic") then .
              else .include += [{
                name:"glm-general-critic",
                provider:"glm",
                api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",
                model:"glm-5.0",
                agent_role:"general-critic"
              }] end
            ')"
          fi

          if [[ "${multi_agent_mode}" == "max" ]]; then
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "codex-reliability-engineer") then .
              else .include += [{
                name:"codex-reliability-engineer",
                provider:"codex",
                api_url:"https://api.openai.com/v1/chat/completions",
                model:"gpt-5.3-codex-spark",
                agent_role:"reliability-engineer"
              }] end
            ')"
            matrix="$(echo "${matrix}" | jq -c '
              if any(.include[]; .name == "glm-invariants-checker") then .
              else .include += [{
                name:"glm-invariants-checker",
                provider:"glm",
                api_url:"https://api.z.ai/api/coding/paas/v4/chat/completions",
                model:"glm-5.0",
                agent_role:"invariants-checker"
              }] end
            ')"
          fi

          lanes="$(echo "${matrix}" | jq -r '.include | length')"

          {
            echo "provider=${main_provider}"
            echo "provider_requested=${main_provider_requested}"
            echo "multi_agent_mode=${multi_agent_mode}"
            echo "multi_agent_mode_source=${multi_agent_mode_source}"
            echo "claude_fallback_applied=${main_claude_fallback_applied}"
            echo "claude_fallback_reason=${main_claude_fallback_reason}"
            echo "main_provider=${main_provider}"
            echo "main_provider_requested=${main_provider_requested}"
            echo "main_claude_fallback_applied=${main_claude_fallback_applied}"
            echo "main_claude_fallback_reason=${main_claude_fallback_reason}"
            echo "assist_provider=${assist_provider}"
            echo "assist_provider_requested=${assist_provider_requested}"
            echo "assist_claude_fallback_applied=${assist_claude_fallback_applied}"
            echo "assist_claude_fallback_reason=${assist_claude_fallback_reason}"
            echo "claude_pressure_guard_applied=${claude_pressure_guard_applied}"
            echo "claude_pressure_guard_reason=${claude_pressure_guard_reason}"
            echo "main_signal_lane=${main_signal_lane}"
            echo "expected_lanes=${lanes}"
            echo "agent_matrix=${matrix}"
          } >> "${GITHUB_OUTPUT}"

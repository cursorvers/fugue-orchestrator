name: fugue-tutti-router

on:
  workflow_call:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: string
      orchestrator_provider:
        description: "Legacy main orchestrator profile input (claude|codex)"
        required: false
        type: string
        default: ""
      main_orchestrator_provider:
        description: "Main orchestrator profile (codex|claude)"
        required: false
        type: string
        default: ""
      assist_orchestrator_provider:
        description: "Assist orchestrator profile (claude|codex|none)"
        required: false
        type: string
        default: ""
      force_claude:
        description: "Force claude profile even when claude rate-limit state is degraded/exhausted"
        required: false
        type: string
        default: "false"
      multi_agent_mode_override:
        description: "Override multi-agent mode (standard|enhanced|max)"
        required: false
        type: string
        default: ""
      multi_agent_mode_lock:
        description: "When true, ignore issue-body multi-agent mode overrides"
        required: false
        type: string
        default: "false"
      risk_tier:
        description: "Risk tier inferred by caller (low|medium|high)"
        required: false
        type: string
        default: ""
      ambiguity_translation_gate:
        description: "true when caller ambiguity/translation gate requested Claude sub attention"
        required: false
        type: string
        default: "false"
      ambiguity_translation_score:
        description: "Caller ambiguity/translation score (0-100)"
        required: false
        type: string
        default: "0"
      claude_sub_trigger:
        description: "Caller assist auto-selection trigger text"
        required: false
        type: string
        default: "none"
      extra_issue_instruction:
        description: "Optional additional instruction text (for example from /vote comments)"
        required: false
        type: string
        default: ""
    outputs:
      ok_to_execute:
        description: "true when approvals >= 2/3 and no HIGH risk was detected"
        value: ${{ jobs.integrate.outputs.ok_to_execute }}
      vote_passed:
        description: "true when approvals >= 2/3"
        value: ${{ jobs.integrate.outputs.vote_passed }}
      threshold:
        description: "ceil(2/3 * total_count)"
        value: ${{ jobs.integrate.outputs.threshold }}
      high_risk:
        description: "true when any agent reports HIGH risk"
        value: ${{ jobs.integrate.outputs.high_risk }}
      approve_count:
        description: "number of approvals"
        value: ${{ jobs.integrate.outputs.approve_count }}
      total_count:
        description: "number of total agent results"
        value: ${{ jobs.integrate.outputs.total_count }}
      weighted_approve_score:
        description: "weighted approval score"
        value: ${{ jobs.integrate.outputs.weighted_approve_score }}
      weighted_total_score:
        description: "weighted total score"
        value: ${{ jobs.integrate.outputs.weighted_total_score }}
      weighted_threshold:
        description: "weighted threshold score"
        value: ${{ jobs.integrate.outputs.weighted_threshold }}
      weighted_vote_passed:
        description: "true when weighted approvals meet threshold"
        value: ${{ jobs.integrate.outputs.weighted_vote_passed }}
      expected_lanes:
        description: "configured lane count for this run"
        value: ${{ jobs.resolve-orchestrator.outputs.expected_lanes }}
      resolved_multi_agent_mode:
        description: "resolved multi-agent mode after policy/override resolution"
        value: ${{ jobs.resolve-orchestrator.outputs.multi_agent_mode }}
      resolved_multi_agent_mode_source:
        description: "where the resolved multi-agent mode came from"
        value: ${{ jobs.resolve-orchestrator.outputs.multi_agent_mode_source }}
      resolved_glm_subagent_mode:
        description: "resolved GLM subagent mode after policy/override resolution"
        value: ${{ jobs.resolve-orchestrator.outputs.glm_subagent_mode }}
      resolved_glm_subagent_mode_source:
        description: "where the resolved GLM subagent mode came from"
        value: ${{ jobs.resolve-orchestrator.outputs.glm_subagent_mode_source }}
      resolved_main_signal_lanes:
        description: "resolved main signal lanes for this run"
        value: ${{ jobs.resolve-orchestrator.outputs.main_signal_lanes }}
    secrets:
      OPENAI_API_KEY:
        required: false
      ZAI_API_KEY:
        required: false
      GEMINI_API_KEY:
        required: false
      XAI_API_KEY:
        required: false
      ANTHROPIC_API_KEY:
        required: false

permissions:
  issues: write
  contents: read
  actions: read

concurrency:
  group: fugue-tutti-${{ github.repository }}-${{ github.event.issue.number || inputs.issue_number || github.run_id }}
  cancel-in-progress: false

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      should_run: ${{ steps.ctx.outputs.should_run }}
      skip_reason: ${{ steps.ctx.outputs.skip_reason }}
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      issue_title: ${{ steps.ctx.outputs.issue_title }}
      issue_body: ${{ steps.ctx.outputs.issue_body }}
      author: ${{ steps.ctx.outputs.author }}
      has_implement_request: ${{ steps.ctx.outputs.has_implement_request }}
      emergency_continuity_mode: ${{ steps.ctx.outputs.emergency_continuity_mode }}
      self_hosted_online_count: ${{ steps.ctx.outputs.self_hosted_online_count }}
      subscription_runner_label: ${{ steps.ctx.outputs.subscription_runner_label }}
      trusted: ${{ steps.trust.outputs.trusted }}
      permission: ${{ steps.trust.outputs.permission }}

    steps:
      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
          EXTRA_ISSUE_INSTRUCTION: ${{ inputs.extra_issue_instruction }}
          CI_EXECUTION_ENGINE: ${{ vars.FUGUE_CI_EXECUTION_ENGINE || 'subscription' }}
          SUBSCRIPTION_OFFLINE_POLICY: ${{ vars.FUGUE_SUBSCRIPTION_OFFLINE_POLICY || 'continuity' }}
          EMERGENCY_CONTINUITY_MODE: ${{ vars.FUGUE_EMERGENCY_CONTINUITY_MODE || 'false' }}
          SUBSCRIPTION_RUNNER_LABEL: ${{ vars.FUGUE_SUBSCRIPTION_RUNNER_LABEL || 'fugue-subscription' }}
        run: |
          set -euo pipefail
          gh_api_retry() {
            local endpoint="$1"
            local attempts="${2:-5}"
            local sleep_sec=2
            local i out
            for ((i=1; i<=attempts; i++)); do
              if out="$(gh api "${endpoint}" 2>/dev/null)"; then
                printf '%s\n' "${out}"
                return 0
              fi
              if (( i == attempts )); then
                return 1
              fi
              sleep "${sleep_sec}"
              if (( sleep_sec < 16 )); then
                sleep_sec=$((sleep_sec * 2))
              fi
            done
            return 1
          }

          ISSUE_NUMBER="${{ inputs.issue_number }}"
          if [[ -n "${ISSUE_NUMBER}" ]]; then
            issue_endpoint="repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}"
            if ! issue_json="$(gh_api_retry "${issue_endpoint}" 5)"; then
              echo "Failed to fetch issue context after retries: ${issue_endpoint}" >&2
              exit 1
            fi
          else
            issue_json="$(jq -c '.issue' "${GITHUB_EVENT_PATH}")"
            ISSUE_NUMBER="$(echo "${issue_json}" | jq -r '.number')"
          fi

          TITLE="$(echo "${issue_json}" | jq -r '.title // ""')"
          BODY="$(echo "${issue_json}" | jq -r '.body // ""')"
          extra_issue_instruction="$(printf '%s' "${EXTRA_ISSUE_INSTRUCTION:-}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -n "${extra_issue_instruction}" ]]; then
            BODY="$(printf '%s\n\n## Vote Instruction\n%s\n' "${BODY}" "${extra_issue_instruction}")"
          fi
          AUTHOR="$(echo "${issue_json}" | jq -r '.user.login // ""')"
          HAS_FUGUE="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          HAS_TUTTI="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          HAS_PROCESSING="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("processing") != null')"
          HAS_IMPLEMENT_REQUEST="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | (index("implement") != null) or (index("codex-implement") != null) or (index("claude-implement") != null)')"
          ci_execution_engine="$(echo "${CI_EXECUTION_ENGINE:-subscription}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ci_execution_engine}" != "harness" && "${ci_execution_engine}" != "api" && "${ci_execution_engine}" != "subscription" ]]; then
            ci_execution_engine="subscription"
          fi
          subscription_offline_policy="$(echo "${SUBSCRIPTION_OFFLINE_POLICY:-continuity}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${subscription_offline_policy}" != "hold" && "${subscription_offline_policy}" != "continuity" ]]; then
            subscription_offline_policy="continuity"
          fi
          emergency_continuity_mode="$(echo "${EMERGENCY_CONTINUITY_MODE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${emergency_continuity_mode}" != "true" ]]; then
            emergency_continuity_mode="false"
          fi
          subscription_runner_label="$(echo "${SUBSCRIPTION_RUNNER_LABEL:-fugue-subscription}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${subscription_runner_label}" ]]; then
            subscription_runner_label="fugue-subscription"
          fi
          self_hosted_online_count="0"
          if [[ "${ci_execution_engine}" == "subscription" ]]; then
            runners_endpoint="repos/${GITHUB_REPOSITORY}/actions/runners?per_page=100"
            runners_json="$(gh_api_retry "${runners_endpoint}" 5 || echo '{}')"
            self_hosted_online_count="$(echo "${runners_json}" | jq -r --arg label "${subscription_runner_label}" '[.runners[]? | select(.status=="online" and .busy != true and ([.labels[]?.name] | index("self-hosted") != null) and ([.labels[]?.name] | index($label) != null))] | length' 2>/dev/null || echo "0")"
            self_hosted_online_count="$(echo "${self_hosted_online_count}" | tr -cd '0-9')"
            if [[ -z "${self_hosted_online_count}" ]]; then
              self_hosted_online_count="0"
            else
              self_hosted_online_count="$((10#${self_hosted_online_count}))"
            fi
          fi

          SHOULD_RUN="true"
          SKIP_REASON=""
          if [[ "${HAS_FUGUE}" != "true" || "${HAS_TUTTI}" != "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="missing-required-labels"
          elif [[ "${ci_execution_engine}" == "subscription" && "${subscription_offline_policy}" == "hold" && "${emergency_continuity_mode}" != "true" && "${self_hosted_online_count}" == "0" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="subscription-self-hosted-offline-strict"
          elif [[ "${emergency_continuity_mode}" == "true" ]]; then
            if [[ "${HAS_PROCESSING}" != "true" ]]; then
              SHOULD_RUN="false"
              SKIP_REASON="emergency-inflight-only"
            fi
          elif [[ "${HAS_PROCESSING}" == "true" ]]; then
            SHOULD_RUN="false"
            SKIP_REASON="already-processing"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "issue_title<<EOF"
            echo "${TITLE}"
            echo "EOF"
            echo "issue_body<<EOF"
            echo "${BODY}"
            echo "EOF"
            echo "author=${AUTHOR}"
            echo "has_implement_request=${HAS_IMPLEMENT_REQUEST}"
            echo "emergency_continuity_mode=${emergency_continuity_mode}"
            echo "self_hosted_online_count=${self_hosted_online_count}"
            echo "subscription_runner_label=${subscription_runner_label}"
            echo "should_run=${SHOULD_RUN}"
            echo "skip_reason=${SKIP_REASON}"
          } >> "${GITHUB_OUTPUT}"

      - name: Check author trust
        id: trust
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh_api_retry() {
            local endpoint="$1"
            local attempts="${2:-4}"
            local sleep_sec=2
            local i out
            for ((i=1; i<=attempts; i++)); do
              if out="$(gh api "${endpoint}" 2>/dev/null)"; then
                printf '%s\n' "${out}"
                return 0
              fi
              if (( i == attempts )); then
                return 1
              fi
              sleep "${sleep_sec}"
              if (( sleep_sec < 16 )); then
                sleep_sec=$((sleep_sec * 2))
              fi
            done
            return 1
          }

          AUTHOR="${{ steps.ctx.outputs.author }}"
          PERM="none"

          perm_endpoint="repos/${GITHUB_REPOSITORY}/collaborators/${AUTHOR}/permission"
          perm_json="$(gh_api_retry "${perm_endpoint}" 4 || echo '{}')"
          if echo "${perm_json}" | jq -e '.permission' >/dev/null 2>&1; then
            PERM="$(echo "${perm_json}" | jq -r '.permission')"
          fi

          TRUSTED="false"
          if [[ "${PERM}" == "write" || "${PERM}" == "maintain" || "${PERM}" == "admin" ]]; then
            TRUSTED="true"
          fi

          {
            echo "permission=${PERM}"
            echo "trusted=${TRUSTED}"
          } >> "${GITHUB_OUTPUT}"

      - name: Add processing label
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --remove-label "completed" \
            --remove-label "needs-review" \
            --remove-label "needs-human" \
            --remove-label "vote-approved" \
            --remove-label "vote-rejected" || true
          gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --add-label "processing"

      - name: Mark untrusted as needs-human
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.trust.outputs.trusted != 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ISSUE="${{ steps.ctx.outputs.issue_number }}"
          gh issue comment "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --body "Author trust check failed (permission: ${{ steps.trust.outputs.permission }}). Hand-off to humans required."
          gh issue edit "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human" --remove-label "processing" || true

      - name: Comment when subscription strict is paused
        if: ${{ steps.ctx.outputs.should_run != 'true' && steps.ctx.outputs.skip_reason == 'subscription-self-hosted-offline-strict' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE: ${{ steps.ctx.outputs.issue_number }}
          ONLINE_COUNT: ${{ steps.ctx.outputs.self_hosted_online_count }}
          RUNNER_LABEL: ${{ steps.ctx.outputs.subscription_runner_label }}
        run: |
          gh issue comment "${ISSUE}" --repo "${GITHUB_REPOSITORY}" --body "Subscription-strict pause: no online self-hosted runner detected for required label \`${RUNNER_LABEL}\` (online=${ONLINE_COUNT}). Task is kept pending; no API continuity fallback was executed. Local fallback: \`./scripts/local/run-local-orchestration.sh --issue ${ISSUE} --repo ${GITHUB_REPOSITORY} --mode enhanced --glm-mode paired --max-parallel 4\`"

  pause-subscription:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' && needs.resolve-orchestrator.outputs.execution_profile == 'subscription-paused' }}
    needs: [prepare, resolve-orchestrator]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Clear processing and post pause notice
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
          ONLINE_COUNT: ${{ needs.resolve-orchestrator.outputs.self_hosted_online_count }}
          RUNNER_LABEL: ${{ needs.resolve-orchestrator.outputs.subscription_runner_label }}
        run: |
          set -euo pipefail
          gh_api_retry() {
            local endpoint="$1"
            local attempts="${2:-5}"
            local sleep_sec=2
            local i out
            for ((i=1; i<=attempts; i++)); do
              if out="$(gh api "${endpoint}" 2>/dev/null)"; then
                printf '%s\n' "${out}"
                return 0
              fi
              if (( i == attempts )); then
                return 1
              fi
              sleep "${sleep_sec}"
              if (( sleep_sec < 16 )); then
                sleep_sec=$((sleep_sec * 2))
              fi
            done
            return 1
          }
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription-strict pause: no available self-hosted runner detected for required label \`${RUNNER_LABEL}\` (available=${ONLINE_COUNT}). Task is kept pending; no agent lanes were started. Local fallback: \`./scripts/local/run-local-orchestration.sh --issue ${ISSUE_NUMBER} --repo ${GITHUB_REPOSITORY} --mode enhanced --glm-mode paired --max-parallel 4\`"

  run-agents:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' && needs.resolve-orchestrator.outputs.execution_profile != 'subscription-paused' }}
    needs: [prepare, resolve-orchestrator]
    runs-on: ${{ fromJson(needs.resolve-orchestrator.outputs.run_agents_runner_json) }}
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.resolve-orchestrator.outputs.agent_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Call agent engine
        id: call
        env:
          ISSUE_TITLE: ${{ needs.prepare.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.prepare.outputs.issue_body }}
          ORCHESTRATOR_PROVIDER: ${{ needs.resolve-orchestrator.outputs.main_provider }}
          ASSIST_ORCHESTRATOR_PROVIDER: ${{ needs.resolve-orchestrator.outputs.assist_provider }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
          CLAUDE_ASSIST_EXECUTION_POLICY: ${{ vars.FUGUE_CLAUDE_ASSIST_EXECUTION_POLICY || '' }}
          CLAUDE_OPUS_MODEL: ${{ vars.FUGUE_CLAUDE_OPUS_MODEL || 'claude-sonnet-4-6' }}
          CODEX_MAIN_MODEL: ${{ vars.FUGUE_CODEX_MAIN_MODEL || 'gpt-5-codex' }}
          CODEX_MULTI_AGENT_MODEL: ${{ vars.FUGUE_CODEX_MULTI_AGENT_MODEL || 'gpt-5.3-codex-spark' }}
          XAI_MODEL_LATEST: ${{ vars.FUGUE_XAI_MODEL || 'grok-4' }}
          GEMINI_FALLBACK_MODEL: ${{ vars.FUGUE_GEMINI_FALLBACK_MODEL || 'gemini-3-flash' }}
          STRICT_MAIN_CODEX_MODEL: ${{ needs.resolve-orchestrator.outputs.strict_main_codex_model_effective }}
          STRICT_OPUS_ASSIST_DIRECT: ${{ needs.resolve-orchestrator.outputs.strict_opus_assist_direct_effective }}
          CI_EXECUTION_ENGINE: ${{ needs.resolve-orchestrator.outputs.ci_execution_engine }}
          EXECUTION_PROFILE: ${{ needs.resolve-orchestrator.outputs.execution_profile }}
          SUBSCRIPTION_CLI_TIMEOUT_SEC: ${{ vars.FUGUE_SUBSCRIPTION_CLI_TIMEOUT_SEC || '180' }}
          FUGUE_CODEX_RECURSIVE_DELEGATION: ${{ vars.FUGUE_CODEX_RECURSIVE_DELEGATION || 'false' }}
          FUGUE_CODEX_RECURSIVE_MAX_DEPTH: ${{ vars.FUGUE_CODEX_RECURSIVE_MAX_DEPTH || '3' }}
          FUGUE_CODEX_RECURSIVE_TARGET_LANES: ${{ vars.FUGUE_CODEX_RECURSIVE_TARGET_LANES || 'codex-main-orchestrator,codex-orchestration-assist' }}
          FUGUE_CODEX_RECURSIVE_DRY_RUN: ${{ vars.FUGUE_CODEX_RECURSIVE_DRY_RUN || 'false' }}
          API_URL: ${{ matrix.api_url }}
          PROVIDER: ${{ matrix.provider }}
          MODEL: ${{ matrix.model }}
          AGENT_ROLE: ${{ matrix.agent_role }}
          AGENT_NAME: ${{ matrix.name }}
          AGENT_DIRECTIVE: ${{ matrix.agent_directive || '' }}
        run: |
          set -euo pipefail

          ci_execution_engine="$(echo "${CI_EXECUTION_ENGINE:-subscription}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ci_execution_engine}" != "harness" && "${ci_execution_engine}" != "api" && "${ci_execution_engine}" != "subscription" ]]; then
            ci_execution_engine="subscription"
          fi
          if [[ "${ci_execution_engine}" == "harness" ]]; then
            if [[ ! -x "scripts/harness/ci-agent-runner.sh" ]]; then
              echo "harness execution engine is enabled, but scripts/harness/ci-agent-runner.sh is missing or not executable." >&2
              exit 1
            fi
            bash scripts/harness/ci-agent-runner.sh
            exit 0
          fi
          if [[ "${ci_execution_engine}" == "subscription" ]]; then
            if [[ ! -x "scripts/harness/subscription-agent-runner.sh" ]]; then
              echo "subscription execution engine is enabled, but scripts/harness/subscription-agent-runner.sh is missing or not executable." >&2
              exit 1
            fi
            bash scripts/harness/subscription-agent-runner.sh
            exit 0
          fi

          agent_directive="$(echo "${AGENT_DIRECTIVE:-}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          sys_prompt="You are ${AGENT_ROLE}. Analyze the GitHub issue and return ONLY valid JSON with keys: risk (LOW|MEDIUM|HIGH), approve (boolean), findings (array of strings), recommendation (string), rationale (string)."
          if [[ -n "${agent_directive}" ]]; then
            sys_prompt="${sys_prompt} Focus directive: ${agent_directive}"
          fi
          user_prompt="Issue Title: ${ISSUE_TITLE}

          Issue Body:
          ${ISSUE_BODY}"

          CLAUDE_PROXY_MODE="false"
          CLAUDE_PROXY_NOTE=""
          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi
          CODEX_MAIN_MODEL="gpt-5-codex"
          if ! [[ "${CODEX_MULTI_AGENT_MODEL}" =~ ^gpt-5(\.[0-9]+)?-codex-spark$ ]]; then
            CODEX_MULTI_AGENT_MODEL="gpt-5.3-codex-spark"
          fi
          if [[ "${CLAUDE_OPUS_MODEL}" != "claude-sonnet-4-6" ]]; then
            CLAUDE_OPUS_MODEL="claude-sonnet-4-6"
          fi
          if [[ "${GEMINI_FALLBACK_MODEL}" != "gemini-3.1-pro" && "${GEMINI_FALLBACK_MODEL}" != "gemini-3-flash" ]]; then
            GEMINI_FALLBACK_MODEL="gemini-3-flash"
          fi
          if ! [[ "${XAI_MODEL_LATEST}" =~ ^grok-4([.-].+)?$ ]]; then
            XAI_MODEL_LATEST="grok-4"
          fi

          requested_model="$(echo "${MODEL:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          case "${PROVIDER}" in
            codex)
              if [[ "${AGENT_NAME}" == "codex-main-orchestrator" ]]; then
                MODEL="${CODEX_MAIN_MODEL}"
              elif [[ -n "${requested_model}" && "${requested_model}" =~ ^gpt-5(\.[0-9]+)?-codex-spark$ ]]; then
                MODEL="${requested_model}"
              else
                MODEL="${CODEX_MULTI_AGENT_MODEL}"
              fi
              ;;
            claude)
              MODEL="${CLAUDE_OPUS_MODEL}"
              ;;
            glm)
              MODEL="glm-5.0"
              ;;
            gemini)
              if [[ "${requested_model}" == "gemini-3.1-pro" || "${requested_model}" == "gemini-3-flash" ]]; then
                MODEL="${requested_model}"
              else
                MODEL="gemini-3.1-pro"
              fi
              ;;
            xai)
              if [[ -n "${requested_model}" && "${requested_model}" =~ ^grok-4([.-].+)?$ ]]; then
                MODEL="${requested_model}"
              else
                MODEL="${XAI_MODEL_LATEST}"
              fi
              ;;
          esac

          # Gemini can run without being OpenAI-compatible; if key is missing, skip it.
          if [[ "${PROVIDER}" == "gemini" && -z "${GEMINI_API_KEY:-}" ]]; then
            result="$(jq -n \
              --arg name "${AGENT_NAME}" \
              --arg provider "${PROVIDER}" \
              --arg api_url "${API_URL}" \
              --arg model "${MODEL}" \
              --arg agent_role "${AGENT_ROLE}" \
              '{
                name:$name,
                provider:$provider,
                api_url:$api_url,
                model:$model,
                agent_role:$agent_role,
                http_code:"skipped",
                skipped:true,
                risk:"MEDIUM",
                approve:false,
                findings:["Skipped: missing GEMINI_API_KEY"],
                recommendation:"Add GEMINI_API_KEY to enable Gemini voter",
                rationale:"Gemini voter was skipped due to missing secret"
              }')"
            echo "${result}" > "agent-${AGENT_NAME}.json"
            exit 0
          fi

          if [[ "${PROVIDER}" == "xai" && -z "${XAI_API_KEY:-}" ]]; then
            result="$(jq -n \
              --arg name "${AGENT_NAME}" \
              --arg provider "${PROVIDER}" \
              --arg api_url "${API_URL}" \
              --arg model "${MODEL}" \
              --arg agent_role "${AGENT_ROLE}" \
              '{
                name:$name,
                provider:$provider,
                api_url:$api_url,
                model:$model,
                agent_role:$agent_role,
                http_code:"skipped",
                skipped:true,
                risk:"MEDIUM",
                approve:false,
                findings:["Skipped: missing XAI_API_KEY"],
                recommendation:"Add XAI_API_KEY to enable xAI voter",
                rationale:"xAI voter was skipped due to missing secret"
              }')"
            echo "${result}" > "agent-${AGENT_NAME}.json"
            exit 0
          fi

          if [[ "${PROVIDER}" == "claude" && -z "${ANTHROPIC_API_KEY:-}" ]]; then
            if [[ "${claude_max_plan}" == "true" && -n "${OPENAI_API_KEY:-}" ]]; then
              PROVIDER="codex"
              API_URL="https://api.openai.com/v1/chat/completions"
              MODEL="${CODEX_MULTI_AGENT_MODEL}"
              CLAUDE_PROXY_MODE="true"
              CLAUDE_PROXY_NOTE="Claude MAX plan mode: executed via Codex proxy because ANTHROPIC_API_KEY is not configured."
            else
              result="$(jq -n \
                --arg name "${AGENT_NAME}" \
                --arg provider "${PROVIDER}" \
                --arg api_url "${API_URL}" \
                --arg model "${MODEL}" \
                --arg agent_role "${AGENT_ROLE}" \
                '{
                  name:$name,
                  provider:$provider,
                  api_url:$api_url,
                  model:$model,
                  agent_role:$agent_role,
                  http_code:"skipped",
                  skipped:true,
                  risk:"MEDIUM",
                  approve:false,
                  findings:["Skipped: missing ANTHROPIC_API_KEY and Claude MAX proxy mode is disabled"],
                  recommendation:"Set FUGUE_CLAUDE_MAX_PLAN=true or provide ANTHROPIC_API_KEY to enable Claude lanes",
                  rationale:"Claude lane was skipped due to missing credential path"
                }')"
              echo "${result}" > "agent-${AGENT_NAME}.json"
              exit 0
            fi
          fi

          req=""
          auth_header=""
          if [[ "${PROVIDER}" == "codex" || "${PROVIDER}" == "glm" || "${PROVIDER}" == "xai" ]]; then
            req="$(jq -n \
              --arg model "${MODEL}" \
              --arg s "${sys_prompt}" \
              --arg u "${user_prompt}" \
              '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
            if [[ "${PROVIDER}" == "codex" ]]; then
              auth_header="Authorization: Bearer ${OPENAI_API_KEY}"
            elif [[ "${PROVIDER}" == "glm" ]]; then
              auth_header="Authorization: Bearer ${ZAI_API_KEY}"
            else
              auth_header="Authorization: Bearer ${XAI_API_KEY}"
            fi
          elif [[ "${PROVIDER}" == "claude" ]]; then
            req="$(jq -n \
              --arg model "${MODEL}" \
              --arg s "${sys_prompt}" \
              --arg u "${user_prompt}" \
              '{model:$model,system:$s,messages:[{role:"user",content:$u}],max_tokens:1200,temperature:0.1}')"
          else
            # Gemini generateContent expects a single "user" content string. Keep it strict: JSON only.
            req="$(jq -n \
              --arg text "SYSTEM:\n${sys_prompt}\n\nUSER:\n${user_prompt}\n\nReturn ONLY JSON." \
              '{contents:[{parts:[{text:$text}]}],generationConfig:{temperature:0.1}}')"
          fi

          chosen_model="${MODEL}"
          effective_provider="${PROVIDER}"
          effective_api_url="${API_URL}"
          http_code=""
          content=""

          if [[ "${PROVIDER}" == "codex" ]]; then
            # Prefer latest Codex family + configured repository defaults.
            candidates=("${MODEL}" "${CODEX_MAIN_MODEL}" "${CODEX_MULTI_AGENT_MODEL}" "gpt-5-codex")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done

            # If Codex lane is unavailable, fail over to GLM-5.0 so consensus can continue.
            if [[ "${http_code}" != "200" && -n "${ZAI_API_KEY:-}" ]]; then
              effective_provider="glm"
              effective_api_url="https://api.z.ai/api/coding/paas/v4/chat/completions"
              chosen_model="glm-5.0"
              fallback_req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
              http_code="$(curl -sS -o response.json -w "%{http_code}" "${effective_api_url}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "Authorization: Bearer ${ZAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${fallback_req}" || true)"
            fi
          elif [[ "${PROVIDER}" == "xai" ]]; then
            candidates=("${MODEL}" "${XAI_MODEL_LATEST}" "grok-4-fast-reasoning" "grok-4-fast-non-reasoning")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "${auth_header}" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done
          elif [[ "${PROVIDER}" == "claude" ]]; then
            candidates=("${MODEL}" "${CLAUDE_OPUS_MODEL}")
            for m in "${candidates[@]}"; do
              chosen_model="${m}"
              req="$(jq -n \
                --arg model "${chosen_model}" \
                --arg s "${sys_prompt}" \
                --arg u "${user_prompt}" \
                '{model:$model,system:$s,messages:[{role:"user",content:$u}],max_tokens:1200,temperature:0.1}')"

              http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "x-api-key: ${ANTHROPIC_API_KEY}" \
                -H "anthropic-version: 2023-06-01" \
                -H "Content-Type: application/json" \
                -d "${req}" || true)"
              if [[ "${http_code}" == "200" ]]; then
                break
              fi
            done
          else
            if [[ "${PROVIDER}" == "glm" ]]; then
              candidates=("${MODEL}" "glm-5.0")
              for m in "${candidates[@]}"; do
                chosen_model="${m}"
                req="$(jq -n \
                  --arg model "${chosen_model}" \
                  --arg s "${sys_prompt}" \
                  --arg u "${user_prompt}" \
                  '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"

                http_code="$(curl -sS -o response.json -w "%{http_code}" "${API_URL}" \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "${auth_header}" \
                  -H "Content-Type: application/json" \
                  -d "${req}" || true)"
                if [[ "${http_code}" == "200" ]]; then
                  break
                fi
              done

              # Keep 6-lane quorum robust when GLM endpoint/model is temporarily unavailable.
              if [[ "${http_code}" != "200" && -n "${OPENAI_API_KEY:-}" ]]; then
                effective_provider="codex"
                effective_api_url="https://api.openai.com/v1/chat/completions"
                chosen_model="${CODEX_MULTI_AGENT_MODEL}"
                fallback_req="$(jq -n \
                  --arg model "${chosen_model}" \
                  --arg s "${sys_prompt}" \
                  --arg u "${user_prompt}" \
                  '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
                http_code="$(curl -sS -o response.json -w "%{http_code}" "${effective_api_url}" \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d "${fallback_req}" || true)"
              fi
            else
              # Gemini REST API (key in query param): primary MODEL then flash fallback.
              gemini_candidates=("${MODEL}")
              if [[ -n "${GEMINI_FALLBACK_MODEL}" && "${MODEL}" != "${GEMINI_FALLBACK_MODEL}" ]]; then
                gemini_candidates+=("${GEMINI_FALLBACK_MODEL}")
              fi
              for gm in "${gemini_candidates[@]}"; do
                chosen_model="${gm}"
                gemini_url="${API_URL}/${gm}:generateContent?key=${GEMINI_API_KEY}"
                http_code="$(curl -sS -o response.json -w "%{http_code}" "${gemini_url}" \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "Content-Type: application/json" \
                  -d "${req}" || true)"
                if [[ "${http_code}" == "200" ]]; then
                  break
                fi
              done
            fi
          fi

          if [[ "${PROVIDER}" == "gemini" ]]; then
            content="$(jq -r '.candidates[0].content.parts[0].text // ""' response.json 2>/dev/null || echo "")"
          elif [[ "${PROVIDER}" == "claude" ]]; then
            content="$(jq -r '[.content[]? | select(.type=="text") | .text] | join("\n") // ""' response.json 2>/dev/null || echo "")"
          else
            content="$(jq -r '.choices[0].message.content // ""' response.json 2>/dev/null || echo "")"
          fi

          skipped_flag="false"
          # Optional specialist lanes are excluded from consensus totals when they fail.
          if [[ ( "${PROVIDER}" == "gemini" || "${PROVIDER}" == "xai" || "${PROVIDER}" == "claude" || ( "${PROVIDER}" == "glm" && "${AGENT_NAME}" == glm-*-subagent ) ) && "${http_code}" != "200" ]]; then
            skipped_flag="true"
          fi

          optional_error_note=""
          optional_provider_label=""
          if [[ "${PROVIDER}" == "gemini" && "${http_code}" != "200" ]]; then
            optional_provider_label="Gemini"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="Gemini API rate limited (HTTP 429)"
            else
              optional_error_note="Gemini API error (HTTP ${http_code})"
            fi
          elif [[ "${PROVIDER}" == "xai" && "${http_code}" != "200" ]]; then
            optional_provider_label="xAI"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="xAI API rate limited (HTTP 429)"
            else
              optional_error_note="xAI API error (HTTP ${http_code})"
            fi
          elif [[ "${PROVIDER}" == "claude" && "${http_code}" != "200" ]]; then
            optional_provider_label="Claude"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="Claude API rate limited (HTTP 429)"
            else
              optional_error_note="Claude API error (HTTP ${http_code})"
            fi
          elif [[ "${PROVIDER}" == "glm" && "${AGENT_NAME}" == glm-*-subagent && "${http_code}" != "200" ]]; then
            optional_provider_label="GLM"
            if [[ "${http_code}" == "429" ]]; then
              optional_error_note="GLM subagent API rate limited (HTTP 429)"
            else
              optional_error_note="GLM subagent API error (HTTP ${http_code})"
            fi
          fi

          # Extract JSON even if wrapped in ```json fences.
          extracted="$(jq -Rn --arg s "${content}" '
            ($s | gsub("\r"; "") | gsub("^\\s+|\\s+$"; "")) as $t |
            if ($t | test("```json"; "i")) then
              (($t | split("```json") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            elif ($t | test("```"; "i")) then
              (($t | split("```") | .[1] // $t) | split("```") | .[0]) | gsub("^\\s+|\\s+$"; "")
            else
              $t
            end
          ')"

          normalized="$(echo "${extracted}" | jq -c '
            if type == "string" then (fromjson? // .) else . end
          ' 2>/dev/null || true)"

          if [[ -n "${optional_error_note}" ]]; then
            parsed="$(jq -n \
              --arg note "${optional_error_note}" \
              --arg provider "${optional_provider_label}" \
              '{
                risk:"MEDIUM",
                approve:false,
                findings:[$note],
                recommendation:("Retry later or reduce " + $provider + " specialist lane pressure"),
                rationale:"Optional specialist lane skipped due to provider-side throttling/error"
              }')"
          elif [[ -n "${normalized}" ]] && echo "${normalized}" | jq -e 'type == "object"' >/dev/null 2>&1; then
            parsed="${normalized}"
          else
            parsed="$(jq -n --arg c "${content}" '{risk:"MEDIUM",approve:false,findings:["Could not parse JSON object from model output"],recommendation:"Manual review required",rationale:($c|tostring)}')"
          fi

          if [[ "${CLAUDE_PROXY_MODE}" == "true" ]]; then
            parsed="$(echo "${parsed}" | jq -c \
              --arg note "${CLAUDE_PROXY_NOTE}" \
              '{
                risk:(.risk // "MEDIUM"),
                approve:(.approve // false),
                findings:(
                  (if (.findings|type)=="array" then .findings else [(.findings|tostring)] end) + [$note]
                ),
                recommendation:(.recommendation // "No recommendation"),
                rationale:(
                  (.rationale // "No rationale") + " | " + $note
                )
              }')"
          fi

          reported_provider="${effective_provider}"
          if [[ "${CLAUDE_PROXY_MODE}" == "true" ]]; then
            reported_provider="claude-max-proxy-codex"
          fi

          result="$(jq -n \
            --arg name "${AGENT_NAME}" \
            --arg provider "${reported_provider}" \
            --arg api_url "${effective_api_url}" \
            --arg model "${chosen_model}" \
            --arg agent_role "${AGENT_ROLE}" \
            --argjson payload "${parsed}" \
            --arg http_code "${http_code}" \
            --arg skipped "${skipped_flag}" \
            '{
              name:$name,
              provider:$provider,
              api_url:$api_url,
              model:$model,
              agent_role:$agent_role,
              http_code:$http_code,
              skipped:($skipped == "true"),
              risk:(($payload.risk // "MEDIUM")|ascii_upcase),
              approve:($payload.approve // false),
              findings:(if ($payload.findings|type)=="array" then $payload.findings else [($payload.findings|tostring)] end),
              recommendation:($payload.recommendation // "No recommendation"),
              rationale:($payload.rationale // "No rationale"),
              execution_engine:"api"
            }')"

          echo "${result}" > "agent-${AGENT_NAME}.json"

      - name: Upload JSON artifact
        uses: actions/upload-artifact@v4
        with:
          name: agent-result-${{ matrix.name }}
          path: agent-${{ matrix.name }}.json
          if-no-files-found: error

  subscription-queue-guard:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' && needs.resolve-orchestrator.outputs.execution_profile == 'subscription-strict' }}
    needs: [prepare, resolve-orchestrator]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      actions: write
      issues: write
      contents: read
    steps:
      - name: Detect stalled self-hosted queue and pause
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
          QUEUE_GUARD_TIMEOUT_SEC: ${{ vars.FUGUE_SUBSCRIPTION_QUEUE_GUARD_TIMEOUT_SEC || '120' }}
          EXPECTED_LANES: ${{ needs.resolve-orchestrator.outputs.expected_lanes }}
        run: |
          set -euo pipefail

          timeout_sec="$(echo "${QUEUE_GUARD_TIMEOUT_SEC:-120}" | tr -cd '0-9')"
          if [[ -z "${timeout_sec}" ]]; then
            timeout_sec="120"
          fi
          if (( timeout_sec < 30 )); then
            timeout_sec=30
          elif (( timeout_sec > 900 )); then
            timeout_sec=900
          fi
          interval_sec=10
          max_watch_sec=$((timeout_sec * 2))
          if (( max_watch_sec < 120 )); then
            max_watch_sec=120
          elif (( max_watch_sec > 300 )); then
            max_watch_sec=300
          fi
          elapsed=0
          idle_sec=0
          saw_jobs="false"
          last_metric=-1
          expected_lanes="$(echo "${EXPECTED_LANES:-0}" | tr -cd '0-9')"
          if [[ -z "${expected_lanes}" ]]; then
            expected_lanes="0"
          fi

          while (( elapsed < max_watch_sec )); do
            jobs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/jobs?per_page=100" 2>/dev/null || echo '{}')"
            total="$(echo "${jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents"))] | length' 2>/dev/null || echo "0")"
            started_count="$(echo "${jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and (((.steps // []) | length) > 0))] | length' 2>/dev/null || echo "0")"
            completed_count="$(echo "${jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and ((.conclusion // "") != ""))] | length' 2>/dev/null || echo "0")"
            running_count="$(echo "${jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and .status == "in_progress" and (((.steps // []) | length) > 0))] | length' 2>/dev/null || echo "0")"
            pending_count="$(echo "${jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and (((.steps // []) | length) == 0) and ((.conclusion // "") == ""))] | length' 2>/dev/null || echo "0")"

            if (( total > 0 )); then
              saw_jobs="true"
            fi
            metric=$((started_count + completed_count))
            if (( running_count > 0 || metric > last_metric )); then
              idle_sec=0
            else
              idle_sec=$((idle_sec + interval_sec))
            fi
            last_metric="${metric}"

            if [[ "${saw_jobs}" == "true" ]] && (( pending_count > 0 )) && (( idle_sec >= timeout_sec )); then
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription queue guard pause: strict profile selected but run-agent lane progress stopped for ${timeout_sec}s (pending=${pending_count}/${total}, started=${started_count}, completed=${completed_count}). Task is paused; processing label was cleared."
              gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
              gh run cancel "${GITHUB_RUN_ID}" --repo "${GITHUB_REPOSITORY}" || true
              exit 0
            fi
            sleep "${interval_sec}"
            elapsed=$((elapsed + interval_sec))
          done

          if [[ "${saw_jobs}" != "true" ]]; then
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription queue guard pause: strict profile selected but run-agent lanes were not materialized within ${max_watch_sec}s. Task is paused; processing label was cleared."
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
            gh run cancel "${GITHUB_RUN_ID}" --repo "${GITHUB_REPOSITORY}" || true
            exit 0
          fi

          final_jobs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}/jobs?per_page=100" 2>/dev/null || echo '{}')"
          final_total="$(echo "${final_jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents"))] | length' 2>/dev/null || echo "0")"
          final_started="$(echo "${final_jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and (((.steps // []) | length) > 0))] | length' 2>/dev/null || echo "0")"
          final_completed="$(echo "${final_jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and ((.conclusion // "") != ""))] | length' 2>/dev/null || echo "0")"
          final_pending="$(echo "${final_jobs_json}" | jq '[.jobs[]? | select((.name // "") | contains("run-agents") and (((.steps // []) | length) == 0) and ((.conclusion // "") == ""))] | length' 2>/dev/null || echo "0")"
          if [[ "${saw_jobs}" == "true" ]] && (( final_total == 0 )); then
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription queue guard pause: strict profile selected but run-agent lane inventory became unreadable (expected_lanes=${expected_lanes}, observed_total=${final_total}). Task is paused; processing label was cleared."
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
            gh run cancel "${GITHUB_RUN_ID}" --repo "${GITHUB_REPOSITORY}" || true
            exit 0
          fi
          if (( expected_lanes > 0 && final_total < expected_lanes )); then
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription queue guard pause: strict profile selected but run-agent lanes were only partially materialized (expected=${expected_lanes}, observed=${final_total}, started=${final_started}, completed=${final_completed}). Task is paused; processing label was cleared."
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
            gh run cancel "${GITHUB_RUN_ID}" --repo "${GITHUB_REPOSITORY}" || true
            exit 0
          fi
          if (( final_total > 0 && final_pending > 0 && final_started == 0 )); then
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription queue guard pause: strict profile selected but run-agent lanes remained unstarted after guard window (pending=${final_pending}/${final_total}, started=${final_started}). Task is paused; processing label was cleared."
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
            gh run cancel "${GITHUB_RUN_ID}" --repo "${GITHUB_REPOSITORY}" || true
            exit 0
          fi

          echo "Queue guard timed out without confirmed stall (max_watch_sec=${max_watch_sec}, idle_sec=${idle_sec}, final_total=${final_total}, expected_lanes=${expected_lanes}, final_pending=${final_pending}, final_started=${final_started}, final_completed=${final_completed})."

  integrate:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, resolve-orchestrator, run-agents]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      high_risk: ${{ steps.integrate.outputs.high_risk }}
      approve_count: ${{ steps.integrate.outputs.approve_count }}
      total_count: ${{ steps.integrate.outputs.total_count }}
      threshold: ${{ steps.integrate.outputs.threshold }}
      weighted_approve_score: ${{ steps.integrate.outputs.weighted_approve_score }}
      weighted_total_score: ${{ steps.integrate.outputs.weighted_total_score }}
      weighted_threshold: ${{ steps.integrate.outputs.weighted_threshold }}
      weighted_vote_passed: ${{ steps.integrate.outputs.weighted_vote_passed }}
      vote_passed: ${{ steps.integrate.outputs.vote_passed }}
      ok_to_execute: ${{ steps.integrate.outputs.ok_to_execute }}

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: agent-result-*
          path: agent-results
          merge-multiple: true

      - name: Integrate results with jq rules
        id: integrate
        env:
          ASSIST_PROVIDER_RESOLVED: ${{ needs.resolve-orchestrator.outputs.assist_provider }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          REQUIRE_DIRECT_CLAUDE_ASSIST: ${{ vars.FUGUE_REQUIRE_DIRECT_CLAUDE_ASSIST || 'false' }}
          REQUIRE_CLAUDE_SUB_ON_COMPLEX: ${{ vars.FUGUE_REQUIRE_CLAUDE_SUB_ON_COMPLEX || 'true' }}
          INPUT_RISK_TIER: ${{ inputs.risk_tier }}
          INPUT_AMBIGUITY_TRANSLATION_GATE: ${{ inputs.ambiguity_translation_gate }}
          INPUT_AMBIGUITY_TRANSLATION_SCORE: ${{ inputs.ambiguity_translation_score }}
          INPUT_CLAUDE_SUB_TRIGGER: ${{ inputs.claude_sub_trigger }}
        run: |
          set -euo pipefail

          jq -s '.' agent-results/*.json > all-results.json

          total_count="$(jq '[.[] | select(.skipped != true)] | length' all-results.json)"
          approve_count="$(jq '[.[] | select(.skipped != true and .approve == true)] | length' all-results.json)"
          high_risk_count="$(jq '[.[] | select(.skipped != true and (.risk|ascii_upcase) == "HIGH")] | length' all-results.json)"
          high_risk="false"
          if [[ "${high_risk_count}" -gt 0 ]]; then
            high_risk="true"
          fi
          assist_provider_resolved="$(echo "${ASSIST_PROVIDER_RESOLVED:-none}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${assist_provider_resolved}" != "claude" && "${assist_provider_resolved}" != "codex" && "${assist_provider_resolved}" != "none" ]]; then
            assist_provider_resolved="none"
          fi
          claude_state="$(echo "${CLAUDE_RATE_LIMIT_STATE:-ok}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_state}" != "ok" && "${claude_state}" != "degraded" && "${claude_state}" != "exhausted" ]]; then
            claude_state="ok"
          fi
          require_direct_claude_assist="$(echo "${REQUIRE_DIRECT_CLAUDE_ASSIST:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${require_direct_claude_assist}" != "true" ]]; then
            require_direct_claude_assist="false"
          fi
          require_claude_sub_on_complex="$(echo "${REQUIRE_CLAUDE_SUB_ON_COMPLEX:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${require_claude_sub_on_complex}" != "false" ]]; then
            require_claude_sub_on_complex="true"
          fi
          input_risk_tier="$(echo "${INPUT_RISK_TIER:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${input_risk_tier}" != "low" && "${input_risk_tier}" != "medium" && "${input_risk_tier}" != "high" ]]; then
            input_risk_tier=""
          fi
          ambiguity_translation_gate="$(echo "${INPUT_AMBIGUITY_TRANSLATION_GATE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ambiguity_translation_gate}" != "true" ]]; then
            ambiguity_translation_gate="false"
          fi
          ambiguity_translation_score="$(echo "${INPUT_AMBIGUITY_TRANSLATION_SCORE:-0}" | tr -cd '0-9')"
          if [[ -z "${ambiguity_translation_score}" ]]; then
            ambiguity_translation_score="0"
          fi
          claude_sub_trigger="$(echo "${INPUT_CLAUDE_SUB_TRIGGER:-none}" | tr '\n\r' ' ' | sed -E 's/[[:space:]]+/ /g; s/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${claude_sub_trigger}" ]]; then
            claude_sub_trigger="none"
          fi
          complex_claude_sub_required="false"
          complex_claude_sub_reason="not-required"
          if [[ "${require_claude_sub_on_complex}" == "true" ]]; then
            if [[ "${assist_provider_resolved}" != "claude" ]]; then
              complex_claude_sub_reason="complex-policy-assist-${assist_provider_resolved}"
            elif [[ "${input_risk_tier}" == "high" ]]; then
              complex_claude_sub_required="true"
              complex_claude_sub_reason="risk-high"
            elif [[ "${ambiguity_translation_gate}" == "true" ]]; then
              complex_claude_sub_required="true"
              complex_claude_sub_reason="ambiguity-translation-gate(score=${ambiguity_translation_score},trigger=${claude_sub_trigger})"
            else
              complex_claude_sub_reason="complex-not-required"
            fi
          else
            complex_claude_sub_reason="complex-policy-disabled"
          fi
          claude_opus_lane_total="$(jq '[.[] | select(.name == "claude-opus-assist")] | length' all-results.json)"
          claude_opus_lane_success="$(jq '[
            .[] | select(
              .name == "claude-opus-assist"
              and .skipped != true
              and ((.provider // "" | ascii_downcase) == "claude")
              and (
                ((.http_code // "" | tostring) == "200")
                or
                ((.http_code // "" | tostring | startswith("cli:0")))
              )
            )
          ] | length' all-results.json)"
          gate_required="false"
          gate_requirement_kind="none"
          if [[ "${complex_claude_sub_required}" == "true" ]]; then
            gate_required="true"
            gate_requirement_kind="complex"
          fi
          if [[ "${assist_provider_resolved}" == "claude" && "${claude_state}" == "ok" && "${require_direct_claude_assist}" == "true" ]]; then
            gate_required="true"
            if [[ "${gate_requirement_kind}" == "complex" ]]; then
              gate_requirement_kind="complex+direct"
            else
              gate_requirement_kind="direct"
            fi
          fi
          required_claude_assist_gate="not-required"
          required_claude_assist_reason="none"
          if [[ "${gate_required}" == "true" ]]; then
            required_claude_assist_gate="pass"
            required_claude_assist_reason="${gate_requirement_kind}-ok"
            if [[ "${assist_provider_resolved}" != "claude" ]]; then
              required_claude_assist_gate="fail"
              required_claude_assist_reason="${gate_requirement_kind}-assist-${assist_provider_resolved}"
            elif [[ "${claude_state}" == "exhausted" ]]; then
              required_claude_assist_gate="fail"
              required_claude_assist_reason="${gate_requirement_kind}-claude-rate-limit-exhausted"
            elif [[ "${claude_opus_lane_total}" -eq 0 ]]; then
              required_claude_assist_gate="fail"
              required_claude_assist_reason="${gate_requirement_kind}-missing-claude-opus-assist-lane"
            elif [[ "${claude_opus_lane_success}" -eq 0 ]]; then
              required_claude_assist_gate="fail"
              required_claude_assist_reason="${gate_requirement_kind}-claude-opus-assist-not-success"
            fi
            if [[ "${required_claude_assist_gate}" == "fail" ]]; then
              high_risk="true"
              high_risk_count="$((high_risk_count + 1))"
            fi
          else
            if [[ "${assist_provider_resolved}" == "claude" && "${claude_state}" != "ok" ]]; then
              required_claude_assist_reason="claude-rate-limit-${claude_state}"
            elif [[ "${complex_claude_sub_required}" != "true" && "${require_claude_sub_on_complex}" == "true" ]]; then
              required_claude_assist_reason="${complex_claude_sub_reason}"
            elif [[ "${require_direct_claude_assist}" != "true" ]]; then
              required_claude_assist_reason="direct-policy-disabled"
            else
              required_claude_assist_reason="policy-disabled"
            fi
          fi

          if [[ "${total_count}" -eq 0 ]]; then
            threshold=1
          else
            threshold=$(( (total_count * 2 + 2) / 3 )) # ceil(2/3 * total)
          fi
          weighted_total_score="$(jq -r '
            [ .[] | select(.skipped != true) |
              (if (.agent_role|test("security-analyst";"i")) then 1.4
               elif (.agent_role|test("code-reviewer";"i")) then 1.2
               elif (.agent_role|test("architect";"i")) then 1.1
               elif (.agent_role|test("reliability-engineer|invariants-checker";"i")) then 1.1
               elif (.agent_role|test("general-reviewer|plan-reviewer|general-critic";"i")) then 1.0
               elif (.agent_role|test("refactor-advisor";"i")) then 0.9
               elif (.agent_role|test("math-reasoning|orchestration-assistant|main-orchestrator|ui-reviewer";"i")) then 0.8
               elif (.agent_role|test("realtime-info";"i")) then 0.7
               else 1.0 end)
            ] | add // 0
          ' all-results.json)"
          weighted_approve_score="$(jq -r '
            [ .[] | select(.skipped != true and .approve == true) |
              (if (.agent_role|test("security-analyst";"i")) then 1.4
               elif (.agent_role|test("code-reviewer";"i")) then 1.2
               elif (.agent_role|test("architect";"i")) then 1.1
               elif (.agent_role|test("reliability-engineer|invariants-checker";"i")) then 1.1
               elif (.agent_role|test("general-reviewer|plan-reviewer|general-critic";"i")) then 1.0
               elif (.agent_role|test("refactor-advisor";"i")) then 0.9
               elif (.agent_role|test("math-reasoning|orchestration-assistant|main-orchestrator|ui-reviewer";"i")) then 0.8
               elif (.agent_role|test("realtime-info";"i")) then 0.7
               else 1.0 end)
            ] | add // 0
          ' all-results.json)"
          weighted_threshold="$(awk -v total="${weighted_total_score}" 'BEGIN {printf "%.3f", (2*total)/3}')"
          weighted_vote_passed="$(awk -v approve="${weighted_approve_score}" -v threshold="${weighted_threshold}" 'BEGIN { if (approve + 1e-9 >= threshold) print "true"; else print "false" }')"
          ok_to_execute="false"
          if [[ "${required_claude_assist_gate}" == "fail" ]]; then
            weighted_vote_passed="false"
          fi
          if [[ "${weighted_vote_passed}" == "true" && "${high_risk}" != "true" ]]; then
            ok_to_execute="true"
          fi

          jq '
            {
              adopted_security_criticism: [
                .[] | select(.skipped != true and (.agent_role|test("security";"i")) and ((.findings|length) > 0)) |
                {agent: .name, findings: .findings, recommendation: .recommendation}
              ],
              high_confidence: {
                approve_agreement: (([.[] | select(.skipped != true and .approve == true)] | length) >= 3),
                reject_agreement: (([.[] | select(.skipped != true and .approve != true)] | length) >= 3)
              },
              considerations: (
                [ .[] | select(.skipped != true) | .findings[] ] | group_by(.) | map(select(length == 1) | .[0])
              ),
              contradictions: (
                ([.[] | select(.skipped != true and .approve == true)] | length) > 0 and
                ([.[] | select(.skipped != true and .approve != true)] | length) > 0
              ),
              by_agent: [ .[] | select(.skipped != true) | {name, provider, execution_engine, agent_role, risk, approve, findings, recommendation, rationale} ]
            }
          ' all-results.json > integrated.json

          {
            echo "high_risk=${high_risk}"
            echo "approve_count=${approve_count}"
            echo "total_count=${total_count}"
            echo "threshold=${threshold}"
            echo "weighted_approve_score=${weighted_approve_score}"
            echo "weighted_total_score=${weighted_total_score}"
            echo "weighted_threshold=${weighted_threshold}"
            echo "weighted_vote_passed=${weighted_vote_passed}"
            echo "vote_passed=${weighted_vote_passed}"
            echo "ok_to_execute=${ok_to_execute}"
          } >> "${GITHUB_OUTPUT}"

          approve_agents="$(jq -r '[.[] | select(.skipped != true and .approve == true) | .name] | join(", ")' all-results.json)"
          reject_agents="$(jq -r '[.[] | select(.skipped != true and .approve != true) | .name] | join(", ")' all-results.json)"
          security_block="$(jq -r '
            [.adopted_security_criticism[]? |
              "- **\(.agent)**\n  - findings: \(.findings | join(" | "))\n  - recommendation: \(.recommendation)"
            ] | if length==0 then "- none" else join("\n") end
          ' integrated.json)"
          one_agent_points="$(jq -r '
            .considerations | if length==0 then "- none" else map("- " + .) | join("\n") end
          ' integrated.json)"
          contradiction_flag="$(jq -r '.contradictions' integrated.json)"
          contradiction_section="- none"
          if [[ "${contradiction_flag}" == "true" ]]; then
            contradiction_section="Approve side: ${approve_agents}
          Reject side: ${reject_agents}"
          fi
          skipped_agents="$(jq -r '
            [ .[] | select(.skipped == true) |
              "- \(.name) [\(.provider)/\(.execution_engine // "api")] (http=\(.http_code)): \((.findings | join(" | ")))"
            ] | if length==0 then "- none" else join("\n") end
          ' all-results.json)"
          main_fallback_section="- main fallback: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.main_claude_fallback_applied }}" == "true" ]]; then
            main_fallback_section="- main fallback: claude -> codex (\`${{ needs.resolve-orchestrator.outputs.main_claude_fallback_reason }}\`)"
          fi
          assist_fallback_section="- assist fallback: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.assist_claude_fallback_applied }}" == "true" ]]; then
            assist_fallback_reason="${{ needs.resolve-orchestrator.outputs.assist_claude_fallback_reason }}"
            assist_fallback_target="none"
            if [[ "${assist_fallback_reason}" == *"->"* ]]; then
              assist_fallback_target="${assist_fallback_reason##*->}"
            fi
            assist_fallback_target="$(echo "${assist_fallback_target}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-].*$//g')"
            if [[ -z "${assist_fallback_target}" ]]; then
              assist_fallback_target="none"
            fi
            assist_fallback_section="- assist fallback: claude -> ${assist_fallback_target} (\`${assist_fallback_reason}\`)"
          fi
          claude_pressure_section="- claude pressure guard: none"
          if [[ "${{ needs.resolve-orchestrator.outputs.claude_pressure_guard_applied }}" == "true" ]]; then
            claude_pressure_section="- claude pressure guard: applied (\`${{ needs.resolve-orchestrator.outputs.claude_pressure_guard_reason }}\`)"
          fi
          required_assist_section="- required claude assist gate: not-required"
          if [[ "${required_claude_assist_gate}" == "pass" ]]; then
            required_assist_section="- required claude assist gate: pass (\`${required_claude_assist_reason}\`)"
          elif [[ "${required_claude_assist_gate}" == "fail" ]]; then
            required_assist_section="- required claude assist gate: fail (\`${required_claude_assist_reason}\`)"
          fi
          complex_assist_section="- complex claude-sub requirement: ${complex_claude_sub_required} (\`${complex_claude_sub_reason}\`)"
          integrated_meta="$(jq -cn \
            --arg schema "fugue-integrated-meta/v1" \
            --arg run_id "${GITHUB_RUN_ID}" \
            --arg issue_number "${{ needs.prepare.outputs.issue_number }}" \
            --arg main "${{ needs.resolve-orchestrator.outputs.main_provider }}" \
            --arg assist "${{ needs.resolve-orchestrator.outputs.assist_provider }}" \
            --arg multi_agent_mode "${{ needs.resolve-orchestrator.outputs.multi_agent_mode }}" \
            --arg glm_subagent_mode "${{ needs.resolve-orchestrator.outputs.glm_subagent_mode }}" \
            --arg profile "${{ needs.resolve-orchestrator.outputs.execution_profile }}" \
            --arg runner "${{ needs.resolve-orchestrator.outputs.run_agents_runner }}" \
            --arg runner_labels "${{ needs.resolve-orchestrator.outputs.run_agents_runner_json }}" \
            --arg lanes "${{ needs.resolve-orchestrator.outputs.expected_lanes }}" \
            --arg weighted_vote "${weighted_vote_passed}" \
            --arg high_risk "${high_risk}" \
            --arg required_claude_assist_gate "${required_claude_assist_gate}" \
            --arg required_claude_assist_reason "${required_claude_assist_reason}" \
            --arg complex_claude_sub_required "${complex_claude_sub_required}" \
            --arg complex_claude_sub_reason "${complex_claude_sub_reason}" \
            '{
              schema:$schema,
              run_id:$run_id,
              issue_number:$issue_number,
              main_orchestrator_resolved:$main,
              assist_orchestrator_resolved:$assist,
              multi_agent_mode:$multi_agent_mode,
              glm_subagent_mode:$glm_subagent_mode,
              execution_profile:$profile,
              run_agents_runner:$runner,
              run_agents_runner_labels:(try ($runner_labels | fromjson) catch []),
              lanes_configured:($lanes | tonumber? // 0),
              weighted_vote_passed:($weighted_vote == "true"),
              high_risk:($high_risk == "true"),
              required_claude_assist_gate:$required_claude_assist_gate,
              required_claude_assist_reason:$required_claude_assist_reason,
              complex_claude_sub_required:($complex_claude_sub_required == "true"),
              complex_claude_sub_reason:$complex_claude_sub_reason
            }'
          )"

          cat > integrated-comment.md <<COMMENT_EOF
          ## Tutti Integrated Review

          - main orchestrator requested: ${{ needs.resolve-orchestrator.outputs.main_provider_requested }}
          - main orchestrator resolved: ${{ needs.resolve-orchestrator.outputs.main_provider }}
          - main orchestrator signal lane: ${{ needs.resolve-orchestrator.outputs.main_signal_lane }}
          - main orchestrator signal lanes: ${{ needs.resolve-orchestrator.outputs.main_signal_lanes }}
          - assist orchestrator requested: ${{ needs.resolve-orchestrator.outputs.assist_provider_requested }}
          - assist orchestrator resolved: ${{ needs.resolve-orchestrator.outputs.assist_provider }}
          - multi-agent mode: ${{ needs.resolve-orchestrator.outputs.multi_agent_mode }}
          - multi-agent mode source: ${{ needs.resolve-orchestrator.outputs.multi_agent_mode_source }}
          - glm subagent mode: ${{ needs.resolve-orchestrator.outputs.glm_subagent_mode }}
          - glm subagent mode source: ${{ needs.resolve-orchestrator.outputs.glm_subagent_mode_source }}
          - ci execution engine: ${{ needs.resolve-orchestrator.outputs.ci_execution_engine }}
          - subscription offline policy: ${{ needs.resolve-orchestrator.outputs.subscription_offline_policy }}
          - run-agents runner: ${{ needs.resolve-orchestrator.outputs.run_agents_runner }}
          - run-agents runner labels: ${{ needs.resolve-orchestrator.outputs.run_agents_runner_json }}
          - execution profile: ${{ needs.resolve-orchestrator.outputs.execution_profile }} (\`${{ needs.resolve-orchestrator.outputs.execution_profile_reason }}\`)
          - continuity active: ${{ needs.resolve-orchestrator.outputs.continuity_active }}
          - self-hosted online count: ${{ needs.resolve-orchestrator.outputs.self_hosted_online_count }}
          - required subscription runner label: ${{ needs.resolve-orchestrator.outputs.subscription_runner_label }}
          - strict main codex model effective: ${{ needs.resolve-orchestrator.outputs.strict_main_codex_model_effective }}
          - strict opus assist direct effective: ${{ needs.resolve-orchestrator.outputs.strict_opus_assist_direct_effective }}
          - assist adjusted by execution profile: ${{ needs.resolve-orchestrator.outputs.assist_adjusted_by_execution_profile }} (\`${{ needs.resolve-orchestrator.outputs.assist_adjustment_reason }}\`)
          ${main_fallback_section}
          ${assist_fallback_section}
          ${claude_pressure_section}
          ${complex_assist_section}
          ${required_assist_section}
          - lanes configured: ${{ needs.resolve-orchestrator.outputs.expected_lanes }}

          **Rule a: Security criticism (unconditionally adopted)**
          ${security_block}

          **Rule b: 3+ agents agree (high confidence)**
          - approve agreement (>=3): $(jq -r '.high_confidence.approve_agreement' integrated.json)
          - reject agreement (>=3): $(jq -r '.high_confidence.reject_agreement' integrated.json)

          **Rule c: Single-agent points (consideration)**
          ${one_agent_points}

          **Rule d: Contradictions (present both sides)**
          ${contradiction_section}

          **Optional lanes skipped**
          ${skipped_agents}

          **Consensus summary**
          - approvals: ${approve_count}/${total_count}
          - weighted approvals: ${weighted_approve_score}/${weighted_total_score} (threshold: ${weighted_threshold})
          - weighted vote passed: ${weighted_vote_passed}
          - high-risk findings: ${high_risk_count}
          - approving agents: ${approve_agents}
          - non-approving agents: ${reject_agents}

          <!-- FUGUE_INTEGRATED_META:${integrated_meta} -->
          COMMENT_EOF

      - name: Post integrated comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh issue comment "${{ needs.prepare.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --body-file integrated-comment.md

  finalize:
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare, integrate]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Apply Tier 2 decision and labels
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.prepare.outputs.issue_number }}
          HAS_IMPLEMENT_REQUEST: ${{ needs.prepare.outputs.has_implement_request }}
          HIGH_RISK: ${{ needs.integrate.outputs.high_risk }}
          APPROVE_COUNT: ${{ needs.integrate.outputs.approve_count }}
          TOTAL_COUNT: ${{ needs.integrate.outputs.total_count }}
          THRESHOLD: ${{ needs.integrate.outputs.threshold }}
          WEIGHTED_APPROVE_SCORE: ${{ needs.integrate.outputs.weighted_approve_score }}
          WEIGHTED_TOTAL_SCORE: ${{ needs.integrate.outputs.weighted_total_score }}
          WEIGHTED_THRESHOLD: ${{ needs.integrate.outputs.weighted_threshold }}
          WEIGHTED_VOTE_PASSED: ${{ needs.integrate.outputs.weighted_vote_passed }}
        run: |
          set -euo pipefail

          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "processing" || true
          gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --remove-label "completed" --remove-label "needs-review" --remove-label "needs-human" || true

          if [[ "${HIGH_RISK}" == "true" ]]; then
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-human"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tier 2 consensus: HIGH risk detected. Escalated to human review."
            exit 0
          fi

          if [[ "${WEIGHTED_VOTE_PASSED}" == "true" ]]; then
            if [[ "${HAS_IMPLEMENT_REQUEST}" == "true" ]]; then
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote passed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}. weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Approved to execute; implementation may proceed."
            else
              gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "completed"
              gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote passed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}. weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Auto-execution approved."
              gh issue close "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}"
            fi
          else
            gh issue edit "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --add-label "needs-review"
            gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti weighted vote failed. approval count: ${APPROVE_COUNT}/${TOTAL_COUNT}, weighted: ${WEIGHTED_APPROVE_SCORE}/${WEIGHTED_TOTAL_SCORE} (threshold ${WEIGHTED_THRESHOLD}). Marked for review."
          fi

  resolve-orchestrator:
    # Allow bot-triggered workflow_dispatch (from task-router handoff) to resolve
    # the matrix; otherwise run-agents/integrate/finalize are skipped.
    if: ${{ needs.prepare.outputs.should_run == 'true' && needs.prepare.outputs.trusted == 'true' }}
    needs: [prepare]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      provider: ${{ steps.resolve.outputs.main_provider }}
      provider_requested: ${{ steps.resolve.outputs.main_provider_requested }}
      multi_agent_mode: ${{ steps.resolve.outputs.multi_agent_mode }}
      multi_agent_mode_source: ${{ steps.resolve.outputs.multi_agent_mode_source }}
      glm_subagent_mode: ${{ steps.resolve.outputs.glm_subagent_mode }}
      glm_subagent_mode_source: ${{ steps.resolve.outputs.glm_subagent_mode_source }}
      claude_fallback_applied: ${{ steps.resolve.outputs.main_claude_fallback_applied }}
      claude_fallback_reason: ${{ steps.resolve.outputs.main_claude_fallback_reason }}
      main_provider: ${{ steps.resolve.outputs.main_provider }}
      main_provider_requested: ${{ steps.resolve.outputs.main_provider_requested }}
      main_claude_fallback_applied: ${{ steps.resolve.outputs.main_claude_fallback_applied }}
      main_claude_fallback_reason: ${{ steps.resolve.outputs.main_claude_fallback_reason }}
      assist_provider: ${{ steps.resolve.outputs.assist_provider }}
      assist_provider_requested: ${{ steps.resolve.outputs.assist_provider_requested }}
      assist_claude_fallback_applied: ${{ steps.resolve.outputs.assist_claude_fallback_applied }}
      assist_claude_fallback_reason: ${{ steps.resolve.outputs.assist_claude_fallback_reason }}
      claude_pressure_guard_applied: ${{ steps.resolve.outputs.claude_pressure_guard_applied }}
      claude_pressure_guard_reason: ${{ steps.resolve.outputs.claude_pressure_guard_reason }}
      ci_execution_engine: ${{ steps.resolve.outputs.ci_execution_engine }}
      run_agents_runner: ${{ steps.resolve.outputs.run_agents_runner }}
      run_agents_runner_json: ${{ steps.resolve.outputs.run_agents_runner_json }}
      execution_profile: ${{ steps.resolve.outputs.execution_profile }}
      execution_profile_reason: ${{ steps.resolve.outputs.execution_profile_reason }}
      continuity_active: ${{ steps.resolve.outputs.continuity_active }}
      self_hosted_online_count: ${{ steps.resolve.outputs.self_hosted_online_count }}
      subscription_runner_label: ${{ steps.resolve.outputs.subscription_runner_label }}
      strict_main_codex_model_effective: ${{ steps.resolve.outputs.strict_main_codex_model_effective }}
      strict_opus_assist_direct_effective: ${{ steps.resolve.outputs.strict_opus_assist_direct_effective }}
      subscription_offline_policy: ${{ steps.resolve.outputs.subscription_offline_policy }}
      assist_adjusted_by_execution_profile: ${{ steps.resolve.outputs.assist_adjusted_by_execution_profile }}
      assist_adjustment_reason: ${{ steps.resolve.outputs.assist_adjustment_reason }}
      main_signal_lane: ${{ steps.resolve.outputs.main_signal_lane }}
      main_signal_lanes: ${{ steps.resolve.outputs.main_signal_lanes }}
      expected_lanes: ${{ steps.resolve.outputs.expected_lanes }}
      agent_matrix: ${{ steps.resolve.outputs.agent_matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          repository: cursorvers/fugue-orchestrator
          path: .fugue-orchestrator

      - name: Resolve orchestrator profile and lane matrix
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
          REQUESTED_PROVIDER: ${{ inputs.main_orchestrator_provider || inputs.orchestrator_provider }}
          REQUESTED_ASSIST_PROVIDER: ${{ inputs.assist_orchestrator_provider }}
          FORCE_CLAUDE: ${{ inputs.force_claude }}
          MULTI_AGENT_MODE_OVERRIDE: ${{ inputs.multi_agent_mode_override }}
          MULTI_AGENT_MODE_LOCK: ${{ inputs.multi_agent_mode_lock }}
          DEFAULT_MAIN_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_MAIN_ORCHESTRATOR_PROVIDER || vars.FUGUE_ORCHESTRATOR_PROVIDER || 'codex' }}
          DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_ASSIST_ORCHESTRATOR_PROVIDER || 'claude' }}
          CODEX_MAIN_MODEL: ${{ vars.FUGUE_CODEX_MAIN_MODEL || 'gpt-5-codex' }}
          CODEX_MULTI_AGENT_MODEL: ${{ vars.FUGUE_CODEX_MULTI_AGENT_MODEL || 'gpt-5.3-codex-spark' }}
          MULTI_AGENT_MODE: ${{ vars.FUGUE_MULTI_AGENT_MODE || 'standard' }}
          GLM_SUBAGENT_MODE: ${{ vars.FUGUE_GLM_SUBAGENT_MODE || 'paired' }}
          CLAUDE_OPUS_MODEL: ${{ vars.FUGUE_CLAUDE_OPUS_MODEL || 'claude-sonnet-4-6' }}
          CLAUDE_SONNET4_MODEL: ${{ vars.FUGUE_CLAUDE_SONNET4_MODEL || 'claude-sonnet-4-6' }}
          CLAUDE_SONNET6_MODEL: ${{ vars.FUGUE_CLAUDE_SONNET6_MODEL || 'claude-sonnet-4-6' }}
          GEMINI_MODEL: ${{ vars.FUGUE_GEMINI_MODEL || 'gemini-3.1-pro' }}
          XAI_MODEL: ${{ vars.FUGUE_XAI_MODEL || 'grok-4' }}
          ALLOW_GLM_IN_SUBSCRIPTION: ${{ vars.FUGUE_ALLOW_GLM_IN_SUBSCRIPTION || 'true' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          CLAUDE_MAIN_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_MAIN_ASSIST_POLICY || 'codex' }}
          CLAUDE_ROLE_POLICY: ${{ vars.FUGUE_CLAUDE_ROLE_POLICY || 'flex' }}
          CLAUDE_DEGRADED_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_DEGRADED_ASSIST_POLICY || 'claude' }}
          DUAL_MAIN_SIGNAL: ${{ vars.FUGUE_DUAL_MAIN_SIGNAL || '' }}
          CI_EXECUTION_ENGINE: ${{ vars.FUGUE_CI_EXECUTION_ENGINE || 'subscription' }}
          STRICT_MAIN_CODEX_MODEL: ${{ vars.FUGUE_STRICT_MAIN_CODEX_MODEL || 'false' }}
          STRICT_OPUS_ASSIST_DIRECT: ${{ vars.FUGUE_STRICT_OPUS_ASSIST_DIRECT || 'false' }}
          SUBSCRIPTION_OFFLINE_POLICY: ${{ vars.FUGUE_SUBSCRIPTION_OFFLINE_POLICY || 'continuity' }}
          SUBSCRIPTION_RUNNER_LABEL: ${{ vars.FUGUE_SUBSCRIPTION_RUNNER_LABEL || 'fugue-subscription' }}
          API_STRICT_MODE: ${{ vars.FUGUE_API_STRICT_MODE || 'false' }}
          EMERGENCY_CONTINUITY_MODE: ${{ vars.FUGUE_EMERGENCY_CONTINUITY_MODE || 'false' }}
          EMERGENCY_ASSIST_POLICY: ${{ vars.FUGUE_EMERGENCY_ASSIST_POLICY || 'none' }}
          MIN_CONSENSUS_LANES: ${{ vars.FUGUE_MIN_CONSENSUS_LANES || '6' }}
          HAS_ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY != '' }}
          HAS_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY != '' }}
          ISSUE_TITLE: ${{ needs.prepare.outputs.issue_title }}
          ISSUE_BODY: ${{ needs.prepare.outputs.issue_body }}
        run: |
          set -euo pipefail

          orchestrator_lib_dir=".fugue-orchestrator/scripts/lib"
          if [[ ! -d "${orchestrator_lib_dir}" ]]; then
            orchestrator_lib_dir="scripts/lib"
          fi

          force_claude="$(echo "${FORCE_CLAUDE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${force_claude}" != "true" ]]; then
            force_claude="false"
          fi

          eval "$(
            bash "${orchestrator_lib_dir}/orchestrator-policy.sh" \
              --main "${REQUESTED_PROVIDER}" \
              --assist "${REQUESTED_ASSIST_PROVIDER}" \
              --default-main "${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER}" \
              --default-assist "${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER}" \
              --claude-state "${CLAUDE_RATE_LIMIT_STATE}" \
              --force-claude "${force_claude}" \
              --assist-policy "${CLAUDE_MAIN_ASSIST_POLICY}" \
              --claude-role-policy "${CLAUDE_ROLE_POLICY}" \
              --degraded-assist-policy "${CLAUDE_DEGRADED_ASSIST_POLICY}"
          )"

          main_provider_requested="${requested_main}"
          assist_provider_requested="${requested_assist}"
          main_provider="${resolved_main}"
          assist_provider="${resolved_assist}"
          main_claude_fallback_applied="${main_fallback_applied}"
          main_claude_fallback_reason="${main_fallback_reason}"
          assist_claude_fallback_applied="${assist_fallback_applied}"
          assist_claude_fallback_reason="${assist_fallback_reason}"
          claude_pressure_guard_applied="${pressure_guard_applied}"
          claude_pressure_guard_reason="${pressure_guard_reason}"

          text="$(printf '%s\n%s\n' "${ISSUE_TITLE}" "${ISSUE_BODY}" | tr '[:upper:]' '[:lower:]')"
          ci_execution_engine="$(echo "${CI_EXECUTION_ENGINE:-subscription}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ci_execution_engine}" != "harness" && "${ci_execution_engine}" != "api" && "${ci_execution_engine}" != "subscription" ]]; then
            ci_execution_engine="subscription"
          fi
          strict_main_requested="$(echo "${STRICT_MAIN_CODEX_MODEL:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${strict_main_requested}" != "true" ]]; then
            strict_main_requested="false"
          fi
          strict_opus_requested="$(echo "${STRICT_OPUS_ASSIST_DIRECT:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${strict_opus_requested}" != "true" ]]; then
            strict_opus_requested="false"
          fi
          subscription_offline_policy="$(echo "${SUBSCRIPTION_OFFLINE_POLICY:-continuity}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${subscription_offline_policy}" != "hold" && "${subscription_offline_policy}" != "continuity" ]]; then
            subscription_offline_policy="continuity"
          fi
          api_strict_mode="$(echo "${API_STRICT_MODE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${api_strict_mode}" != "true" ]]; then
            api_strict_mode="false"
          fi
          emergency_continuity_mode="$(echo "${EMERGENCY_CONTINUITY_MODE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${emergency_continuity_mode}" != "true" ]]; then
            emergency_continuity_mode="false"
          fi
          emergency_assist_policy="$(echo "${EMERGENCY_ASSIST_POLICY:-none}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${emergency_assist_policy}" != "none" && "${emergency_assist_policy}" != "codex" && "${emergency_assist_policy}" != "claude" ]]; then
            emergency_assist_policy="none"
          fi
          subscription_runner_label="$(echo "${SUBSCRIPTION_RUNNER_LABEL:-fugue-subscription}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${subscription_runner_label}" ]]; then
            subscription_runner_label="fugue-subscription"
          fi
          self_hosted_online_count="0"
          self_hosted_online="false"
          if [[ "${ci_execution_engine}" == "subscription" ]]; then
            runners_endpoint="repos/${GITHUB_REPOSITORY}/actions/runners?per_page=100"
            runners_json="$(gh_api_retry "${runners_endpoint}" 5 || echo '{}')"
            self_hosted_online_count="$(echo "${runners_json}" | jq -r --arg label "${subscription_runner_label}" '[.runners[]? | select(.status=="online" and .busy != true and ([.labels[]?.name] | index("self-hosted") != null) and ([.labels[]?.name] | index($label) != null))] | length' 2>/dev/null || echo "0")"
            self_hosted_online_count="$(echo "${self_hosted_online_count}" | tr -cd '0-9')"
            if [[ -z "${self_hosted_online_count}" ]]; then
              self_hosted_online_count="0"
            else
              self_hosted_online_count="$((10#${self_hosted_online_count}))"
            fi
            if (( self_hosted_online_count > 0 )); then
              self_hosted_online="true"
            fi
          fi
          assist_before_execution_profile="${assist_provider}"
          eval "$(
            bash "${orchestrator_lib_dir}/execution-profile-policy.sh" \
              --requested-engine "${ci_execution_engine}" \
              --main-provider "${main_provider}" \
              --assist-provider "${assist_provider}" \
              --force-claude "${force_claude}" \
              --self-hosted-online "${self_hosted_online}" \
              --claude-state "${CLAUDE_RATE_LIMIT_STATE}" \
              --strict-main-requested "${strict_main_requested}" \
              --strict-opus-requested "${strict_opus_requested}" \
              --claude-direct-available "${HAS_ANTHROPIC_API_KEY}" \
              --codex-api-available "${HAS_OPENAI_API_KEY}" \
              --subscription-offline-policy "${subscription_offline_policy}" \
              --api-strict-mode "${api_strict_mode}" \
              --emergency-continuity-mode "${emergency_continuity_mode}" \
              --emergency-assist-policy "${emergency_assist_policy}"
          )"
          ci_execution_engine="${effective_engine}"
          strict_main_codex_model_effective="${strict_main_effective}"
          strict_opus_assist_direct_effective="${strict_opus_effective}"
          assist_adjusted_by_execution_profile="${assist_adjusted_by_profile}"
          assist_provider="${assist_provider_effective}"
          run_agents_runner_json='["ubuntu-latest"]'
          if [[ "${run_agents_runner}" == "self-hosted" ]]; then
            run_agents_runner_json="$(jq -cn --arg label "${subscription_runner_label}" '["self-hosted",$label]')"
          fi
          if [[ "${assist_before_execution_profile}" != "${assist_provider}" ]]; then
            assist_claude_fallback_applied="true"
            if [[ -n "${assist_adjustment_reason}" ]]; then
              assist_claude_fallback_reason="${assist_adjustment_reason}"
            fi
          fi
          multi_agent_mode="$(echo "${MULTI_AGENT_MODE:-standard}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          mode_override="$(echo "${MULTI_AGENT_MODE_OVERRIDE:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          mode_lock="$(echo "${MULTI_AGENT_MODE_LOCK:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          multi_agent_mode_source="repo-default"
          if [[ "${mode_lock}" != "true" ]]; then
            mode_lock="false"
          fi
          if [[ "${mode_override}" == "standard" || "${mode_override}" == "enhanced" || "${mode_override}" == "max" ]]; then
            multi_agent_mode="${mode_override}"
            multi_agent_mode_source="input-override"
          fi
          if [[ "${mode_lock}" != "true" ]]; then
            body_multi_agent_mode="$(printf '%s\n' "${ISSUE_BODY}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*multi[[:space:]_-]*agent[[:space:]]+mode[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
            if [[ -z "${body_multi_agent_mode}" ]]; then
              body_multi_agent_mode="$(echo "${ISSUE_BODY}" | sed -nE 's/^[[:space:]]*multi[[:space:]_-]*agent[[:space:]_-]*mode[[:space:]]*:[[:space:]]*(standard|enhanced|max|auto)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
            fi
            if [[ "${body_multi_agent_mode}" == "auto" ]]; then
              body_multi_agent_mode=""
            fi
            if [[ -n "${body_multi_agent_mode}" ]]; then
              multi_agent_mode="${body_multi_agent_mode}"
              multi_agent_mode_source="issue-body"
            fi
          fi
          if [[ "${multi_agent_mode_source}" == "repo-default" ]]; then
            heuristic_mode=""
            if echo "${text}" | grep -Eqi '(|||refactor|rewrite|migration|||)'; then
              heuristic_mode="max"
            elif echo "${text}" | grep -Eqi '(architecture|security|performance|concurrency|database|schema|workflow|ci|gha|infra|||)'; then
              heuristic_mode="enhanced"
            fi
            text_len="$(printf '%s' "${text}" | wc -c | tr -d ' ')"
            if [[ -z "${heuristic_mode}" ]]; then
              if (( text_len > 1400 )); then
                heuristic_mode="enhanced"
              elif (( text_len > 0 && text_len < 280 )); then
                heuristic_mode="standard"
              fi
            fi
            if [[ -n "${heuristic_mode}" ]]; then
              multi_agent_mode="${heuristic_mode}"
              multi_agent_mode_source="complexity-heuristic"
            fi
          fi
          if [[ "${multi_agent_mode}" != "standard" && "${multi_agent_mode}" != "enhanced" && "${multi_agent_mode}" != "max" ]]; then
            multi_agent_mode="standard"
            multi_agent_mode_source="repo-default"
          fi
          glm_subagent_mode="$(echo "${GLM_SUBAGENT_MODE:-paired}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          glm_subagent_mode_source="repo-default"
          if [[ "${glm_subagent_mode}" != "off" && "${glm_subagent_mode}" != "paired" && "${glm_subagent_mode}" != "symphony" ]]; then
            glm_subagent_mode="paired"
          fi
          allow_glm_in_subscription="$(echo "${ALLOW_GLM_IN_SUBSCRIPTION:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${allow_glm_in_subscription}" != "true" ]]; then
            allow_glm_in_subscription="false"
          fi
          if [[ "${mode_lock}" != "true" ]]; then
            body_glm_subagent_mode="$(printf '%s\n' "${ISSUE_BODY}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*glm[[:space:]_-]*subagent[[:space:]]+mode[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
            if [[ -z "${body_glm_subagent_mode}" ]]; then
              body_glm_subagent_mode="$(echo "${ISSUE_BODY}" | sed -nE 's/^[[:space:]]*glm[[:space:]_-]*subagent[[:space:]_-]*mode[[:space:]]*:[[:space:]]*(off|paired|symphony|auto)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
            fi
            if [[ "${body_glm_subagent_mode}" == "auto" ]]; then
              body_glm_subagent_mode=""
            fi
            if [[ "${body_glm_subagent_mode}" == "off" || "${body_glm_subagent_mode}" == "paired" || "${body_glm_subagent_mode}" == "symphony" ]]; then
              glm_subagent_mode="${body_glm_subagent_mode}"
              glm_subagent_mode_source="issue-body"
            fi
          fi
          if [[ "${glm_subagent_mode_source}" == "repo-default" && "${multi_agent_mode}" == "max" && "${glm_subagent_mode}" == "paired" ]]; then
            glm_subagent_mode="symphony"
            glm_subagent_mode_source="complexity-heuristic"
          fi
          if [[ "${ci_execution_engine}" == "subscription" && "${allow_glm_in_subscription}" != "true" && "${glm_subagent_mode}" != "off" ]]; then
            glm_subagent_mode="off"
            glm_subagent_mode_source="subscription-engine"
          fi
          wants_gemini="false"
          wants_xai="false"
          dual_main_signal_raw="$(echo "${DUAL_MAIN_SIGNAL:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${dual_main_signal_raw}" == "true" ]]; then
            dual_main_signal="true"
          elif [[ "${dual_main_signal_raw}" == "false" ]]; then
            dual_main_signal="false"
          elif [[ "${multi_agent_mode}" == "max" ]]; then
            # Keep high-risk mode redundant by default.
            dual_main_signal="true"
          else
            # Keep standard/enhanced mode lightweight by default.
            dual_main_signal="false"
          fi
          if [[ "${ci_execution_engine}" != "subscription" || "${allow_glm_in_subscription}" == "true" ]]; then
            if echo "${text}" | grep -Eqi '(ui|ux|ui[[:space:]]*design|ux[[:space:]]*design|figma|mockup|wireframe|screenshot|layout||||||pencil)'; then
              wants_gemini="true"
            fi
          fi
          if [[ "${ci_execution_engine}" != "subscription" ]]; then
            if echo "${text}" | grep -Eqi '(x/twitter|twitter|tweet|tweets|xai|grok|x||||timeline|)'; then
              wants_xai="true"
            fi
          fi
          codex_main_model="$(echo "${CODEX_MAIN_MODEL:-gpt-5-codex}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${codex_main_model}" ]]; then
            codex_main_model="gpt-5-codex"
          fi
          codex_multi_agent_model="$(echo "${CODEX_MULTI_AGENT_MODEL:-gpt-5.3-codex-spark}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${codex_multi_agent_model}" ]]; then
            codex_multi_agent_model="gpt-5.3-codex-spark"
          fi

          matrix_payload="$(bash "${orchestrator_lib_dir}/build-agent-matrix.sh" \
            --engine "${ci_execution_engine}" \
            --main-provider "${main_provider}" \
            --assist-provider "${assist_provider}" \
            --multi-agent-mode "${multi_agent_mode}" \
            --glm-subagent-mode "${glm_subagent_mode}" \
            --wants-gemini "${wants_gemini}" \
            --wants-xai "${wants_xai}" \
            --dual-main-signal "${dual_main_signal}" \
            --allow-glm-in-subscription "${allow_glm_in_subscription}" \
            --codex-main-model "${codex_main_model}" \
            --codex-multi-agent-model "${codex_multi_agent_model}" \
            --claude-opus-model "${CLAUDE_OPUS_MODEL}" \
            --claude-sonnet4-model "${CLAUDE_SONNET4_MODEL}" \
            --claude-sonnet6-model "${CLAUDE_SONNET6_MODEL}" \
            --gemini-model "${GEMINI_MODEL}" \
            --xai-model "${XAI_MODEL}" \
            --format "json")"
          matrix="$(echo "${matrix_payload}" | jq -c '.matrix')"
          lanes="$(echo "${matrix_payload}" | jq -r '.lanes')"
          main_signal_lane="$(echo "${matrix_payload}" | jq -r '.main_signal_lane')"
          main_signal_lanes="$(echo "${matrix_payload}" | jq -c '.main_signal_lanes // []')"
          min_consensus_lanes="$(echo "${MIN_CONSENSUS_LANES:-6}" | tr -cd '0-9')"
          if [[ -z "${min_consensus_lanes}" ]]; then
            min_consensus_lanes="6"
          fi
          if (( 10#${min_consensus_lanes} < 6 )); then
            min_consensus_lanes="6"
          fi
          lanes_num="$(echo "${lanes}" | tr -cd '0-9')"
          if [[ -z "${lanes_num}" ]]; then
            echo "Failed to resolve lane count from build-agent-matrix output (lanes=${lanes})." >&2
            exit 1
          fi
          if (( 10#${lanes_num} < 10#${min_consensus_lanes} )); then
            echo "Resolved lane count (${lanes_num}) is below FUGUE_MIN_CONSENSUS_LANES (${min_consensus_lanes}); refusing to run under-minimum consensus." >&2
            exit 1
          fi

          {
            echo "provider=${main_provider}"
            echo "provider_requested=${main_provider_requested}"
            echo "multi_agent_mode=${multi_agent_mode}"
            echo "multi_agent_mode_source=${multi_agent_mode_source}"
            echo "glm_subagent_mode=${glm_subagent_mode}"
            echo "glm_subagent_mode_source=${glm_subagent_mode_source}"
            echo "allow_glm_in_subscription=${allow_glm_in_subscription}"
            echo "claude_fallback_applied=${main_claude_fallback_applied}"
            echo "claude_fallback_reason=${main_claude_fallback_reason}"
            echo "main_provider=${main_provider}"
            echo "main_provider_requested=${main_provider_requested}"
            echo "main_claude_fallback_applied=${main_claude_fallback_applied}"
            echo "main_claude_fallback_reason=${main_claude_fallback_reason}"
            echo "assist_provider=${assist_provider}"
            echo "assist_provider_requested=${assist_provider_requested}"
            echo "assist_claude_fallback_applied=${assist_claude_fallback_applied}"
            echo "assist_claude_fallback_reason=${assist_claude_fallback_reason}"
            echo "claude_pressure_guard_applied=${claude_pressure_guard_applied}"
            echo "claude_pressure_guard_reason=${claude_pressure_guard_reason}"
            echo "ci_execution_engine=${ci_execution_engine}"
            echo "run_agents_runner=${run_agents_runner}"
            echo "run_agents_runner_json=${run_agents_runner_json}"
            echo "execution_profile=${execution_profile}"
            echo "execution_profile_reason=${execution_profile_reason}"
            echo "continuity_active=${continuity_active}"
            echo "self_hosted_online_count=${self_hosted_online_count}"
            echo "subscription_runner_label=${subscription_runner_label}"
            echo "strict_main_codex_model_effective=${strict_main_codex_model_effective}"
            echo "strict_opus_assist_direct_effective=${strict_opus_assist_direct_effective}"
            echo "subscription_offline_policy=${subscription_offline_policy}"
            echo "assist_adjusted_by_execution_profile=${assist_adjusted_by_execution_profile}"
            echo "assist_adjustment_reason=${assist_adjustment_reason}"
            echo "main_signal_lane=${main_signal_lane}"
            echo "main_signal_lanes=${main_signal_lanes}"
            echo "expected_lanes=${lanes}"
            echo "min_consensus_lanes=${min_consensus_lanes}"
            echo "agent_matrix=${matrix}"
          } >> "${GITHUB_OUTPUT}"

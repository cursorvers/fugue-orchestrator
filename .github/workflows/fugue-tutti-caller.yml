name: Fugue Mainframe (Tutti + Optional Codex Implement)

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process (used for automated handoff)"
        required: true
        type: string
      trust_subject:
        description: "Optional trusted actor login for permission checks"
        required: false
        type: string
        default: ""
      allow_processing_rerun:
        description: "Allow rerun while processing label is present"
        required: false
        type: string
        default: "false"
      subscription_offline_policy_override:
        description: "Optional offline policy override for this dispatch (hold|continuity)"
        required: false
        type: string
        default: ""
      vote_instruction_b64:
        description: "Optional /vote instruction payload (base64-encoded)"
        required: false
        type: string
        default: ""

permissions:
  issues: write
  contents: write
  pull-requests: write
  actions: read

concurrency:
  group: fugue-mainframe-${{ github.repository }}-${{ github.event.issue.number || github.event.inputs.issue_number || github.run_id }}-${{ github.event_name == 'issues' && format('label-{0}', github.event.label.name) || 'dispatch' }}
  cancel-in-progress: true

jobs:
  ctx:
    # For issues:labeled, only run when the label event is `tutti`.
    # For workflow_dispatch, treat the dispatch itself as the trigger.
    if: ${{ github.event_name != 'issues' || github.event.label.name == 'tutti' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_run: ${{ steps.ctx.outputs.should_run }}
      skip_reason: ${{ steps.ctx.outputs.skip_reason }}
      issue_number: ${{ steps.ctx.outputs.issue_number }}
      has_implement_request: ${{ steps.ctx.outputs.has_implement_request }}
      has_implement_confirmed: ${{ steps.ctx.outputs.has_implement_confirmed }}
      target_repo: ${{ steps.ctx.outputs.target_repo }}
      orchestrator_provider: ${{ steps.ctx.outputs.main_orchestrator_provider }}
      main_orchestrator_provider: ${{ steps.ctx.outputs.main_orchestrator_provider }}
      assist_orchestrator_provider: ${{ steps.ctx.outputs.assist_orchestrator_provider }}
      claude_fallback_applied: ${{ steps.ctx.outputs.main_claude_fallback_applied }}
      claude_fallback_reason: ${{ steps.ctx.outputs.main_claude_fallback_reason }}
      main_claude_fallback_applied: ${{ steps.ctx.outputs.main_claude_fallback_applied }}
      main_claude_fallback_reason: ${{ steps.ctx.outputs.main_claude_fallback_reason }}
      assist_claude_fallback_applied: ${{ steps.ctx.outputs.assist_claude_fallback_applied }}
      assist_claude_fallback_reason: ${{ steps.ctx.outputs.assist_claude_fallback_reason }}
      claude_pressure_guard_applied: ${{ steps.ctx.outputs.claude_pressure_guard_applied }}
      claude_pressure_guard_reason: ${{ steps.ctx.outputs.claude_pressure_guard_reason }}
      translation_gate_decision: ${{ steps.ctx.outputs.translation_gate_decision }}
      translation_applied: ${{ steps.ctx.outputs.translation_applied }}
      translation_provider: ${{ steps.ctx.outputs.translation_provider }}
      translation_score: ${{ steps.ctx.outputs.translation_score }}
      translation_threshold: ${{ steps.ctx.outputs.translation_threshold }}
      orchestration_profile: ${{ steps.ctx.outputs.orchestration_profile }}
      preflight_cycles: ${{ steps.ctx.outputs.preflight_cycles }}
      multi_agent_mode_override: ${{ steps.ctx.outputs.multi_agent_mode_override }}
      multi_agent_mode_lock: ${{ steps.ctx.outputs.multi_agent_mode_lock }}
      implementation_dialogue_rounds: ${{ steps.ctx.outputs.implementation_dialogue_rounds }}
      risk_tier: ${{ steps.ctx.outputs.risk_tier }}
      risk_score: ${{ steps.ctx.outputs.risk_score }}
      risk_reasons: ${{ steps.ctx.outputs.risk_reasons }}
      lessons_required: ${{ steps.ctx.outputs.lessons_required }}
      correction_signal: ${{ steps.ctx.outputs.correction_signal }}
      context_budget_initial: ${{ steps.ctx.outputs.context_budget_initial }}
      context_budget_max: ${{ steps.ctx.outputs.context_budget_max }}
      context_budget_floor_initial: ${{ steps.ctx.outputs.context_budget_floor_initial }}
      context_budget_floor_max: ${{ steps.ctx.outputs.context_budget_floor_max }}
      context_budget_floor_span: ${{ steps.ctx.outputs.context_budget_floor_span }}
      context_budget_guard_applied: ${{ steps.ctx.outputs.context_budget_guard_applied }}
      context_budget_guard_reasons: ${{ steps.ctx.outputs.context_budget_guard_reasons }}
      assist_auto_selected: ${{ steps.ctx.outputs.assist_auto_selected }}
      force_claude: ${{ steps.ctx.outputs.force_claude }}
      execution_provider: ${{ steps.ctx.outputs.execution_provider }}
      execution_profile: ${{ steps.ctx.outputs.execution_profile }}
      hybrid_conductor_mode: ${{ steps.ctx.outputs.hybrid_conductor_mode }}
      self_hosted_online_count: ${{ steps.ctx.outputs.self_hosted_online_count }}
      subscription_runner_label: ${{ steps.ctx.outputs.subscription_runner_label }}
      subscription_offline_policy: ${{ steps.ctx.outputs.subscription_offline_policy }}
      trust_subject: ${{ steps.ctx.outputs.trust_subject }}
      allow_processing_rerun: ${{ steps.ctx.outputs.allow_processing_rerun }}
      vote_instruction: ${{ steps.ctx.outputs.vote_instruction }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Resolve issue context
        id: ctx
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER_FROM_DISPATCH: ${{ github.event.inputs.issue_number || '' }}
          TRUST_SUBJECT_INPUT: ${{ github.event.inputs.trust_subject || '' }}
          ALLOW_PROCESSING_RERUN_INPUT: ${{ github.event.inputs.allow_processing_rerun || 'false' }}
          SUBSCRIPTION_OFFLINE_POLICY_OVERRIDE_INPUT: ${{ github.event.inputs.subscription_offline_policy_override || '' }}
          VOTE_INSTRUCTION_B64_INPUT: ${{ github.event.inputs.vote_instruction_b64 || '' }}
          ISSUE_NUMBER_FROM_ISSUE: ${{ github.event.issue.number || '' }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          DEFAULT_MAIN_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_MAIN_ORCHESTRATOR_PROVIDER || vars.FUGUE_ORCHESTRATOR_PROVIDER || 'claude' }}
          EXECUTION_PROVIDER_DEFAULT: ${{ vars.FUGUE_EXECUTION_PROVIDER || '' }}
          DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER: ${{ vars.FUGUE_ASSIST_ORCHESTRATOR_PROVIDER || 'claude' }}
          CLAUDE_RATE_LIMIT_STATE: ${{ vars.FUGUE_CLAUDE_RATE_LIMIT_STATE || 'ok' }}
          CLAUDE_MAIN_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_MAIN_ASSIST_POLICY || 'codex' }}
          CLAUDE_ROLE_POLICY: ${{ vars.FUGUE_CLAUDE_ROLE_POLICY || 'flex' }}
          CLAUDE_DEGRADED_ASSIST_POLICY: ${{ vars.FUGUE_CLAUDE_DEGRADED_ASSIST_POLICY || 'claude' }}
          CLAUDE_SUB_AUTO_ESCALATE: ${{ vars.FUGUE_CLAUDE_SUB_AUTO_ESCALATE || 'high' }}
          CLAUDE_SUB_AMBIGUITY_MIN_SCORE: ${{ vars.FUGUE_CLAUDE_SUB_AMBIGUITY_MIN_SCORE || '90' }}
          CLAUDE_MAX_PLAN: ${{ vars.FUGUE_CLAUDE_MAX_PLAN || 'true' }}
          CLAUDE_TRANSLATOR_MODE: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_MODE || 'auto' }}
          CLAUDE_TRANSLATOR_THRESHOLD: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_THRESHOLD || '75' }}
          CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED || '88' }}
          CLAUDE_TRANSLATOR_THRESHOLD_CLAUDE_LIGHT: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_THRESHOLD_CLAUDE_LIGHT || '90' }}
          CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED_CLAUDE_LIGHT: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED_CLAUDE_LIGHT || '95' }}
          CLAUDE_TRANSLATOR_MAX_CHARS: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_MAX_CHARS || '6000' }}
          CLAUDE_TRANSLATOR_MODEL: ${{ vars.FUGUE_CLAUDE_TRANSLATOR_MODEL || 'claude-sonnet-4-6' }}
          CODEX_MAIN_MODEL: ${{ vars.FUGUE_CODEX_MAIN_MODEL || 'gpt-5-codex' }}
          CODEX_MULTI_AGENT_MODEL: ${{ vars.FUGUE_CODEX_MULTI_AGENT_MODEL || 'gpt-5.3-codex-spark' }}
          DEFAULT_MULTI_AGENT_MODE: ${{ vars.FUGUE_MULTI_AGENT_MODE || '' }}
          DEFAULT_MULTI_AGENT_MODE_LOCK: ${{ vars.FUGUE_MULTI_AGENT_MODE_LOCK || 'false' }}
          CLAUDE_LIGHT_MULTI_AGENT_MODE: ${{ vars.FUGUE_CLAUDE_LIGHT_MULTI_AGENT_MODE || 'standard' }}
          CLAUDE_LIGHT_MULTI_AGENT_LOCK: ${{ vars.FUGUE_CLAUDE_LIGHT_MULTI_AGENT_LOCK || 'true' }}
          IMPLEMENT_PREFLIGHT_CYCLES_FULL: ${{ vars.FUGUE_IMPLEMENT_PREFLIGHT_CYCLES_FULL || '2' }}
          IMPLEMENT_PREFLIGHT_CYCLES_CLAUDE: ${{ vars.FUGUE_IMPLEMENT_PREFLIGHT_CYCLES_CLAUDE || '1' }}
          IMPLEMENT_DIALOGUE_ROUNDS_DEFAULT: ${{ vars.FUGUE_IMPLEMENT_DIALOGUE_ROUNDS || '2' }}
          IMPLEMENT_DIALOGUE_ROUNDS_CLAUDE: ${{ vars.FUGUE_IMPLEMENT_DIALOGUE_ROUNDS_CLAUDE || '1' }}
          FUGUE_CONTEXT_BUDGET_MIN_INITIAL: ${{ vars.FUGUE_CONTEXT_BUDGET_MIN_INITIAL || '6' }}
          FUGUE_CONTEXT_BUDGET_MIN_MAX: ${{ vars.FUGUE_CONTEXT_BUDGET_MIN_MAX || '12' }}
          FUGUE_CONTEXT_BUDGET_MIN_SPAN: ${{ vars.FUGUE_CONTEXT_BUDGET_MIN_SPAN || '6' }}
          CI_EXECUTION_ENGINE: ${{ vars.FUGUE_CI_EXECUTION_ENGINE || 'subscription' }}
          SUBSCRIPTION_OFFLINE_POLICY: ${{ vars.FUGUE_SUBSCRIPTION_OFFLINE_POLICY || 'continuity' }}
          EMERGENCY_CONTINUITY_MODE: ${{ vars.FUGUE_EMERGENCY_CONTINUITY_MODE || 'false' }}
          SUBSCRIPTION_RUNNER_LABEL: ${{ vars.FUGUE_SUBSCRIPTION_RUNNER_LABEL || 'fugue-subscription' }}
        run: |
          set -euo pipefail
          gh_api_retry() {
            local endpoint="$1"
            local attempts="${2:-5}"
            local sleep_sec=2
            local i out
            for ((i=1; i<=attempts; i++)); do
              if out="$(gh api "${endpoint}" 2>/dev/null)"; then
                printf '%s\n' "${out}"
                return 0
              fi
              if (( i == attempts )); then
                return 1
              fi
              sleep "${sleep_sec}"
              if (( sleep_sec < 16 )); then
                sleep_sec=$((sleep_sec * 2))
              fi
            done
            return 1
          }

          ISSUE_NUMBER=""
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            ISSUE_NUMBER="${ISSUE_NUMBER_FROM_DISPATCH}"
          else
            ISSUE_NUMBER="${ISSUE_NUMBER_FROM_ISSUE}"
          fi

          issue_endpoint="repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}"
          if ! issue_json="$(gh_api_retry "${issue_endpoint}" 5)"; then
            echo "Failed to fetch issue context after retries: ${issue_endpoint}" >&2
            exit 1
          fi
          title="$(echo "${issue_json}" | jq -r '.title // ""')"
          body="$(echo "${issue_json}" | jq -r '.body // ""')"
          trust_subject="$(printf '%s' "${TRUST_SUBJECT_INPUT:-}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -n "${trust_subject}" ]]; then
            trust_subject="$(printf '%s' "${trust_subject}" | sed -E 's/[^A-Za-z0-9_.-]//g')"
          fi
          allow_processing_rerun="$(echo "${ALLOW_PROCESSING_RERUN_INPUT:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${allow_processing_rerun}" != "true" ]]; then
            allow_processing_rerun="false"
          fi
          vote_instruction=""
          vote_instruction_b64="$(echo "${VOTE_INSTRUCTION_B64_INPUT:-}" | tr -d '\n\r[:space:]')"
          if [[ -n "${vote_instruction_b64}" ]]; then
            vote_instruction="$(printf '%s' "${vote_instruction_b64}" | base64 --decode 2>/dev/null || true)"
            vote_instruction="$(printf '%s' "${vote_instruction}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          fi
          owner="${GITHUB_REPOSITORY%%/*}"

          has_fugue="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("fugue-task") != null')"
          has_tutti="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | index("tutti") != null')"
          has_implement="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | (index("implement") != null) or (index("codex-implement") != null) or (index("claude-implement") != null)')"
          has_implement_confirmed="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | (index("implement-confirmed") != null)')"
          ci_execution_engine="$(echo "${CI_EXECUTION_ENGINE:-subscription}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${ci_execution_engine}" != "harness" && "${ci_execution_engine}" != "api" && "${ci_execution_engine}" != "subscription" ]]; then
            ci_execution_engine="subscription"
          fi
          subscription_offline_policy="$(echo "${SUBSCRIPTION_OFFLINE_POLICY:-continuity}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${subscription_offline_policy}" != "hold" && "${subscription_offline_policy}" != "continuity" ]]; then
            subscription_offline_policy="continuity"
          fi
          subscription_offline_policy_override="$(echo "${SUBSCRIPTION_OFFLINE_POLICY_OVERRIDE_INPUT:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${subscription_offline_policy_override}" == "hold" || "${subscription_offline_policy_override}" == "continuity" ]]; then
            subscription_offline_policy="${subscription_offline_policy_override}"
          fi
          emergency_continuity_mode="$(echo "${EMERGENCY_CONTINUITY_MODE:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${emergency_continuity_mode}" != "true" ]]; then
            emergency_continuity_mode="false"
          fi
          subscription_runner_label="$(echo "${SUBSCRIPTION_RUNNER_LABEL:-fugue-subscription}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ -z "${subscription_runner_label}" ]]; then
            subscription_runner_label="fugue-subscription"
          fi
          self_hosted_online_count="0"
          if [[ "${ci_execution_engine}" == "subscription" ]]; then
            runners_endpoint="repos/${GITHUB_REPOSITORY}/actions/runners?per_page=100"
            runners_json="$(gh_api_retry "${runners_endpoint}" 5 || echo '{}')"
            self_hosted_online_count="$(echo "${runners_json}" | jq -r --arg label "${subscription_runner_label}" '[.runners[]? | select(.status=="online" and .busy != true and ([.labels[]?.name] | index("self-hosted") != null) and ([.labels[]?.name] | index($label) != null))] | length' 2>/dev/null || echo "0")"
            self_hosted_online_count="$(echo "${self_hosted_online_count}" | tr -cd '0-9')"
            if [[ -z "${self_hosted_online_count}" ]]; then
              self_hosted_online_count="0"
            else
              self_hosted_online_count="$((10#${self_hosted_online_count}))"
            fi
          fi
          labels_csv="$(echo "${issue_json}" | jq -r '[.labels[]? | .name] | join(",")')"
          body_mode="$(printf '%s\n' "${body}" | awk '
            BEGIN { in_sec=0 }
            tolower($0) ~ /^##[[:space:]]*mode[[:space:]]*$/ { in_sec=1; next }
            in_sec && $0 ~ /^##[[:space:]]/ { exit }
            in_sec {
              line=$0
              gsub(/`/, "", line)
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
              if (line != "") {
                print tolower(line)
                exit
              }
            }
          ')"
          if [[ "${body_mode}" != "implement" && "${body_mode}" != "review" ]]; then
            body_mode="$(printf '%s\n' "${body}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*execution[[:space:]]+mode[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
          fi
          if [[ "${body_mode}" != "implement" && "${body_mode}" != "review" ]]; then
            body_mode="$(echo "${body}" | sed -nE 's/^[[:space:]]*mode[[:space:]]*:[[:space:]]*(implement|review)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
          fi
          # Explicit review mode in issue body always wins over stale labels.
          if [[ "${body_mode}" == "review" ]]; then
            has_implement="false"
            has_implement_confirmed="false"
          fi
          label_main_provider="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] as $labels
            | if ((($labels | index("orchestrator:claude")) != null) and (($labels | index("orchestrator:codex")) != null)) then ""
              elif (($labels | index("orchestrator:claude")) != null) then "claude"
              elif (($labels | index("orchestrator:codex")) != null) then "codex"
              else "" end
          ')"
          label_assist_provider="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] as $labels
            | if (($labels | index("orchestrator-assist:none")) != null) then "none"
              elif ((($labels | index("orchestrator-assist:claude")) != null) and (($labels | index("orchestrator-assist:codex")) != null)) then ""
              elif (($labels | index("orchestrator-assist:claude")) != null) then "claude"
              elif (($labels | index("orchestrator-assist:codex")) != null) then "codex"
              else "" end
          ')"
          force_claude="$(echo "${issue_json}" | jq -r '
            [ .labels[]? | .name ] | index("orchestrator-force:claude") != null
          ')"
          body_main_provider="$(printf '%s\n' "${body}" | awk '
            BEGIN { in_sec=0 }
            tolower($0) ~ /^##[[:space:]]*orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
            in_sec && $0 ~ /^##[[:space:]]/ { exit }
            in_sec {
              line=$0
              gsub(/`/, "", line)
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
              if (line != "") {
                print tolower(line)
                exit
              }
            }
          ')"
          if [[ -z "${body_main_provider}" ]]; then
            body_main_provider="$(printf '%s\n' "${body}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*main[[:space:]]+orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
          fi
          if [[ "${body_main_provider}" != "claude" && "${body_main_provider}" != "codex" ]]; then
            body_main_provider=""
          fi
          if [[ -z "${body_main_provider}" ]]; then
            body_main_provider="$(echo "${body}" | sed -nE 's/^[[:space:]]*orchestrator[[:space:]_-]*provider[[:space:]]*:[[:space:]]*(claude|codex)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
          fi

          body_assist_provider="$(printf '%s\n' "${body}" | awk '
            BEGIN { in_sec=0 }
            tolower($0) ~ /^##[[:space:]]*assist[[:space:]]+orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
            in_sec && $0 ~ /^##[[:space:]]/ { exit }
            in_sec {
              line=$0
              gsub(/`/, "", line)
              gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
              if (line != "") {
                print tolower(line)
                exit
              }
            }
          ')"
          if [[ -z "${body_assist_provider}" ]]; then
            body_assist_provider="$(printf '%s\n' "${body}" | awk '
              BEGIN { in_sec=0 }
              tolower($0) ~ /^###[[:space:]]*assist[[:space:]]+orchestrator[[:space:]]+provider[[:space:]]*$/ { in_sec=1; next }
              in_sec && $0 ~ /^###[[:space:]]/ { exit }
              in_sec {
                line=$0
                gsub(/`/, "", line)
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                if (line != "") {
                  print tolower(line)
                  exit
                }
              }
            ')"
          fi
          if [[ "${body_assist_provider}" != "claude" && "${body_assist_provider}" != "codex" && "${body_assist_provider}" != "none" ]]; then
            body_assist_provider=""
          fi
          if [[ -z "${body_assist_provider}" ]]; then
            body_assist_provider="$(echo "${body}" | sed -nE 's/^[[:space:]]*assist[[:space:]]+orchestrator[[:space:]_-]*provider[[:space:]]*:[[:space:]]*(claude|codex|none)[[:space:]]*$/\1/ip' | head -n1 | tr '[:upper:]' '[:lower:]')"
          fi

          eval "$(
            scripts/lib/orchestrator-nl-hints.sh \
              --title "${title}" \
              --body "${body}"
          )"

          requested_main_provider="${label_main_provider}"
          main_provider_source="label"
          if [[ -z "${requested_main_provider}" && -n "${body_main_provider}" ]]; then
            requested_main_provider="${body_main_provider}"
            main_provider_source="body-structured"
          fi
          if [[ -z "${requested_main_provider}" && -n "${nl_main_hint}" ]]; then
            requested_main_provider="${nl_main_hint}"
            main_provider_source="body-natural-language"
          fi
          if [[ -z "${requested_main_provider}" ]]; then
            requested_main_provider="${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER:-codex}"
            main_provider_source="default"
          fi
          requested_main_provider="$(echo "${requested_main_provider}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${requested_main_provider}" != "claude" && "${requested_main_provider}" != "codex" ]]; then
            requested_main_provider="codex"
            main_provider_source="default"
          fi
          requested_main_provider_initial="${requested_main_provider}"
          orchestration_profile="codex-full"
          if [[ "${requested_main_provider_initial}" == "claude" && "${force_claude}" != "true" ]]; then
            orchestration_profile="claude-light"
          fi
          multi_agent_mode_override="$(echo "${DEFAULT_MULTI_AGENT_MODE:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${multi_agent_mode_override}" != "standard" && "${multi_agent_mode_override}" != "enhanced" && "${multi_agent_mode_override}" != "max" ]]; then
            multi_agent_mode_override=""
          fi
          multi_agent_mode_lock="$(echo "${DEFAULT_MULTI_AGENT_MODE_LOCK:-false}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${multi_agent_mode_lock}" != "true" ]]; then
            multi_agent_mode_lock="false"
          fi
          # Apply claude-light multi-agent restrictions only when NOT in Hybrid Conductor Mode.
          # In Hybrid, Claude is main but execution is Codex — full multi-agent depth is desired.
          if [[ "${orchestration_profile}" == "claude-light" && "${hybrid_conductor_mode}" != "true" ]]; then
            if [[ -z "${multi_agent_mode_override}" ]]; then
              multi_agent_mode_override="$(echo "${CLAUDE_LIGHT_MULTI_AGENT_MODE:-standard}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
              if [[ "${multi_agent_mode_override}" != "standard" && "${multi_agent_mode_override}" != "enhanced" && "${multi_agent_mode_override}" != "max" ]]; then
                multi_agent_mode_override="standard"
              fi
            fi
            if [[ "${multi_agent_mode_lock}" != "true" ]]; then
              multi_agent_mode_lock="$(echo "${CLAUDE_LIGHT_MULTI_AGENT_LOCK:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
              if [[ "${multi_agent_mode_lock}" != "true" ]]; then
                multi_agent_mode_lock="false"
              fi
            fi
          fi

          requested_assist_provider="${label_assist_provider}"
          assist_provider_source="label"
          if [[ -z "${requested_assist_provider}" && -n "${body_assist_provider}" ]]; then
            requested_assist_provider="${body_assist_provider}"
            assist_provider_source="body-structured"
          fi
          if [[ -z "${requested_assist_provider}" && -n "${nl_assist_hint}" ]]; then
            requested_assist_provider="${nl_assist_hint}"
            assist_provider_source="body-natural-language"
          fi
          assist_explicit="false"
          if [[ -n "${label_assist_provider}" || -n "${body_assist_provider}" || -n "${nl_assist_hint}" ]]; then
            assist_explicit="true"
          fi
          if [[ -z "${requested_assist_provider}" ]]; then
            requested_assist_provider="${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER:-claude}"
            assist_provider_source="default"
          fi
          requested_assist_provider="$(echo "${requested_assist_provider}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${requested_assist_provider}" != "claude" && "${requested_assist_provider}" != "codex" && "${requested_assist_provider}" != "none" ]]; then
            requested_assist_provider="${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER:-claude}"
            assist_provider_source="default"
          fi

          claude_state="$(echo "${CLAUDE_RATE_LIMIT_STATE:-ok}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_state}" != "ok" && "${claude_state}" != "degraded" && "${claude_state}" != "exhausted" ]]; then
            claude_state="ok"
          fi

          # Translation gateway:
          # Codex judges whether Claude translation is needed between human input and Codex orchestration.
          translator_mode="$(echo "${CLAUDE_TRANSLATOR_MODE:-auto}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${translator_mode}" != "auto" && "${translator_mode}" != "always" && "${translator_mode}" != "off" ]]; then
            translator_mode="auto"
          fi
          claude_max_plan="$(echo "${CLAUDE_MAX_PLAN:-true}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${claude_max_plan}" != "true" ]]; then
            claude_max_plan="false"
          fi
          threshold_raw="$(echo "${CLAUDE_TRANSLATOR_THRESHOLD:-75}" | tr -cd '0-9')"
          if [[ -z "${threshold_raw}" ]]; then
            threshold_raw="75"
          fi
          threshold_degraded_raw="$(echo "${CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED:-88}" | tr -cd '0-9')"
          if [[ -z "${threshold_degraded_raw}" ]]; then
            threshold_degraded_raw="88"
          fi
          if [[ "${orchestration_profile}" == "claude-light" ]]; then
            light_threshold_raw="$(echo "${CLAUDE_TRANSLATOR_THRESHOLD_CLAUDE_LIGHT:-90}" | tr -cd '0-9')"
            if [[ -z "${light_threshold_raw}" ]]; then
              light_threshold_raw="90"
            fi
            light_threshold_degraded_raw="$(echo "${CLAUDE_TRANSLATOR_THRESHOLD_DEGRADED_CLAUDE_LIGHT:-95}" | tr -cd '0-9')"
            if [[ -z "${light_threshold_degraded_raw}" ]]; then
              light_threshold_degraded_raw="95"
            fi
            if (( threshold_raw < light_threshold_raw )); then
              threshold_raw="${light_threshold_raw}"
            fi
            if (( threshold_degraded_raw < light_threshold_degraded_raw )); then
              threshold_degraded_raw="${light_threshold_degraded_raw}"
            fi
          fi
          max_chars_raw="$(echo "${CLAUDE_TRANSLATOR_MAX_CHARS:-6000}" | tr -cd '0-9')"
          if [[ -z "${max_chars_raw}" ]]; then
            max_chars_raw="6000"
          fi
          translation_threshold="${threshold_raw}"
          if [[ "${claude_state}" == "degraded" ]]; then
            translation_threshold="${threshold_degraded_raw}"
          fi
          translation_gate_decision="false"
          translation_applied="false"
          translation_provider="none"
          translation_judge_provider="codex"
          translation_score="0"
          translation_reason="translation-not-required"
          translation_skip_reason=""
          translation_event="false"
          translation_payload=""
          normalized_text="$(printf '%s\n\n%s\n' "${title}" "${body}" | head -c "${max_chars_raw}")"
          CODEX_MAIN_MODEL="gpt-5-codex"
          if ! [[ "${CODEX_MULTI_AGENT_MODEL}" =~ ^gpt-5(\.[0-9]+)?-codex-spark$ ]]; then
            CODEX_MULTI_AGENT_MODEL="gpt-5.3-codex-spark"
          fi
          if [[ "${CLAUDE_TRANSLATOR_MODEL}" != "claude-sonnet-4-6" ]]; then
            CLAUDE_TRANSLATOR_MODEL="claude-sonnet-4-6"
          fi

          if [[ "${translator_mode}" != "off" && -n "${OPENAI_API_KEY:-}" ]]; then
            judge_sys_prompt="You are Codex Orchestrator gate. Decide if Claude translation should be inserted before orchestration. Return ONLY compact JSON: {\"score\":0-100,\"should_translate\":true|false,\"reason\":\"short\",\"signals\":[\"...\"]}."
            judge_user_prompt="Analyze this issue text for ambiguity/conflict/risk/implicit constraints. Prioritize translation when requirements are unclear, mixed-language, or high-risk refactor/migration. Text:\n${normalized_text}"
            judge_candidates=("${CODEX_MULTI_AGENT_MODEL}" "${CODEX_MAIN_MODEL}" "gpt-5-codex")
            judge_json=""
            for judge_model in "${judge_candidates[@]}"; do
              judge_req="$(jq -n \
                --arg model "${judge_model}" \
                --arg s "${judge_sys_prompt}" \
                --arg u "${judge_user_prompt}" \
                '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.0}')"
              judge_http="$(curl -sS -o /tmp/fugue-judge-response.json -w "%{http_code}" https://api.openai.com/v1/chat/completions \
                --connect-timeout 10 --max-time 60 --retry 2 \
                -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                -H "Content-Type: application/json" \
                -d "${judge_req}" || true)"
              if [[ "${judge_http}" == "200" ]]; then
                judge_content="$(jq -r '.choices[0].message.content // ""' /tmp/fugue-judge-response.json 2>/dev/null || echo "")"
                judge_json="$(printf '%s' "${judge_content}" | sed -E 's/^```json[[:space:]]*//; s/^```[[:space:]]*//; s/[[:space:]]*```$//')"
                if printf '%s' "${judge_json}" | jq -e . >/dev/null 2>&1; then
                  break
                fi
              fi
              judge_json=""
            done
            if [[ -n "${judge_json}" ]]; then
              translation_score="$(printf '%s' "${judge_json}" | jq -r '.score // 0' | tr -cd '0-9')"
              if [[ -z "${translation_score}" ]]; then
                translation_score="0"
              fi
              judge_decision="$(printf '%s' "${judge_json}" | jq -r '.should_translate // false')"
              if [[ "${judge_decision}" == "true" || "${translator_mode}" == "always" || "${translation_score}" -ge "${translation_threshold}" ]]; then
                translation_gate_decision="true"
              fi
              translation_reason="$(printf '%s' "${judge_json}" | jq -r '.reason // "codex-judge"' | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g')"
            else
              # Heuristic fallback when Codex judge response is unavailable.
              translation_score=30
              if [[ "${#normalized_text}" -gt 1600 ]]; then translation_score=$((translation_score + 20)); fi
              if echo "${normalized_text}" | grep -Eqi '(大規模|全面|全体|リファクタ|refactor|migration|rewrite|アーキテクチャ刷新)'; then translation_score=$((translation_score + 25)); fi
              if echo "${normalized_text}" | grep -Eqi '(いい感じ|任せ|よろしく|適宜|うまく|なんとか|ざっくり|とりあえず|as needed|best effort)'; then translation_score=$((translation_score + 20)); fi
              if echo "${normalized_text}" | grep -Eqi '(must not|制約|禁止|rollback|ロールバック|受け入れ|acceptance)'; then translation_score=$((translation_score + 10)); fi
              if (( translation_score > 100 )); then translation_score=100; fi
              translation_reason="codex-judge-fallback-heuristic"
              if [[ "${translator_mode}" == "always" || "${translation_score}" -ge "${translation_threshold}" ]]; then
                translation_gate_decision="true"
              fi
            fi
          fi
          if [[ "${translator_mode}" == "always" ]]; then
            translation_gate_decision="true"
          elif [[ "${translator_mode}" == "off" ]]; then
            translation_gate_decision="false"
            translation_reason="translator-mode-off"
          fi

          if [[ "${translation_gate_decision}" == "true" ]]; then
            if [[ "${claude_state}" == "exhausted" && "${force_claude}" != "true" ]]; then
              translation_skip_reason="claude-rate-limit-exhausted"
            else
              translator_sys_prompt="You are a requirements translator between human request and Codex orchestrator. Preserve intent. Return ONLY compact JSON with keys: task_summary, goal, constraints(array), acceptance_criteria(array), risks(array), open_questions(array), execution_mode_hint(review|implement|unspecified)."
              translator_user_prompt="Translate and structure this issue for precise execution:\n${normalized_text}"
              translation_resp_json=""
              if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
                translation_provider="claude"
                claude_req="$(jq -n \
                  --arg model "${CLAUDE_TRANSLATOR_MODEL}" \
                  --arg s "${translator_sys_prompt}" \
                  --arg u "${translator_user_prompt}" \
                  '{model:$model,system:$s,messages:[{role:"user",content:$u}],max_tokens:1400,temperature:0.1}')"
                claude_http="$(curl -sS -o /tmp/fugue-translation-response.json -w "%{http_code}" https://api.anthropic.com/v1/messages \
                  --connect-timeout 10 --max-time 60 --retry 2 \
                  -H "x-api-key: ${ANTHROPIC_API_KEY}" \
                  -H "anthropic-version: 2023-06-01" \
                  -H "Content-Type: application/json" \
                  -d "${claude_req}" || true)"
                if [[ "${claude_http}" == "200" ]]; then
                  translation_resp_json="$(jq -r '[.content[]? | select(.type=="text") | .text] | join("\n") // ""' /tmp/fugue-translation-response.json 2>/dev/null || echo "")"
                fi
              elif [[ "${claude_max_plan}" == "true" && -n "${OPENAI_API_KEY:-}" ]]; then
                translation_provider="claude-max-proxy-codex"
                proxy_candidates=("${CODEX_MULTI_AGENT_MODEL}" "${CODEX_MAIN_MODEL}" "gpt-5-codex")
                for proxy_model in "${proxy_candidates[@]}"; do
                  proxy_req="$(jq -n \
                    --arg model "${proxy_model}" \
                    --arg s "${translator_sys_prompt}" \
                    --arg u "${translator_user_prompt}" \
                    '{model:$model,messages:[{role:"system",content:$s},{role:"user",content:$u}],temperature:0.1}')"
                  proxy_http="$(curl -sS -o /tmp/fugue-translation-response.json -w "%{http_code}" https://api.openai.com/v1/chat/completions \
                    --connect-timeout 10 --max-time 60 --retry 2 \
                    -H "Authorization: Bearer ${OPENAI_API_KEY}" \
                    -H "Content-Type: application/json" \
                    -d "${proxy_req}" || true)"
                  if [[ "${proxy_http}" == "200" ]]; then
                    translation_resp_json="$(jq -r '.choices[0].message.content // ""' /tmp/fugue-translation-response.json 2>/dev/null || echo "")"
                    if [[ -n "${translation_resp_json}" ]]; then
                      break
                    fi
                  fi
                done
              else
                translation_skip_reason="missing-claude-translation-credentials"
              fi

              if [[ -n "${translation_resp_json}" ]]; then
                translation_payload="$(printf '%s' "${translation_resp_json}" | sed -E 's/^```json[[:space:]]*//; s/^```[[:space:]]*//; s/[[:space:]]*```$//')"
                if ! printf '%s' "${translation_payload}" | jq -e . >/dev/null 2>&1; then
                  translation_payload=""
                  translation_skip_reason="translator-invalid-json"
                fi
              fi
            fi
          fi

          if [[ "${translation_gate_decision}" == "true" && -n "${translation_payload}" ]]; then
            task_summary="$(printf '%s' "${translation_payload}" | jq -r '.task_summary // ""')"
            translated_goal="$(printf '%s' "${translation_payload}" | jq -r '.goal // ""')"
            exec_mode_hint="$(printf '%s' "${translation_payload}" | jq -r '.execution_mode_hint // "unspecified"')"
            constraints_md="$(printf '%s' "${translation_payload}" | jq -r '(.constraints // []) | if length==0 then "- none" else map("- " + .) | join("\n") end')"
            acceptance_md="$(printf '%s' "${translation_payload}" | jq -r '(.acceptance_criteria // []) | if length==0 then "- none" else map("- " + .) | join("\n") end')"
            risks_md="$(printf '%s' "${translation_payload}" | jq -r '(.risks // []) | if length==0 then "- none" else map("- " + .) | join("\n") end')"
            questions_md="$(printf '%s' "${translation_payload}" | jq -r '(.open_questions // []) | if length==0 then "- none" else map("- " + .) | join("\n") end')"
            ts_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            marker_start="<!-- fugue-translation-gateway:start -->"
            marker_end="<!-- fugue-translation-gateway:end -->"
            old_body_file="$(mktemp)"
            new_body_file="$(mktemp)"
            block_file="$(mktemp)"
            printf '%s\n' "${body}" > "${old_body_file}"
            {
              echo "${marker_start}"
              echo "## FUGUE Translation Gateway"
              echo "- mode: ${translator_mode}"
              echo "- judge: ${translation_judge_provider}"
              echo "- decision: ${translation_gate_decision}"
              echo "- score: ${translation_score} (threshold=${translation_threshold})"
              echo "- reason: ${translation_reason}"
              echo "- translator: ${translation_provider}"
              echo "- timestamp_utc: ${ts_utc}"
              echo
              echo "### Task Summary"
              echo "${task_summary}"
              echo
              echo "### Goal"
              echo "${translated_goal}"
              echo
              echo "### Constraints"
              echo "${constraints_md}"
              echo
              echo "### Acceptance Criteria"
              echo "${acceptance_md}"
              echo
              echo "### Risk Notes"
              echo "${risks_md}"
              echo
              echo "### Open Questions"
              echo "${questions_md}"
              echo
              echo "### Routing Hint"
              echo "- execution_mode_hint: ${exec_mode_hint}"
              echo "${marker_end}"
            } > "${block_file}"
            awk -v start="${marker_start}" -v end="${marker_end}" '
              $0 == start {skip=1; next}
              $0 == end {skip=0; next}
              !skip {print}
            ' "${old_body_file}" > "${new_body_file}"
            printf '\n\n' >> "${new_body_file}"
            cat "${block_file}" >> "${new_body_file}"
            new_body="$(cat "${new_body_file}")"
            if [[ "${new_body}" != "${body}" ]]; then
              payload_file="$(mktemp)"
              jq -n --arg b "${new_body}" '{body:$b}' > "${payload_file}"
              gh api "repos/${GITHUB_REPOSITORY}/issues/${ISSUE_NUMBER}" \
                --method PATCH \
                --input "${payload_file}" >/dev/null
              body="${new_body}"
            fi
            translation_applied="true"
            translation_event="true"
          elif [[ "${translation_gate_decision}" == "true" ]]; then
            if [[ -z "${translation_skip_reason}" ]]; then
              translation_skip_reason="translator-no-output"
            fi
            translation_event="true"
          fi

          eval "$(
            scripts/lib/orchestrator-policy.sh \
              --main "${requested_main_provider_initial}" \
              --assist "${requested_assist_provider}" \
              --default-main "${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER}" \
              --default-assist "${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER}" \
              --claude-state "${claude_state}" \
              --force-claude "${force_claude}" \
              --assist-policy "${CLAUDE_MAIN_ASSIST_POLICY}" \
              --claude-role-policy "${CLAUDE_ROLE_POLICY}" \
              --degraded-assist-policy "${CLAUDE_DEGRADED_ASSIST_POLICY}"
          )"
          requested_main_provider="${resolved_main}"
          requested_assist_provider="${resolved_assist}"
          main_claude_fallback_applied="${main_fallback_applied}"
          main_claude_fallback_reason="${main_fallback_reason}"
          assist_claude_fallback_applied="${assist_fallback_applied}"
          assist_claude_fallback_reason="${assist_fallback_reason}"
          claude_pressure_guard_applied="${pressure_guard_applied}"
          claude_pressure_guard_reason="${pressure_guard_reason}"
          # Profile should follow the resolved main provider, not just initial request.
          orchestration_profile="codex-full"
          if [[ "${requested_main_provider}" == "claude" ]]; then
            orchestration_profile="claude-light"
          fi

          # Hybrid Conductor Mode: execution provider can differ from main orchestrator.
          execution_provider="$(echo "${EXECUTION_PROVIDER_DEFAULT:-}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${execution_provider}" != "codex" && "${execution_provider}" != "claude" ]]; then
            execution_provider="${requested_main_provider}"
          fi
          hybrid_conductor_mode="false"
          if [[ "${requested_main_provider}" != "${execution_provider}" ]]; then
            hybrid_conductor_mode="true"
          fi
          # Guard: only main=claude + execution=codex is a valid Hybrid combination.
          if [[ "${hybrid_conductor_mode}" == "true" && "${requested_main_provider}" != "claude" ]]; then
            echo "Warning: reverse Hybrid (main=${requested_main_provider}, execution=${execution_provider}) is unsupported; falling back to non-Hybrid." >&2
            execution_provider="${requested_main_provider}"
            hybrid_conductor_mode="false"
          fi
          # Execution profile determines implementation parameters (codex-full or claude-light).
          execution_profile="codex-full"
          if [[ "${execution_provider}" == "claude" ]]; then
            execution_profile="claude-light"
          fi

          implementation_dialogue_rounds_raw="${IMPLEMENT_DIALOGUE_ROUNDS_DEFAULT:-2}"
          if [[ "${execution_profile}" == "claude-light" ]]; then
            implementation_dialogue_rounds_raw="${IMPLEMENT_DIALOGUE_ROUNDS_CLAUDE:-1}"
          fi
          implementation_dialogue_rounds="$(echo "${implementation_dialogue_rounds_raw}" | tr -cd '0-9')"
          if [[ -z "${implementation_dialogue_rounds}" ]]; then
            implementation_dialogue_rounds="2"
          fi
          if (( implementation_dialogue_rounds < 1 )); then
            implementation_dialogue_rounds=1
          elif (( implementation_dialogue_rounds > 5 )); then
            implementation_dialogue_rounds=5
          fi

          preflight_cycles_raw="${IMPLEMENT_PREFLIGHT_CYCLES_FULL:-2}"
          if [[ "${execution_profile}" == "claude-light" ]]; then
            preflight_cycles_raw="${IMPLEMENT_PREFLIGHT_CYCLES_CLAUDE:-1}"
          fi
          preflight_cycles="$(echo "${preflight_cycles_raw}" | tr -cd '0-9')"
          if [[ -z "${preflight_cycles}" ]]; then
            preflight_cycles="2"
          fi
          if [[ "${execution_profile}" == "claude-light" ]]; then
            if (( preflight_cycles < 1 )); then
              preflight_cycles=1
            elif (( preflight_cycles > 3 )); then
              preflight_cycles=3
            fi
          else
            if (( preflight_cycles < 2 )); then
              preflight_cycles=2
            elif (( preflight_cycles > 5 )); then
              preflight_cycles=5
            fi
          fi

          eval "$(
            scripts/lib/workflow-risk-policy.sh \
              --title "${title}" \
              --body "${body}" \
              --labels "${labels_csv}" \
              --has-implement "${has_implement}" \
              --orchestration-profile "${orchestration_profile}"
          )"

          if (( preflight_cycles < preflight_cycles_floor )); then
            preflight_cycles="${preflight_cycles_floor}"
          fi
          if (( implementation_dialogue_rounds < implementation_dialogue_rounds_floor )); then
            implementation_dialogue_rounds="${implementation_dialogue_rounds_floor}"
          fi
          assist_auto_selected="explicit-or-default"
          sub_auto_escalate="$(echo "${CLAUDE_SUB_AUTO_ESCALATE:-high}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${sub_auto_escalate}" != "off" && "${sub_auto_escalate}" != "high" && "${sub_auto_escalate}" != "medium-high" ]]; then
            sub_auto_escalate="high"
          fi
          claude_sub_trigger="none"
          auto_attach_claude="false"
          ambiguity_score_min="$(echo "${CLAUDE_SUB_AMBIGUITY_MIN_SCORE:-90}" | tr -cd '0-9')"
          if [[ -z "${ambiguity_score_min}" ]]; then
            ambiguity_score_min="90"
          fi
          if (( ambiguity_score_min < 0 )); then
            ambiguity_score_min=0
          elif (( ambiguity_score_min > 100 )); then
            ambiguity_score_min=100
          fi
          translation_score_num="$(echo "${translation_score}" | tr -cd '0-9')"
          if [[ -z "${translation_score_num}" ]]; then
            translation_score_num=0
          fi
          # Secondary triggers to avoid "never-use-Claude" failure when risk heuristics miss.
          if [[ "${risk_tier}" == "high" ]]; then
            auto_attach_claude="true"
            claude_sub_trigger="risk-high"
          elif [[ "${correction_signal}" == "true" ]]; then
            auto_attach_claude="true"
            claude_sub_trigger="correction-signal"
          elif [[ "${translation_gate_decision}" == "true" && "${translation_score_num}" -ge "${ambiguity_score_min}" ]]; then
            auto_attach_claude="true"
            claude_sub_trigger="ambiguity-translation-gate(${translation_score_num})"
          fi
          # Claude is a sub orchestrator under constrained MAX plans.
          # Auto-attach only when risk warrants it and no explicit/default assist was requested.
          if [[ "${assist_explicit}" != "true" && "${force_claude}" != "true" && "${requested_assist_provider}" == "none" ]]; then
            if [[ "${sub_auto_escalate}" == "off" ]]; then
              requested_assist_provider="none"
              assist_provider_source="risk-auto(off)"
              assist_auto_selected="off->none"
            elif [[ "${sub_auto_escalate}" == "medium-high" ]]; then
              if [[ "${risk_tier}" == "medium" || "${risk_tier}" == "high" || "${auto_attach_claude}" == "true" ]]; then
                requested_assist_provider="claude"
                assist_provider_source="risk-auto(medium-high)"
                assist_auto_selected="${risk_tier}->claude(${claude_sub_trigger})"
              else
                requested_assist_provider="none"
                assist_provider_source="risk-auto(medium-high)"
                assist_auto_selected="low->none"
              fi
            else
              if [[ "${auto_attach_claude}" == "true" ]]; then
                requested_assist_provider="claude"
                assist_provider_source="risk-auto(high)"
                assist_auto_selected="${risk_tier}->claude(${claude_sub_trigger})"
              else
                requested_assist_provider="none"
                assist_provider_source="risk-auto(high)"
                assist_auto_selected="${risk_tier}->none"
              fi
            fi
          fi
          eval "$(
            scripts/lib/orchestrator-policy.sh \
              --main "${requested_main_provider_initial}" \
              --assist "${requested_assist_provider}" \
              --default-main "${DEFAULT_MAIN_ORCHESTRATOR_PROVIDER}" \
              --default-assist "${DEFAULT_ASSIST_ORCHESTRATOR_PROVIDER}" \
              --claude-state "${claude_state}" \
              --force-claude "${force_claude}" \
              --assist-policy "${CLAUDE_MAIN_ASSIST_POLICY}" \
              --claude-role-policy "${CLAUDE_ROLE_POLICY}" \
              --degraded-assist-policy "${CLAUDE_DEGRADED_ASSIST_POLICY}"
          )"
          requested_main_provider="${resolved_main}"
          requested_assist_provider="${resolved_assist}"
          main_claude_fallback_applied="${main_fallback_applied}"
          main_claude_fallback_reason="${main_fallback_reason}"
          assist_claude_fallback_applied="${assist_fallback_applied}"
          assist_claude_fallback_reason="${assist_fallback_reason}"
          claude_pressure_guard_applied="${pressure_guard_applied}"
          claude_pressure_guard_reason="${pressure_guard_reason}"
          if [[ "${main_claude_fallback_applied}" == "true" && -n "${main_claude_fallback_reason}" ]]; then
            main_provider_source="${main_provider_source}+policy(${main_claude_fallback_reason})"
          fi
          if [[ "${assist_claude_fallback_applied}" == "true" && -n "${assist_claude_fallback_reason}" ]]; then
            assist_provider_source="${assist_provider_source}+policy(${assist_claude_fallback_reason})"
          elif [[ "${claude_pressure_guard_applied}" == "true" && -n "${claude_pressure_guard_reason}" ]]; then
            assist_provider_source="${assist_provider_source}+policy(${claude_pressure_guard_reason})"
          fi
          # Keep low-risk tasks lightweight and high-risk tasks exhaustive when
          # no explicit multi-agent override was provided.
          if [[ -z "${multi_agent_mode_override}" && "${multi_agent_mode_lock}" != "true" ]]; then
            if [[ "${risk_tier}" == "low" ]]; then
              multi_agent_mode_override="standard"
            elif [[ "${risk_tier}" == "high" ]]; then
              multi_agent_mode_override="max"
            fi
          fi

          # 1) Prefer fully-qualified owner/repo found inside backticks.
          target_repo="$(printf '%s\n' "${body}" \
            | sed -nE 's/.*`([A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+)`.*/\1/p' \
            | head -n1)"

          # 1b) Also accept plain "owner/repo" (common on mobile forms).
          if [[ -z "${target_repo}" ]]; then
            target_repo="$(printf '%s\n' "${body}" | grep -oE "${owner}/[A-Za-z0-9_.-]+" | head -n1 || true)"
          fi

          # 2) Fallback: repo name in backticks on lines mentioning repo/リポジトリ.
          if [[ -z "${target_repo}" ]]; then
            bare_repo="$(printf '%s\n' "${body}" \
              | grep -E 'repo|Repo|repository|Repository|リポジトリ' \
              | sed -nE 's/.*`([A-Za-z0-9_.-]+)`.*/\1/p' \
              | head -n1 || true)"
            if [[ -n "${bare_repo}" ]]; then
              target_repo="${owner}/${bare_repo}"
            fi
          fi

          # 3) Default to caller repo when no hint exists.
          if [[ -z "${target_repo}" ]]; then
            target_repo="${GITHUB_REPOSITORY}"
          fi

          should_run="true"
          skip_reason=""
          if [[ "${has_fugue}" != "true" || "${has_tutti}" != "true" ]]; then
            should_run="false"
            skip_reason="missing-required-labels"
          elif [[ "${ci_execution_engine}" == "subscription" && "${subscription_offline_policy}" == "hold" && "${emergency_continuity_mode}" != "true" && "${self_hosted_online_count}" == "0" ]]; then
            should_run="false"
            skip_reason="subscription-self-hosted-offline-strict"
          fi

          {
            echo "issue_number=${ISSUE_NUMBER}"
            echo "has_implement_request=${has_implement}"
            echo "has_implement_confirmed=${has_implement_confirmed}"
            echo "self_hosted_online_count=${self_hosted_online_count}"
            echo "subscription_runner_label=${subscription_runner_label}"
            echo "subscription_offline_policy=${subscription_offline_policy}"
            echo "trust_subject=${trust_subject}"
            echo "target_repo=${target_repo}"
            echo "orchestrator_provider=${requested_main_provider}"
            echo "main_orchestrator_provider=${requested_main_provider}"
            echo "assist_orchestrator_provider=${requested_assist_provider}"
            echo "main_provider_source=${main_provider_source}"
            echo "assist_provider_source=${assist_provider_source}"
            echo "nl_hint_applied=${nl_hint_applied}"
            echo "nl_main_hint=${nl_main_hint}"
            echo "nl_assist_hint=${nl_assist_hint}"
            echo "nl_main_reason=${nl_main_reason}"
            echo "nl_assist_reason=${nl_assist_reason}"
            echo "nl_inference_skipped_reason=${nl_inference_skipped_reason}"
            echo "claude_fallback_applied=${main_claude_fallback_applied}"
            echo "claude_fallback_reason=${main_claude_fallback_reason}"
            echo "main_claude_fallback_applied=${main_claude_fallback_applied}"
            echo "main_claude_fallback_reason=${main_claude_fallback_reason}"
            echo "assist_claude_fallback_applied=${assist_claude_fallback_applied}"
            echo "assist_claude_fallback_reason=${assist_claude_fallback_reason}"
            echo "claude_pressure_guard_applied=${claude_pressure_guard_applied}"
            echo "claude_pressure_guard_reason=${claude_pressure_guard_reason}"
            echo "claude_role_policy=${claude_role_policy}"
            echo "claude_degraded_assist_policy=${degraded_assist_policy}"
            echo "translation_gate_decision=${translation_gate_decision}"
            echo "translation_applied=${translation_applied}"
            echo "translation_provider=${translation_provider}"
            echo "translation_score=${translation_score}"
            echo "translation_threshold=${translation_threshold}"
            echo "translation_reason=$(echo "${translation_reason}" | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g')"
            echo "translation_skip_reason=${translation_skip_reason}"
            echo "translation_event=${translation_event}"
            echo "orchestration_profile=${orchestration_profile}"
            echo "preflight_cycles=${preflight_cycles}"
            echo "multi_agent_mode_override=${multi_agent_mode_override}"
            echo "multi_agent_mode_lock=${multi_agent_mode_lock}"
            echo "implementation_dialogue_rounds=${implementation_dialogue_rounds}"
            echo "risk_tier=${risk_tier}"
            echo "risk_score=${risk_score}"
            echo "risk_reasons=${risk_reasons}"
            echo "lessons_required=${lessons_required}"
            echo "correction_signal=${correction_signal}"
            echo "context_budget_initial=${context_budget_initial}"
            echo "context_budget_max=${context_budget_max}"
            echo "context_budget_floor_initial=${context_budget_floor_initial}"
            echo "context_budget_floor_max=${context_budget_floor_max}"
            echo "context_budget_floor_span=${context_budget_floor_span}"
            echo "context_budget_guard_applied=${context_budget_guard_applied}"
            echo "context_budget_guard_reasons=${context_budget_guard_reasons}"
            echo "assist_auto_selected=${assist_auto_selected}"
            echo "force_claude=${force_claude}"
            echo "execution_provider=${execution_provider}"
            echo "execution_profile=${execution_profile}"
            echo "hybrid_conductor_mode=${hybrid_conductor_mode}"
            echo "subscription_offline_policy=${subscription_offline_policy}"
            echo "trust_subject=${trust_subject}"
            echo "allow_processing_rerun=${allow_processing_rerun}"
            echo "vote_instruction<<EOF"
            echo "${vote_instruction}"
            echo "EOF"
            echo "should_run=${should_run}"
            echo "skip_reason=${skip_reason}"
          } >> "${GITHUB_OUTPUT}"

      - name: Comment when subscription strict is paused
        if: ${{ steps.ctx.outputs.should_run != 'true' && steps.ctx.outputs.skip_reason == 'subscription-self-hosted-offline-strict' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          ONLINE_COUNT: ${{ steps.ctx.outputs.self_hosted_online_count }}
          RUNNER_LABEL: ${{ steps.ctx.outputs.subscription_runner_label }}
        run: |
          set -euo pipefail
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Subscription-strict pause: no online self-hosted runner detected for required label \`${RUNNER_LABEL}\` (online=${ONLINE_COUNT}). Task is kept pending; no API continuity fallback was executed. Local fallback: \`./scripts/local/run-local-orchestration.sh --issue ${ISSUE_NUMBER} --repo ${GITHUB_REPOSITORY} --mode enhanced --glm-mode paired --max-parallel 4\`"

      - name: Comment translation gateway decision
        if: ${{ steps.ctx.outputs.should_run == 'true' && steps.ctx.outputs.translation_event == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          DECISION: ${{ steps.ctx.outputs.translation_gate_decision }}
          APPLIED: ${{ steps.ctx.outputs.translation_applied }}
          PROVIDER: ${{ steps.ctx.outputs.translation_provider }}
          SCORE: ${{ steps.ctx.outputs.translation_score }}
          THRESHOLD: ${{ steps.ctx.outputs.translation_threshold }}
          REASON: ${{ steps.ctx.outputs.translation_reason }}
          SKIP_REASON: ${{ steps.ctx.outputs.translation_skip_reason }}
        run: |
          set -euo pipefail
          msg="Translation gateway evaluated by Codex. decision=\`${DECISION}\`, applied=\`${APPLIED}\`, provider=\`${PROVIDER}\`, score=\`${SCORE}\` (threshold=\`${THRESHOLD}\`), reason=\`${REASON}\`."
          if [[ -n "${SKIP_REASON}" ]]; then
            msg="${msg} skip=\`${SKIP_REASON}\`."
          fi
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "${msg}"

      - name: Comment orchestration profile decision
        if: ${{ steps.ctx.outputs.should_run == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue_number }}
          PROFILE: ${{ steps.ctx.outputs.orchestration_profile }}
          PREFLIGHT_CYCLES: ${{ steps.ctx.outputs.preflight_cycles }}
          IMPLEMENT_ROUNDS: ${{ steps.ctx.outputs.implementation_dialogue_rounds }}
          MODE_OVERRIDE: ${{ steps.ctx.outputs.multi_agent_mode_override }}
          MODE_LOCK: ${{ steps.ctx.outputs.multi_agent_mode_lock }}
          RISK_TIER: ${{ steps.ctx.outputs.risk_tier }}
          RISK_SCORE: ${{ steps.ctx.outputs.risk_score }}
          RISK_REASONS: ${{ steps.ctx.outputs.risk_reasons }}
          LESSONS_REQUIRED: ${{ steps.ctx.outputs.lessons_required }}
          BUDGET_INITIAL: ${{ steps.ctx.outputs.context_budget_initial }}
          BUDGET_MAX: ${{ steps.ctx.outputs.context_budget_max }}
          BUDGET_FLOOR_INITIAL: ${{ steps.ctx.outputs.context_budget_floor_initial }}
          BUDGET_FLOOR_MAX: ${{ steps.ctx.outputs.context_budget_floor_max }}
          BUDGET_FLOOR_SPAN: ${{ steps.ctx.outputs.context_budget_floor_span }}
          BUDGET_GUARD_APPLIED: ${{ steps.ctx.outputs.context_budget_guard_applied }}
          BUDGET_GUARD_REASONS: ${{ steps.ctx.outputs.context_budget_guard_reasons }}
          ASSIST_AUTO: ${{ steps.ctx.outputs.assist_auto_selected }}
          MAIN_SOURCE: ${{ steps.ctx.outputs.main_provider_source }}
          ASSIST_SOURCE: ${{ steps.ctx.outputs.assist_provider_source }}
          NL_HINT_APPLIED: ${{ steps.ctx.outputs.nl_hint_applied }}
          NL_MAIN_HINT: ${{ steps.ctx.outputs.nl_main_hint }}
          NL_ASSIST_HINT: ${{ steps.ctx.outputs.nl_assist_hint }}
          NL_SKIP_REASON: ${{ steps.ctx.outputs.nl_inference_skipped_reason }}
        run: |
          set -euo pipefail
          override_display="${MODE_OVERRIDE:-none}"
          nl_note=""
          if [[ "${NL_HINT_APPLIED}" == "true" ]]; then
            nl_note=" natural_language_hint(main=\`${NL_MAIN_HINT:-none}\`, assist=\`${NL_ASSIST_HINT:-none}\`)."
          elif [[ -n "${NL_SKIP_REASON}" ]]; then
            nl_note=" natural_language_hint(skipped=\`${NL_SKIP_REASON}\`)."
          fi
          budget_guard_note=""
          if [[ "${BUDGET_GUARD_APPLIED}" == "true" ]]; then
            budget_guard_note=" context_guard=applied(\`${BUDGET_GUARD_REASONS:-none}\`) floors=\`${BUDGET_FLOOR_INITIAL}/${BUDGET_FLOOR_MAX}/span${BUDGET_FLOOR_SPAN}\`."
          fi
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Orchestration profile resolved: \`${PROFILE}\`. provider_source(main=\`${MAIN_SOURCE}\`, assist=\`${ASSIST_SOURCE}\`). risk_tier=\`${RISK_TIER}\` (score=\`${RISK_SCORE}\`, reasons=\`${RISK_REASONS}\`). preflight_cycles=\`${PREFLIGHT_CYCLES}\`, implementation_dialogue_rounds=\`${IMPLEMENT_ROUNDS}\`, multi_agent_mode_override=\`${override_display}\`, mode_lock=\`${MODE_LOCK}\`, lessons_required=\`${LESSONS_REQUIRED}\`, context_budget=\`${BUDGET_INITIAL}->${BUDGET_MAX}\`, assist_auto=\`${ASSIST_AUTO}\`.${budget_guard_note}${nl_note}"

      - name: Comment fallback decision
        if: ${{ steps.ctx.outputs.should_run == 'true' && (steps.ctx.outputs.main_claude_fallback_applied == 'true' || steps.ctx.outputs.assist_claude_fallback_applied == 'true' || steps.ctx.outputs.claude_pressure_guard_applied == 'true') }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ steps.ctx.outputs.main_claude_fallback_applied }}" == "true" ]]; then
            gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
              --repo "${GITHUB_REPOSITORY}" \
              --remove-label "orchestrator:claude" \
              --add-label "orchestrator:codex" >/dev/null 2>&1 || true
          fi
          if [[ "${{ steps.ctx.outputs.assist_claude_fallback_applied }}" == "true" ]]; then
            gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
              --repo "${GITHUB_REPOSITORY}" \
              --remove-label "orchestrator-assist:claude" \
              --add-label "orchestrator-assist:none" >/dev/null 2>&1 || true
          fi
          if [[ "${{ steps.ctx.outputs.claude_pressure_guard_applied }}" == "true" ]]; then
            target_assist="$(echo "${{ steps.ctx.outputs.assist_orchestrator_provider }}" | tr '[:upper:]' '[:lower:]')"
            gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
              --repo "${GITHUB_REPOSITORY}" \
              --remove-label "orchestrator-assist:claude" >/dev/null 2>&1 || true
            if [[ "${target_assist}" == "codex" || "${target_assist}" == "none" ]]; then
              gh issue edit "${{ steps.ctx.outputs.issue_number }}" \
                --repo "${GITHUB_REPOSITORY}" \
                --add-label "orchestrator-assist:${target_assist}" >/dev/null 2>&1 || true
            fi
          fi
          gh issue comment "${{ steps.ctx.outputs.issue_number }}" \
            --repo "${GITHUB_REPOSITORY}" \
            --body "Orchestrator auto-adjust applied. Main fallback: \`${{ steps.ctx.outputs.main_claude_fallback_applied }}\` (\`${{ steps.ctx.outputs.main_claude_fallback_reason }}\`). Assist fallback: \`${{ steps.ctx.outputs.assist_claude_fallback_applied }}\` (\`${{ steps.ctx.outputs.assist_claude_fallback_reason }}\`). Claude pressure guard: \`${{ steps.ctx.outputs.claude_pressure_guard_applied }}\` (\`${{ steps.ctx.outputs.claude_pressure_guard_reason }}\`). To force Claude for this issue, add label \`orchestrator-force:claude\`."

  # Review mode: Tutti consensus (6+ parallel lanes baseline)
  tutti:
    if: >-
      needs.ctx.outputs.should_run == 'true'
    needs: [ctx]
    permissions:
      issues: write
      contents: read
      actions: write
    uses: ./.github/workflows/fugue-tutti-router.yml
    with:
      issue_number: "${{ needs.ctx.outputs.issue_number }}"
      orchestrator_provider: "${{ needs.ctx.outputs.orchestrator_provider }}"
      main_orchestrator_provider: "${{ needs.ctx.outputs.main_orchestrator_provider }}"
      assist_orchestrator_provider: "${{ needs.ctx.outputs.assist_orchestrator_provider }}"
      force_claude: "${{ needs.ctx.outputs.force_claude }}"
      multi_agent_mode_override: "${{ needs.ctx.outputs.multi_agent_mode_override }}"
      multi_agent_mode_lock: "${{ needs.ctx.outputs.multi_agent_mode_lock }}"
      risk_tier: "${{ needs.ctx.outputs.risk_tier }}"
      ambiguity_translation_gate: "${{ needs.ctx.outputs.translation_gate_decision }}"
      ambiguity_translation_score: "${{ needs.ctx.outputs.translation_score }}"
      claude_sub_trigger: "${{ needs.ctx.outputs.assist_auto_selected }}"
      subscription_offline_policy_override: "${{ needs.ctx.outputs.subscription_offline_policy }}"
      trust_subject: "${{ needs.ctx.outputs.trust_subject }}"
      allow_processing_rerun: "${{ needs.ctx.outputs.allow_processing_rerun }}"
      extra_issue_instruction: "${{ needs.ctx.outputs.vote_instruction }}"
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

  orchestration-scorecard:
    if: >-
      needs.ctx.outputs.should_run == 'true'
    needs: [ctx, tutti]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Post multi-agent / translator scorecard
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.ctx.outputs.issue_number }}
          PROFILE: ${{ needs.ctx.outputs.orchestration_profile }}
          RESOLVED_MULTI_AGENT_MODE: ${{ needs.tutti.outputs.resolved_multi_agent_mode }}
          EXPECTED_LANES: ${{ needs.tutti.outputs.expected_lanes }}
          HIGH_RISK: ${{ needs.tutti.outputs.high_risk }}
          WEIGHTED_VOTE_PASSED: ${{ needs.tutti.outputs.weighted_vote_passed }}
          WEIGHTED_APPROVE_SCORE: ${{ needs.tutti.outputs.weighted_approve_score }}
          WEIGHTED_TOTAL_SCORE: ${{ needs.tutti.outputs.weighted_total_score }}
          APPROVE_COUNT: ${{ needs.tutti.outputs.approve_count }}
          TOTAL_COUNT: ${{ needs.tutti.outputs.total_count }}
          TRANSLATION_DECISION: ${{ needs.ctx.outputs.translation_gate_decision }}
          TRANSLATION_APPLIED: ${{ needs.ctx.outputs.translation_applied }}
          TRANSLATION_PROVIDER: ${{ needs.ctx.outputs.translation_provider }}
          TRANSLATION_SCORE: ${{ needs.ctx.outputs.translation_score }}
          TRANSLATION_THRESHOLD: ${{ needs.ctx.outputs.translation_threshold }}
        run: |
          set -euo pipefail

          clamp_int() {
            local v="$1"
            local lo="$2"
            local hi="$3"
            if (( v < lo )); then
              echo "${lo}"
            elif (( v > hi )); then
              echo "${hi}"
            else
              echo "${v}"
            fi
          }

          run_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}")"
          created_epoch="$(printf '%s' "${run_json}" | jq -r '.created_at | fromdateiso8601')"
          updated_epoch="$(printf '%s' "${run_json}" | jq -r '.updated_at | fromdateiso8601')"
          duration_sec=$((updated_epoch - created_epoch))
          if (( duration_sec < 1 )); then
            duration_sec=1
          fi

          lanes="$(echo "${EXPECTED_LANES:-0}" | tr -cd '0-9')"
          if [[ -z "${lanes}" || "${lanes}" == "0" ]]; then
            lanes=6
          fi

          weighted_total="${WEIGHTED_TOTAL_SCORE:-0}"
          weighted_approve="${WEIGHTED_APPROVE_SCORE:-0}"
          quality_current="$(awk -v a="${weighted_approve}" -v t="${weighted_total}" -v ac="${APPROVE_COUNT:-0}" -v tc="${TOTAL_COUNT:-0}" 'BEGIN {
            q=0;
            if (t+0 > 0) q=(a/t)*100;
            else if (tc+0 > 0) q=(ac/tc)*100;
            if (q < 0) q=0;
            if (q > 100) q=100;
            printf "%.0f", q;
          }')"

          fail_current=45
          if [[ "${HIGH_RISK}" == "true" ]]; then
            fail_current=85
          elif [[ "${WEIGHTED_VOTE_PASSED}" == "true" ]]; then
            fail_current=20
          elif [[ "${WEIGHTED_VOTE_PASSED}" == "false" ]]; then
            fail_current=60
          fi

          mode="$(echo "${RESOLVED_MULTI_AGENT_MODE:-standard}" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          if [[ "${mode}" != "standard" && "${mode}" != "enhanced" && "${mode}" != "max" ]]; then
            mode="standard"
          fi
          if [[ "${mode}" == "standard" ]]; then
            ma_on_quality="$(clamp_int $((quality_current + 8)) 0 100)"
            ma_off_quality="${quality_current}"
            ma_on_fail="$(clamp_int $((fail_current - 8)) 0 100)"
            ma_off_fail="${fail_current}"
            ma_on_time=$((duration_sec * 125 / 100))
            ma_off_time="${duration_sec}"
          else
            ma_on_quality="${quality_current}"
            ma_off_quality="$(clamp_int $((quality_current - 8)) 0 100)"
            ma_on_fail="${fail_current}"
            ma_off_fail="$(clamp_int $((fail_current + 12)) 0 100)"
            ma_on_time="${duration_sec}"
            ma_off_time=$((duration_sec * 78 / 100))
          fi

          translation_current="off"
          if [[ "${TRANSLATION_APPLIED}" == "true" || "${TRANSLATION_DECISION}" == "true" ]]; then
            translation_current="on"
          fi
          if [[ "${translation_current}" == "on" ]]; then
            tr_on_quality="${quality_current}"
            tr_off_quality="$(clamp_int $((quality_current - 6)) 0 100)"
            tr_on_fail="${fail_current}"
            tr_off_fail="$(clamp_int $((fail_current + 9)) 0 100)"
            tr_on_time="${duration_sec}"
            tr_off_time=$((duration_sec * 94 / 100))
          else
            tr_on_quality="$(clamp_int $((quality_current + 2)) 0 100)"
            tr_off_quality="${quality_current}"
            tr_on_fail="$(clamp_int $((fail_current - 2)) 0 100)"
            tr_off_fail="${fail_current}"
            tr_on_time=$((duration_sec * 106 / 100))
            tr_off_time="${duration_sec}"
          fi

          fmt_min() {
            awk -v s="$1" 'BEGIN { printf "%.1f min", s/60 }'
          }

          cat > /tmp/fugue-scorecard.md <<EOF
          ## Orchestration Scorecard (Heuristic)

          - profile: \`${PROFILE}\`
          - current multi-agent mode: \`${mode}\` (lanes=${lanes})
          - current translator state: \`${translation_current}\` (decision=\`${TRANSLATION_DECISION}\`, applied=\`${TRANSLATION_APPLIED}\`, provider=\`${TRANSLATION_PROVIDER}\`, score=\`${TRANSLATION_SCORE}\`/threshold=\`${TRANSLATION_THRESHOLD}\`)
          - run duration observed: $(fmt_min "${duration_sec}")

          ### Multi-agent ON/OFF
          | mode | quality (0-100) | time | failure risk (0-100) |
          |---|---:|---:|---:|
          | ON | ${ma_on_quality} | $(fmt_min "${ma_on_time}") | ${ma_on_fail} |
          | OFF | ${ma_off_quality} | $(fmt_min "${ma_off_time}") | ${ma_off_fail} |

          ### Translator ON/OFF
          | mode | quality (0-100) | time | failure risk (0-100) |
          |---|---:|---:|---:|
          | ON | ${tr_on_quality} | $(fmt_min "${tr_on_time}") | ${tr_on_fail} |
          | OFF | ${tr_off_quality} | $(fmt_min "${tr_off_time}") | ${tr_off_fail} |

          Note: scorecard is an estimated counterfactual from this run (not separate A/B executions).
          EOF

          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body-file /tmp/fugue-scorecard.md

  # Implement mode: if Tutti says it's safe AND issue requests implementation, run Codex implement immediately.
  codex-implement:
    if: >-
      needs.ctx.outputs.should_run == 'true' &&
      needs.ctx.outputs.has_implement_request == 'true' &&
      needs.ctx.outputs.has_implement_confirmed == 'true' &&
      needs.tutti.outputs.ok_to_execute == 'true'
    needs: [ctx, tutti]
    uses: ./.github/workflows/fugue-codex-implement.yml
    with:
      issue_number: "${{ needs.ctx.outputs.issue_number }}"
      target_repo: "${{ needs.ctx.outputs.target_repo }}"
      refinement_cycles: "${{ needs.ctx.outputs.preflight_cycles }}"
      implementation_dialogue_rounds: "${{ needs.ctx.outputs.implementation_dialogue_rounds }}"
      orchestration_profile: "${{ needs.ctx.outputs.execution_profile }}"
      risk_tier: "${{ needs.ctx.outputs.risk_tier }}"
      lessons_required: "${{ needs.ctx.outputs.lessons_required }}"
      correction_signal: "${{ needs.ctx.outputs.correction_signal }}"
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      TARGET_REPO_PAT: ${{ secrets.TARGET_REPO_PAT }}

  implement-awaiting-confirmation:
    if: >-
      needs.ctx.outputs.should_run == 'true' &&
      needs.ctx.outputs.has_implement_request == 'true' &&
      needs.ctx.outputs.has_implement_confirmed != 'true' &&
      needs.tutti.outputs.ok_to_execute == 'true'
    needs: [ctx, tutti]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Post confirmation-required notice
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ needs.ctx.outputs.issue_number }}
        run: |
          gh issue comment "${ISSUE_NUMBER}" --repo "${GITHUB_REPOSITORY}" --body "Tutti approved execution, but implementation is blocked because \`implement-confirmed\` is missing. Add that label to proceed."
